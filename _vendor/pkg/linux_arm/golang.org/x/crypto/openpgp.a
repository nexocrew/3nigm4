!<arch>
__.PKGDEF       0           0     0     644     61533     `
go object linux arm go1.6.2 X:none
build id "37289fb3840ac4d02cc543788e07653c7e25c6ee"

$$
package openpgp
	import hash "hash"
	import io "io"
	import rsa "crypto/rsa"
	import crypto "crypto"
	import time "time"
	import armor "golang.org/x/crypto/openpgp/armor"
	import errors "golang.org/x/crypto/openpgp/errors"
	import strconv "strconv"
	import packet "golang.org/x/crypto/openpgp/packet"
	import s2k "golang.org/x/crypto/openpgp/s2k"
	import sha256 "crypto/sha256"
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".NewCanonicalTextHash (@"".h·2 @"hash".Hash) (? @"hash".Hash) { return (&@"".canonicalTextHash{ @"".h:@"".h·2, @"".s:int(0x0) }) }
	var @"".PublicKeyType string
	var @"".PrivateKeyType string
	type @"time".zone struct { @"time".name string; @"time".offset int; @"time".isDST bool }
	type @"time".zoneTrans struct { @"time".when int64; @"time".index uint8; @"time".isstd bool; @"time".isutc bool }
	type @"time".Location struct { @"time".name string; @"time".zone []@"time".zone; @"time".tx []@"time".zoneTrans; @"time".cacheStart int64; @"time".cacheEnd int64; @"time".cacheZone *@"time".zone }
	func (@"time".l·2 *@"time".Location "esc:0x22") String () (? string)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".firstZoneUsed () (? bool)
	func (@"time".l·2 *@"time".Location "esc:0x12") @"time".get () (? *@"time".Location)
	func (@"time".l·6 *@"time".Location "esc:0x32") @"time".lookup (@"time".sec·7 int64) (@"time".name·1 string, @"time".offset·2 int, @"time".isDST·3 bool, @"time".start·4 int64, @"time".end·5 int64)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".lookupFirstZone () (? int)
	func (@"time".l·4 *@"time".Location "esc:0x1") @"time".lookupName (@"time".name·5 string "esc:0x1", @"time".unix·6 int64) (@"time".offset·1 int, @"time".isDST·2 bool, @"time".ok·3 bool)
	type @"time".Duration int64
	func (@"time".d·2 @"time".Duration) Hours () (? float64) { var @"time".hour·3 @"time".Duration; ; @"time".hour·3 = @"time".d·2 / @"time".Duration(0x34630b8a000); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x34630b8a000); return float64(@"time".hour·3) + float64(@"time".nsec·4) * float64(8190022623310637111963488201822504381538623676021880892417778544696899264837610290203272971060556344039023584360473938041055625214280336402169897364226048p-553) }
	func (@"time".d·2 @"time".Duration) Minutes () (? float64) { var @"time".min·3 @"time".Duration; ; @"time".min·3 = @"time".d·2 / @"time".Duration(0xdf8475800); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0xdf8475800); return float64(@"time".min·3) + float64(@"time".nsec·4) * float64(7678146209353722106395056769533233877065564876941352542109479049699919628723768656821910653339403201031675627614471533358284117434246264392176261853609984p-547) }
	func (@"time".d·2 @"time".Duration) Nanoseconds () (? int64) { return int64(@"time".d·2) }
	func (@"time".d·2 @"time".Duration) Seconds () (? float64) { var @"time".sec·3 @"time".Duration; ; @"time".sec·3 = @"time".d·2 / @"time".Duration(0x3b9aca00); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x3b9aca00); return float64(@"time".sec·3) + float64(@"time".nsec·4) * float64(7198262071269114660816079141112770740375861891461678802759824945047098083990024106014198994535558872472104883612039846078596891298747423852523262413111296p-541) }
	func (@"time".d·2 @"time".Duration) String () (? string)
	type @"time".Month int
	func (@"time".m·2 @"time".Month) String () (? string) { return @"time".months[@"time".m·2 - @"time".Month(0x1)] }
	type @"time".Weekday int
	func (@"time".d·2 @"time".Weekday) String () (? string) { return @"time".days[@"time".d·2] }
	type @"time".Time struct { @"time".sec int64; @"time".nsec int32; @"time".loc *@"time".Location }
	func (@"time".t·2 @"time".Time "esc:0x12") Add (@"time".d·3 @"time".Duration) (? @"time".Time) { @"time".t·2.@"time".sec += int64(@"time".d·3 / @"time".Duration(0x3b9aca00)); var @"time".nsec·4 int32; ; @"time".nsec·4 = int32(@"time".t·2.@"time".nsec) + int32(@"time".d·3 % @"time".Duration(0x3b9aca00)); if @"time".nsec·4 >= int32(0x3b9aca00) { @"time".t·2.@"time".sec++; @"time".nsec·4 -= int32(0x3b9aca00) } else { if @"time".nsec·4 < int32(0x0) { @"time".t·2.@"time".sec--; @"time".nsec·4 += int32(0x3b9aca00) } }; @"time".t·2.@"time".nsec = @"time".nsec·4; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") AddDate (@"time".years·3 int, @"time".months·4 int, @"time".days·5 int) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") After (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec > @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec > @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") AppendFormat (@"time".b·3 []byte "esc:0x1a", @"time".layout·4 string "esc:0x9") (? []byte)
	func (@"time".t·2 @"time".Time "esc:0x1") Before (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec < @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec < @"time".u·3.@"time".nsec }
	func (@"time".t·4 @"time".Time "esc:0x1") Clock () (@"time".hour·1 int, @"time".min·2 int, @"time".sec·3 int)
	func (@"time".t·4 @"time".Time "esc:0x1") Date () (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int)
	func (@"time".t·2 @"time".Time "esc:0x1") Day () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Equal (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec == @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") Format (@"time".layout·3 string "esc:0x9") (? string)
	func (@"time".t·2 *@"time".Time "esc:0x1") GobDecode (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·3 @"time".Time "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Hour () (? int)
	func (@"time".t·3 @"time".Time "esc:0x1") ISOWeek () (@"time".year·1 int, @"time".week·2 int)
	func (@"time".t·2 @"time".Time "esc:0x12") In (@"time".loc·3 *@"time".Location "esc:0x12") (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") IsZero () (? bool) { return @"time".t·2.@"time".sec == int64(0x0) && @"time".t·2.@"time".nsec == int32(0x0) }
	func (@"time".t·2 @"time".Time "esc:0x12") Local () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".Local; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") Location () (? *@"time".Location) { var @"time".l·3 *@"time".Location; ; @"time".l·3 = @"time".t·2.@"time".loc; if @"time".l·3 == nil { @"time".l·3 = @"time".UTC }; return @"time".l·3 }
	func (@"time".t·3 @"time".Time "esc:0x1") MarshalBinary () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalText () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Minute () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Month () (? @"time".Month)
	func (@"time".t·2 @"time".Time "esc:0x1") Nanosecond () (? int) { return int(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 @"time".Time "esc:0x12") Round (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") Second () (? int)
	func (@"time".t·2 @"time".Time "esc:0x9") String () (? string)
	func (@"time".t·2 @"time".Time "esc:0x1") Sub (@"time".u·3 @"time".Time "esc:0x1") (? @"time".Duration)
	func (@"time".t·2 @"time".Time "esc:0x12") Truncate (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x12") UTC () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".UTC; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x1") Unix () (? int64) { return @"time".t·2.@"time".sec + int64(-0xe7791f700) }
	func (@"time".t·2 @"time".Time "esc:0x1") UnixNano () (? int64) { return (@"time".t·2.@"time".sec + int64(-0xe7791f700)) * int64(0x3b9aca00) + int64(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalBinary (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalJSON (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalText (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 @"time".Time "esc:0x1") Weekday () (? @"time".Weekday)
	func (@"time".t·2 @"time".Time "esc:0x1") Year () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") YearDay () (? int)
	func (@"time".t·3 @"time".Time "esc:0x32") Zone () (@"time".name·1 string, @"time".offset·2 int)
	func (@"time".t·2 @"time".Time "esc:0x1") @"time".abs () (? uint64)
	func (@"time".t·5 @"time".Time "esc:0x1") @"time".date (@"time".full·6 bool) (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int, @"time".yday·4 int)
	func (@"time".t·4 @"time".Time "esc:0x32") @"time".locabs () (@"time".name·1 string, @"time".offset·2 int, @"time".abs·3 uint64)
	type @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm uint8
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanEncrypt () (? bool)
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanSign () (? bool)
	type @"golang.org/x/crypto/openpgp/packet".parsedMPI struct { @"golang.org/x/crypto/openpgp/packet".bytes []byte; @"golang.org/x/crypto/openpgp/packet".bitLength uint16 }
	import ecdsa "crypto/ecdsa" // indirect
	import elliptic "crypto/elliptic" // indirect
	import big "math/big" // indirect
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".n·3 int32) (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".n·3 int64) (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".n·3 int) (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".n·3 int) (? []int)
	func (@"math/rand".r·3 *@"math/rand".Rand "esc:0x9") Read (@"math/rand".p·4 []byte "esc:0x1") (@"math/rand".n·1 int, @"math/rand".err·2 error)
	func (@"math/rand".r·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seed·2 int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".z·2 @"math/big".nat) @"math/big".add (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".x·3 @"math/big".nat "esc:0x1", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".i·3 uint) (? uint) { var @"math/big".j·4 uint; ; @"math/big".j·4 = @"math/big".i·3 / uint(0x20); if @"math/big".j·4 >= uint(len(@"math/big".x·2)) { return uint(0x0) }; return uint(@"math/big".x·2[@"math/big".j·4] >> (@"math/big".i·3 % uint(0x20)) & @"math/big".Word(0x1)) }
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".z·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".buf·3 []byte "esc:0x1") (@"math/big".i·1 int)
	func (@"math/big".z·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".y·3 @"math/big".nat "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".q·1 @"math/big".nat) @"math/big".convertWords (@"math/big".s·2 []byte "esc:0x1", @"math/big".b·3 @"math/big".Word, @"math/big".ndigits·4 int, @"math/big".bb·5 @"math/big".Word, @"math/big".table·6 []@"math/big".divisor "esc:0x9")
	func (@"math/big".z·3 @"math/big".nat) @"math/big".div (@"math/big".z2·4 @"math/big".nat, @"math/big".u·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".u·4 @"math/big".nat, @"math/big".uIn·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat) @"math/big".divW (@"math/big".x·4 @"math/big".nat, @"math/big".y·5 @"math/big".Word) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNN (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expWW (@"math/big".x·3 @"math/big".Word, @"math/big".y·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".itoa (@"math/big".neg·3 bool, @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".n·3 int) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat) @"math/big".modW (@"math/big".d·3 @"math/big".Word) (@"math/big".r·1 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".montgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat, @"math/big".k·6 @"math/big".Word, @"math/big".n·7 int) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mul (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".Word, @"math/big".r·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulRange (@"math/big".a·3 uint64, @"math/big".b·4 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".n·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".reps·3 int) (? bool)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".rand·3 *@"math/rand".Rand "esc:0x9", @"math/big".limit·4 @"math/big".nat "esc:0x1", @"math/big".n·5 int) (? @"math/big".nat)
	func (@"math/big".z·5 @"math/big".nat) @"math/big".scan (@"math/big".r·6 @"io".ByteScanner, @"math/big".base·7 int, @"math/big".fracOk·8 bool) (@"math/big".res·1 @"math/big".nat, @"math/big".b·2 int, @"math/big".count·3 int, @"math/big".err·4 error)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".x·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".i·4 uint, @"math/big".b·5 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".buf·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".x·3 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".x·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shl (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shr (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".i·3 uint) (? uint)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".sub (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".utoa (@"math/big".base·3 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") And (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Append (@"math/big".buf·3 []byte "esc:0x1a", @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".n·3 int64, @"math/big".k·4 int64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".i·3 int) (? uint)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".x·2.@"math/big".abs }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".y·3 *@"math/big".Int "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".m·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x1", @"math/big".m·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·1 *@"math/big".Int "esc:0x9") Format (@"math/big".s·2 @"fmt".State, @"math/big".ch·3 rune)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9", @"math/big".a·5 *@"math/big".Int "esc:0x9", @"math/big".b·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".buf·3 []byte "esc:0x1") (? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".v·3 int64; ; @"math/big".v·3 = int64(@"math/big".low64(@"math/big".x·2.@"math/big".abs)); if @"math/big".x·2.@"math/big".neg { @"math/big".v·3 = -@"math/big".v·3 }; return @"math/big".v·3 }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".text·1 []byte, @"math/big".err·2 error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".g·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".a·3 int64, @"math/big".b·4 int64) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".n·3 int) (? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".r·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rnd·3 *@"math/rand".Rand "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".s·3 @"fmt".ScanState, @"math/big".ch·4 rune) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".i·4 int, @"math/big".b·5 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".abs·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".buf·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".x·3 int64) (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".s·4 string, @"math/big".base·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".x·3 uint64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".x·2.@"math/big".abs) == int(0x0) { return int(0x0) }; if @"math/big".x·2.@"math/big".neg { return int(-0x1) }; return int(0x1) }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Text (@"math/big".base·3 int) (? string)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".x·2.@"math/big".abs) }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".a·3 *@"math/big".Int "esc:0x9", @"math/big".b·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrt3Mod4Prime (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrtTonelliShanks (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".r·5 @"io".ByteScanner, @"math/big".base·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int; Name string }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Add (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Double (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x9") IsOnCurve (@"crypto/elliptic".x·3 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·4 *@"math/big".Int "esc:0x9") (? bool)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x12") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curve·2 }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarBaseMult (@"crypto/elliptic".k·4 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarMult (@"crypto/elliptic".Bx·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".By·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".k·6 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z1·7 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·8 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·9 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z2·10 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".x·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·6 *@"math/big".Int "esc:0x9") (@"crypto/elliptic".xOut·1 *@"math/big".Int, @"crypto/elliptic".yOut·2 *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".x·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"crypto/ecdsa".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"io".Writer interface { Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"golang.org/x/crypto/openpgp/packet".ecdsaKey struct { @"golang.org/x/crypto/openpgp/packet".oid []byte; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x1) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".oid) + int(0x2) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".p.@"golang.org/x/crypto/openpgp/packet".bytes) }
	func (@"golang.org/x/crypto/openpgp/packet".f·3 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".newECDSA () (? *@"crypto/ecdsa".PublicKey, ? error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".kdfHashFunction uint8
	type @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm uint8
	type @"golang.org/x/crypto/openpgp/packet".ecdhKdf struct { KdfHash @"golang.org/x/crypto/openpgp/packet".kdfHashFunction; KdfAlgo @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x4) }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureType uint8
	type @"crypto".Hash uint
	func (@"crypto".h·2 @"crypto".Hash) Available () (? bool) { return @"crypto".h·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".h·2] != nil }
	func (@"crypto".h·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".h·2 }
	func (@"crypto".h·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".h·2 @"crypto".Hash) Size () (? int)
	type @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType uint8
	type @"golang.org/x/crypto/openpgp/packet".outputSubpacket struct { @"golang.org/x/crypto/openpgp/packet".hashed bool; @"golang.org/x/crypto/openpgp/packet".subpacketType @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType; @"golang.org/x/crypto/openpgp/packet".isCritical bool; @"golang.org/x/crypto/openpgp/packet".contents []byte }
	import cipher "crypto/cipher" // indirect
	type @"crypto/cipher".Block interface { BlockSize() (? int); Decrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte); Encrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte) }
	type @"golang.org/x/crypto/openpgp/packet".CipherFunction uint8
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) KeySize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".blockSize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".new (@"golang.org/x/crypto/openpgp/packet".key·3 []byte "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".block·1 @"crypto/cipher".Block)
	type @"golang.org/x/crypto/openpgp/packet".PrivateKey struct { ? @"golang.org/x/crypto/openpgp/packet".PublicKey; Encrypted bool; @"golang.org/x/crypto/openpgp/packet".encryptedData []byte; @"golang.org/x/crypto/openpgp/packet".cipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; @"golang.org/x/crypto/openpgp/packet".s2k func(@"golang.org/x/crypto/openpgp/packet".out []byte, @"golang.org/x/crypto/openpgp/packet".in []byte); PrivateKey interface {}; @"golang.org/x/crypto/openpgp/packet".sha1Checksum bool; @"golang.org/x/crypto/openpgp/packet".iv []byte }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Decrypt (@"golang.org/x/crypto/openpgp/packet".passphrase·3 []byte) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseDSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseElGamalPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parsePrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseRSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".CompressionAlgo uint8
	type @"golang.org/x/crypto/openpgp/packet".CompressionConfig struct { Level int }
	type @"golang.org/x/crypto/openpgp/packet".Config struct { Rand @"io".Reader; DefaultHash @"crypto".Hash; DefaultCipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; Time func() (? @"time".Time); DefaultCompressionAlgo @"golang.org/x/crypto/openpgp/packet".CompressionAlgo; CompressionConfig *@"golang.org/x/crypto/openpgp/packet".CompressionConfig; S2KCount int; RSABits int }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Cipher () (? @"golang.org/x/crypto/openpgp/packet".CipherFunction) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint8(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher) == uint8(0x0) { return @"golang.org/x/crypto/openpgp/packet".CipherFunction(0x7) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Compression () (? @"golang.org/x/crypto/openpgp/packet".CompressionAlgo) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil { return @"golang.org/x/crypto/openpgp/packet".CompressionAlgo(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCompressionAlgo }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Hash () (? @"crypto".Hash) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash) == uint(0x0) { return @"crypto".Hash(0x5) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x32") Now () (? @"time".Time)
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") PasswordHashIterations () (? int) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount == int(0x0) { return int(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x22") Random () (? @"io".Reader) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.Rand == nil { return @"crypto/rand".Reader }; return @"golang.org/x/crypto/openpgp/packet".c·2.Rand }
	type @"golang.org/x/crypto/openpgp/packet".Signature struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashSuffix []byte; HashTag [2]byte; CreationTime @"time".Time; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".rawSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket; SigLifetimeSecs *uint32; KeyLifetimeSecs *uint32; PreferredSymmetric []uint8; PreferredHash []uint8; PreferredCompression []uint8; IssuerKeyId *uint64; IsPrimaryId *bool; FlagsValid bool; FlagCertify bool; FlagSign bool; FlagEncryptCommunications bool; FlagEncryptStorage bool; RevocationReason *uint8; RevocationReasonText string; MDC bool; EmbeddedSignature *@"golang.org/x/crypto/openpgp/packet".Signature; @"golang.org/x/crypto/openpgp/packet".outSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x1") KeyExpired (@"golang.org/x/crypto/openpgp/packet".currentTime·3 @"time".Time "esc:0x1") (? bool) { if @"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs == nil { return bool(false) }; var @"golang.org/x/crypto/openpgp/packet".expiry·4 @"time".Time; ; @"golang.org/x/crypto/openpgp/packet".expiry·4 = @"golang.org/x/crypto/openpgp/packet".sig·2.CreationTime.Add(@"time".Duration(*@"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs) * @"time".Duration(0x3b9aca00)); return @"golang.org/x/crypto/openpgp/packet".currentTime·3.After(@"golang.org/x/crypto/openpgp/packet".expiry·4) }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") Sign (@"golang.org/x/crypto/openpgp/packet".h·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignKey (@"golang.org/x/crypto/openpgp/packet".pub·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey, @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignUserId (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".priv·5 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildHashSuffix () (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildSubpackets () (@"golang.org/x/crypto/openpgp/packet".subpackets·1 []@"golang.org/x/crypto/openpgp/packet".outputSubpacket)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".signPrepareHash (@"golang.org/x/crypto/openpgp/packet".h·4 @"hash".Hash) (@"golang.org/x/crypto/openpgp/packet".digest·1 []byte, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureV3 struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; CreationTime @"time".Time; IssuerKeyId uint64; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashTag [2]byte; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".PublicKey struct { CreationTime @"time".Time; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; PublicKey interface {}; Fingerprint [20]byte; KeyId uint64; IsSubkey bool; @"golang.org/x/crypto/openpgp/packet".n @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".e @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".q @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".g @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".y @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".ec *@"golang.org/x/crypto/openpgp/packet".ecdsaKey; @"golang.org/x/crypto/openpgp/packet".ecdh *@"golang.org/x/crypto/openpgp/packet".ecdhKdf }
	func (@"golang.org/x/crypto/openpgp/packet".pk·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") BitLength () (@"golang.org/x/crypto/openpgp/packet".bitLength·1 uint16, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") CanSign () (? bool) { return @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x2) && @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x10) }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdShortString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") SerializeSignaturePrefix (@"golang.org/x/crypto/openpgp/packet".h·2 @"io".Writer)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyKeySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyRevocationSignature (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignatureV3 (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignature (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignatureV3 (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseDSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseElGamal (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseRSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serializeWithoutHeaders (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".setFingerPrintAndKeyId ()
	type @"golang.org/x/crypto/openpgp/packet".UserId struct { Id string; Name string; Comment string; Email string }
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x1") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"".Identity struct { Name string; UserId *@"golang.org/x/crypto/openpgp/packet".UserId; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature; Signatures []*@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Subkey struct { PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Sig *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Key struct { Entity *@"".Entity; PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Entity struct { PrimaryKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Identities map[string]*@"".Identity; Revocations []*@"golang.org/x/crypto/openpgp/packet".Signature; Subkeys []@"".Subkey }
	func (@"".e·2 *@"".Entity "esc:0x9") Serialize (@"".w·3 @"io".Writer) (? error)
	func (@"".e·2 *@"".Entity "esc:0x9") SerializePrivate (@"".w·3 @"io".Writer, @"".config·4 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func (@"".e·2 *@"".Entity "esc:0x9") SignIdentity (@"".identity·3 string "esc:0x1", @"".signer·4 *@"".Entity, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".encryptionKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	func (@"".e·2 *@"".Entity "esc:0x32") @"".primaryIdentity () (? *@"".Identity)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".signingKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	type @"".KeyRing interface { DecryptionKeys() (? []@"".Key); KeysById(@"".id uint64) (? []@"".Key); KeysByIdUsage(@"".id uint64, @"".requiredUsage byte) (? []@"".Key) }
	type @"".EntityList []*@"".Entity
	func (@"".el·2 @"".EntityList "esc:0x9") DecryptionKeys () (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysById (@"".id·3 uint64) (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysByIdUsage (@"".id·3 uint64, @"".requiredUsage·4 byte) (@"".keys·1 []@"".Key)
	func @"".ReadArmoredKeyRing (@"".r·3 @"io".Reader) (? @"".EntityList, ? error)
	func @"".ReadKeyRing (@"".r·3 @"io".Reader) (@"".el·1 @"".EntityList, @"".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".Packet interface { @"golang.org/x/crypto/openpgp/packet".parse(? @"io".Reader) (? error) }
	type @"golang.org/x/crypto/openpgp/packet".Reader struct { @"golang.org/x/crypto/openpgp/packet".q []@"golang.org/x/crypto/openpgp/packet".Packet; @"golang.org/x/crypto/openpgp/packet".readers []@"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".r·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x3a") Next () (@"golang.org/x/crypto/openpgp/packet".p·1 @"golang.org/x/crypto/openpgp/packet".Packet, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".r·2 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Push (@"golang.org/x/crypto/openpgp/packet".reader·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error) { if len(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers) >= int(0x20) { return @"golang.org/x/crypto/openpgp/errors".StructuralError(@"golang.org/x/crypto/openpgp/errors".StructuralError("too many layers of packets")) }; @"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers = append(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers, @"golang.org/x/crypto/openpgp/packet".reader·3); return nil }
	func (@"golang.org/x/crypto/openpgp/packet".r·1 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Unread (@"golang.org/x/crypto/openpgp/packet".p·2 @"golang.org/x/crypto/openpgp/packet".Packet) { @"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q = append(@"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q, @"golang.org/x/crypto/openpgp/packet".p·2) }
	func @"".ReadEntity (@"".packets·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") (? *@"".Entity, ? error)
	func @"".NewEntity (@"".name·3 string, @"".comment·4 string, @"".email·5 string, @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config) (? *@"".Entity, ? error)
	var @"".SignatureType string
	type @"golang.org/x/crypto/openpgp/packet".LiteralData struct { IsBinary bool; FileName string; Time uint32; Body @"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") ForEyesOnly () (? bool) { return @"golang.org/x/crypto/openpgp/packet".l·2.FileName == string("_CONSOLE") }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"io".ReadCloser interface { Close() (? error); Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"".MessageDetails struct { IsEncrypted bool; EncryptedToKeyIds []uint64; IsSymmetricallyEncrypted bool; DecryptedWith @"".Key; IsSigned bool; SignedByKeyId uint64; SignedBy *@"".Key; LiteralData *@"golang.org/x/crypto/openpgp/packet".LiteralData; UnverifiedBody @"io".Reader; SignatureError error; Signature *@"golang.org/x/crypto/openpgp/packet".Signature; @"".decrypted @"io".ReadCloser }
	type @"".PromptFunction func(@"".keys []@"".Key, @"".symmetric bool) (? []byte, ? error)
	func @"".ReadMessage (@"".r·3 @"io".Reader, @"".keyring·4 @"".KeyRing, @"".prompt·5 @"".PromptFunction "esc:0x10a", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".md·1 *@"".MessageDetails, @"".err·2 error)
	func @"".CheckDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".CheckArmoredDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".DetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func @"".DetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	type @"".FileHints struct { IsBinary bool; FileName string; ModTime @"time".Time }
	type @"io".WriteCloser interface { Close() (? error); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".SymmetricallyEncrypt (@"".ciphertext·3 @"io".Writer, @"".passphrase·4 []byte "esc:0x9", @"".hints·5 *@"".FileHints "esc:0x1", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".Encrypt (@"".ciphertext·3 @"io".Writer, @"".to·4 []*@"".Entity "esc:0x9", @"".signed·5 *@"".Entity "esc:0x12", @"".hints·6 *@"".FileHints "esc:0x1", @"".config·7 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1a") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".init ()
	type @"".canonicalTextHash struct { @"".h @"hash".Hash; @"".s int }
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") BlockSize () (? int)
	func (@"".cth·1 *@"".canonicalTextHash "esc:0x9") Reset ()
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Size () (? int)
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Sum (@"".in·3 []byte) (? []byte)
	func (@"".cth·3 *@"".canonicalTextHash "esc:0x9") Write (@"".buf·4 []byte) (? int, ? error)
	var @"time".months [12]string
	var @"time".days [7]string
	var @"time".Local *@"time".Location
	var @"time".UTC *@"time".Location
	func @"math/big".low64 (@"math/big".z·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".z·2) == int(0x0) { return uint64(0x0) }; var @"math/big".v·3 uint64; ; @"math/big".v·3 = uint64(@"math/big".z·2[int(0x0)]); if true && len(@"math/big".z·2) > int(0x1) { @"math/big".v·3 |= uint64(@"math/big".z·2[int(0x1)]) << uint(0x20) }; return @"math/big".v·3 }
	var @"crypto".hashes []func() (? @"hash".Hash)
	import rand "crypto/rand" // indirect
	var @"crypto/rand".Reader @"io".Reader
	type @"golang.org/x/crypto/openpgp/errors".StructuralError string
	func (@"golang.org/x/crypto/openpgp/errors".s·2 @"golang.org/x/crypto/openpgp/errors".StructuralError "esc:0x1") Error () (? string) { return string("openpgp: invalid data: ") + string(@"golang.org/x/crypto/openpgp/errors".s·2) }

$$
 _go_.o          0           0     0     644     247889    `
go object linux arm go1.6.2 X:none

!
  go13ldhash.acrypto/rsa.aio.atime.aFgolang.org/x/crypto/openpgp/armor.aHgolang.org/x/crypto/openpgp/errors.aHgolang.org/x/crypto/openpgp/packet.acrypto.acrypto/sha256.astrconv.aBgolang.org/x/crypto/openpgp/s2k.a ."".NewCanonicalTextHash     ]*  -  $ (      00  到   R   0l    R  \  X  T       ( $      00                           H "runtime.newobject     runtime.typ2Itab    .runtime.writebarrierptr    0runtime.morestack_noctxt     2type."".canonicalTextHash     (runtime.writeBarrier     Ngo.itab.*"".canonicalTextHash.hash.Hash     4type.*"".canonicalTextHash     type.hash.Hash     Ngo.itab.*"".canonicalTextHash.hash.Hash    (  "".autotmp_0002 4type.*"".canonicalTextHash "".autotmp_0001  4type.*"".canonicalTextHash "".~r1 type.hash.Hash "".h  type.hash.Hash 0*/0    	 Tgclocals·aefd16b155593f6f07980a05b297ad1f Tgclocals·0c8aa8e80191a30eac23f1a218103f16   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go/usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go:"".(*canonicalTextHash).Write  	  	 ]  P-XT@    h l  PD\ H ` L  `H $ D    p$ VV  ,p 0(`  QJ    P  p` 
 P `  X6   U4  A B0  R   
0p`P  T @ 0 8PP<pp@``4  00$ 0/T   P   0           4  00$ 0/X,p(`T@  P    Q \`  U  A B0  R   
0HL D0  T @ 0 D  H  L  4  00$ 0/\ d   h l P   0   g                           $runtime.panicslice          	 $runtime.panicslice   	 0runtime.morestack_noctxt   	  "".newline   	 "".newline   	 "".newline   8  "".autotmp_0011 Gtype.*uint8 "".autotmp_0010 Wtype.int "".autotmp_0009 Otype.int "".autotmp_0008  type.int "".autotmp_0007  type.[]uint8 "".autotmp_0006 /type.[]uint8 "".autotmp_0005 type.[]uint8 "".i _type.int "".~r2 (type.error "".~r1  type.int "".buf type.[]uint8 "".cth  4type.*"".canonicalTextHash   R.

 	  L3 Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f Tgclocals·fdec177485cbfa40ac91f85390ec1fea   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*canonicalTextHash).Sum     ]  (-  < @ D ,   P   0 0  4  8  $ 0  0/@0 <@@0D (0           0runtime.morestack_noctxt   8H  "".~r1  type.[]uint8 
"".in type.[]uint8 "".cth  4type.*"".canonicalTextHash PO # 
Z 
  Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go:"".(*canonicalTextHash).Reset     ]  -   P   0 0 0/  0   p        0runtime.morestack_noctxt     "".cth  4type.*"".canonicalTextHash    b 
  Tgclocals·87d20ce1b58390b294df80b886db78bf Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*canonicalTextHash).Size     ]  -     P   0 0 0/  0   x        0runtime.morestack_noctxt      "".~r0 type.int "".cth  4type.*"".canonicalTextHash ('  
l 
  Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.goB"".(*canonicalTextHash).BlockSize     ]  -     P   0 0 0/  0   x        0runtime.morestack_noctxt      "".~r0 type.int "".cth  4type.*"".canonicalTextHash ('  
t 
  Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*Entity).primaryIdentity     ]3  D-     H                  P  
      P  0   P   0   P  
     P  
L0D        P L D0       
X䁀  runtime.duffzero    &runtime.mapiterinit    &runtime.mapiternext    0runtime.morestack_noctxt     8type.map[string]*"".Identity     "".autotmp_0025 _Btype.map.iter[string]*"".Identity  "".firstIdentity g"type.*"".Identity "".~r0 "type.*"".Identity "".e  type.*"".Entity 3 < (
	 
 + Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa Tgclocals·c00bf85eed6a8e40863dfe64526ae817   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go4"".(*Entity).encryptionKey  "  "<  R X-  ptx|        \  P  lp t  ( p $ l     P ( $ P P   P   @0 (  `@T@d0X0h \ T  P[  
T  PV  
T         RN  
\ `8d<h@lD     P[       P<  1!A@   0   RI    SF    TD      R0  \   P  P@ $1!    P@p`0  T
     W   T    U    P      R  P  P (  (    \   P   $       $p` $   0   P8E!! 0   x |   p`DpH`4080     @0HD   0   48        븀p @0 `pT#"$"P4 8  P @D T4   0 p(@D`x0|p @p`8Q<A@ D ! qp$a`  P@p`ᘀ  T
     W   T   U    P    !     T  0XpL@    P  
\  P      P  :        @0   \QpQtAx1|! X\     L L  P  
L  P)  
\        P!  
L  `HdLhPlT     P       P    \Q\ @\0L pQtAx1| X @pAtAxA|A  X  (,04p`  $   0   PA!! 0       p`<p@`,0008     @0@<   0   ,0        p @0 `P#"$"P, 0  P  @ T&   0 pt@D`!( HQLAPqT(1  D0H H T	    D U   T   U   W    r ʚ;   m  T  0Xp@0    ʚ; golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt     runtime.int64div     runtime.int64div    $runtime.panicindex    8"".(*Entity).primaryIdentity    golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt     runtime.int64div     runtime.int64div   " 0runtime.morestack_noctxt   P  \"".autotmp_0054  type."".Key "".autotmp_0053  type."".Key "".autotmp_0052  type.bool "".autotmp_0051  type.bool "".autotmp_0050  $type.time.Duration "".autotmp_0047  type.bool "".autotmp_0044  $type.time.Duration "".autotmp_0043 type."".Subkey "".autotmp_0042 type.*"".Subkey "".autotmp_0041 type.int "".autotmp_0040 type.int "".autotmp_0039  type.int32 "".autotmp_0038  type.int64 "".autotmp_0037  type.int32 "".autotmp_0036  type.int64 "".autotmp_0035  type.int64 "".autotmp_0034  type.bool "".autotmp_0033  type.int32 "".autotmp_0032  type.int64 "".autotmp_0030  type.int64 "".autotmp_0029 type.int64 "".autotmp_0027  type.[]"".Subkey "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 _type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time time.t·2 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 ?type.time.Time "".i "type.*"".Identity "".subkey type."".Subkey "".i type.int "".maxTime type.time.Time $"".candidateSubkey type.int "".~r2 Htype.bool "".~r1 (type."".Key "".now type.time.Time "".e  type.*"".Entity   |#

@		
		
	  Ds$V^ Tgclocals·7cfe9a03a21b8328cb9dc32a81e0154a Tgclocals·cb89d0b1dc42d7fe829dd0c50f899290   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go."".(*Entity).signingKey    (  R -  048<        P  lp t  ( p $ l     P ( $ P3  P   P   @0 (  `@T@d0X0h \ T  P  
T  P  
T         R  
\   $ ( ,     P       P         P  
  P      P  :        @0   Q0Q4A81<! @      P  
  P   
L  $(,     P       P    Q @00Q4A81< @ @0A4A8A<A  @      p` $   0   PHD!! 0       p`<p@`,000     @0@<   0   ,0        LȀp @0 `|S#"$"P, 0  P @P T'   0 p4@D` 耍pQAq0   <PD0H H T
    < D P   T   U   W    o   l  T  0Xp@P  P (  (       p` $   0   PB!! 0   x |   p`DpH`4080     @0HD   0   48        먀p @0 `PQ#"$"P4 8  P @$ T9   0 p@D`x|p @p`P@   ؀0 pp``  P@p`ᘀ  T     W	   T	   U    P         T  0Xp@0   3 ʚ; zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign    $runtime.panicindex    8"".(*Entity).primaryIdentity     runtime.int64div     runtime.int64div     runtime.int64div     runtime.int64div    0runtime.morestack_noctxt   P  P"".autotmp_0109  type."".Key "".autotmp_0108  type."".Key "".autotmp_0107  type.bool "".autotmp_0106  type.bool "".autotmp_0105  $type.time.Duration "".autotmp_0101  $type.time.Duration "".autotmp_0100 type."".Subkey "".autotmp_0099 type.*"".Subkey "".autotmp_0098 type.int "".autotmp_0097 type.int "".autotmp_0096  type.int32 "".autotmp_0095  type.int64 "".autotmp_0094  type.int32 "".autotmp_0093  type.int64 "".autotmp_0092  type.int64 "".autotmp_0091  type.int32 "".autotmp_0090  type.int64 "".autotmp_0088  type.int64 "".autotmp_0087 type.int64 "".autotmp_0085  type.[]"".Subkey "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 _type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 ?type.time.Time "".i "type.*"".Identity "".subkey type."".Subkey "".i type.int $"".candidateSubkey type.int "".~r2 Htype.bool "".~r1 (type."".Key "".now type.time.Time "".e  type.*"".Entity   L#

	
%	  ?$nr Tgclocals·4db28316a1e41bcee736a1197adee0e9 Tgclocals·6a65d73685d660726632329622a6d393   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".EntityList.KeysById    ĳ  R  -        h  l  p   0 l , h     @ 0 , P  @  88  0@40 SU   TR    4 8              8P4@   P  
      P  0  T  4     8P4@   P      P @0 @  P}  D0 @    0  @  @0      8   P  \` d p` $ \    `$ WH  <`  V ` 0(pP0THXLD00P4  R/   U,    t x |  8 t x0|倀0 @  P   0 @    0  @  @0  t    (p<``p @  @ 0  0 7    P_
     PZ
@a0   <            䁀  runtime.duffzero    &runtime.mapiterinit    &runtime.mapiternext    "runtime.growslice    (runtime.typedmemmove    "runtime.growslice    (runtime.typedmemmove    0runtime.morestack_noctxt     8type.map[string]*"".Identity     type.[]"".Key     type."".Key   @  $"".autotmp_0149 type."".Key "".autotmp_0148 type."".Subkey "".autotmp_0147 type.*"".Subkey "".autotmp_0146 type.int "".autotmp_0145 type.int "".autotmp_0144 type."".Key "".autotmp_0141  type.**"".Entity "".autotmp_0140 type.int "".autotmp_0139 type.int "".autotmp_0138  type.[]"".Subkey "".autotmp_0137 _Btype.map.iter[string]*"".Identity "".autotmp_0135 $type."".EntityList "".subKey type."".Subkey "".selfSig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".e type.*"".Entity "".keys (type.[]"".Key 
"".id type.uint64 
"".el  $type."".EntityList   T
	,	-		
"	  64@* Tgclocals·75e979049760da58a03960363c73f8d8 Tgclocals·7f7e31e410d386547ddc0047dc2faa98   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go6"".EntityList.KeysByIdUsage  
  
 ]  h-       l  p  t  x |    0P@  <P0P@@4@D 8  P4 $ 0    @$ Ut  ,@  T @ p`(PXH\pLp``P`dTH   Q  @PH   PH  P)  
   P&  
  H  P  
  H  P  
  H  P  
  H  P  
      P0 @  P  0 @    0  @  @0  H 4   (P,@0 h0   _         ,"".EntityList.KeysById    "runtime.growslice   	 (runtime.typedmemmove   	 0runtime.morestack_noctxt   
  type.[]"".Key   
  type."".Key   H  "".autotmp_0168 type."".Key "".autotmp_0167 wtype.*"".Key "".autotmp_0166 type.int "".autotmp_0165 type.int "".autotmp_0164  type.uint8 "".autotmp_0163  type.uint8 "".autotmp_0162  type.uint8 "".autotmp_0159 otype.[]"".Key "".autotmp_0158 Wtype.[]"".Key "".key ?type."".Key "".keys 0type.[]"".Key  "".requiredUsage (type.uint8 
"".id type.uint64 
"".el  $type."".EntityList   T	.

$78  p Tgclocals·182a0b7256216f75ea61640d3418698d Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go8"".EntityList.DecryptionKeys  	  	 ]  -        d  h  l  h , d    p, Xs  <p 0  \ X\ ` 0\ $ X     $ SZ  8   R   `P(0L`@`PPDPTHD   P  
@  P  
@  P	  @  P   0  p t x | 4p@ t D x H | 0 @  P  0 @    0  @  @0  p P   40<p(08  p0   o        
 "runtime.growslice    (runtime.typedmemmove    0runtime.morestack_noctxt   	  type.[]"".Key   	  type."".Key   0  "".autotmp_0182 type."".Key "".autotmp_0181 gtype."".Subkey "".autotmp_0180 type.*"".Subkey "".autotmp_0179 type.int "".autotmp_0178 type.int "".autotmp_0176  type.**"".Entity "".autotmp_0175 type.int "".autotmp_0174 type.int "".autotmp_0173 O type.[]"".Subkey "".autotmp_0172 7$type."".EntityList "".subKey type."".Subkey "".e type.*"".Entity "".keys type.[]"".Key 
"".el  $type."".EntityList   ,	3  l Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 Tgclocals·1bcec613e24368dd337b6dd546e388e5   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go*"".ReadArmoredKeyRing     ]  <-  H L P   T X @  D     @ @ 0(0唲  R'  $  0x p     @(0$    P  
L4  8   H L P 0 , ( 4         T  X <$   R  
  H L P T X0<  T @  00 弱  P"  ,  0報 吱     @   P  
  T @        `P@0 H`LPP@T0X <  T @  , 00   P   0 䰟     @   P     +    T @         4  8   H L P T  P  L  4         T  X <0   D                                            (x Pgolang.org/x/crypto/openpgp/armor.Decode    runtime.ifaceeq    runtime.convT2I     runtime.eqstring    "".ReadKeyRing     runtime.eqstring   	 *runtime.concatstring2    runtime.convT2I    0runtime.morestack_noctxt     io.EOF    io.EOF     Bgo.string."no armored data found"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     "".PublicKeyType      "".PublicKeyType    """.PrivateKeyType     """.PrivateKeyType     ngo.string."expected public or private key block, got: "   8p  "".autotmp_0191  type.string "".autotmp_0190 type.string "".autotmp_0187  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0186 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".err /type.error "".block 7Ztype.*golang.org/x/crypto/openpgp/armor.Block "".~r2 (type.error "".~r1 $type."".EntityList "".r  type.io.Reader xwx  ,
6 & $  Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 Tgclocals·07c886799a88ac80d684b8bca7c92573   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".ReadKeyRing     ]  d-  t x     |    p t x h 0 l 4     L P T X \ ` L ,          P  DH@ @   0 4|   R  , @DH, $   8 <   $      (  00|   RP  
  0      |@0   R/  
8@<0$      @@  R  |  @失 圱    |    P  
  |  t   P    R  8 | <  dd|   R
  p t x ( @0      @| 0  S
8 <@$      @@p0t x@  P  0 @    0  @ t x@p0  (T   R         {t      h0   /                            $ "runtime.newobject    "".ReadEntity    $runtime.assertI2T2    ,"".readToNextPublicKey    runtime.ifaceeq   	 $runtime.assertI2T2   	 ,"".readToNextPublicKey   
 "runtime.growslice    .runtime.writebarrierptr    .runtime.writebarrierptr    0runtime.morestack_noctxt     "type.[1]io.Reader     (runtime.writeBarrier     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     io.EOF    io.EOF     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     $type."".EntityList   8  "".autotmp_0196 G type.[]io.Reader "".autotmp_0195 /\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0194 o^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0193  ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 gtype.io.Reader "".e wtype.*"".Entity ."".lastUnsupportedError Wtype.error "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".err (type.error 
"".el $type."".EntityList "".r  type.io.Reader   p0#!)*)*1 * #"
+ Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad Tgclocals·db08f305c468200e3cf791eda6a8ebaa   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".readToNextPublicKey  	  	 ]  @-    H L   8 < D     P8P@<@ 0L0  R  H  0ܱ Ա    8P<@L0H    P   
@H   R  
  0         R  
  H L @     U   
 L PG  0    P
  PD 0P4@(  P0@   Q0    P0@   P0 @(   P  $0 @,P夰   R     0 4x   R  @     @   P   ,P$0 0  0   k                        h bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    runtime.ifaceeq    $runtime.assertI2T2    "runtime.growslice    .runtime.writebarrierptr    .runtime.writebarrierptr   	 0runtime.morestack_noctxt   	  io.EOF   	 io.EOF   	  ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError   	  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey   	  `type.[]golang.org/x/crypto/openpgp/packet.Packet   	  (runtime.writeBarrier   x  
Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 /^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err type.error "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader   H

	0	  -" Tgclocals·725f69b7ae8520ac59af51db7db265d1 Tgclocals·51562c45243a0c5ce48841e15ba48784   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".ReadEntity  J  Jෟ  R -           T               T   P  x   R      T`P@@ 00   R  
    0    P   U   
   P`   $   V `ض   RN  $   Pt       U   
  P=   $   V `|   R+ $   PS   pPt@<  P0@   QE  8 P0@   P0 @<   P  ,0 @\Pܵ   R&     p t尵   R   )                            P   \P,0  V `  Q    R          R   )                      X                00T  R    08 0    0    P  
T   P   
      P                              0 0      0 Sd  `   40T  H           R?  T P0@   Q4   P0@   P0 @T   P  (0 @\P|   R    HX   R   `  4 0        P   \P(0$ ,                    T         R  
    00 00     XpP@ l R  d R{       U   
  P  0`   Pm  
  PT    h  l  @  P0@   QC    P0@   P0 @@   P  (0 @\PH   R$     h l   R  (                                                                78B        P   \P(0T    0   P  0    00   R
    0䀸 Rf       U   
 ` P`   0   PX  
  PA    x  |  D  P0@   Q0   P0@   P0 @D   P  (0 @\P嬷   R     x |倷   R          P   \P(0T            00   RO
    0P@G   0 0 `Ķ R       U   
  P `0   P  
P`    P)  0 @  P   \0 @    P`0  @  @0     R   	   `       P
  W   ,                    P0@   Q0  < P0@   P`P0 @X   P  (0 @\Pܴ   R    Ḵ   R      `     P   P`\P(0ꄴ R\     U   
 d P8 L@    PN
H     L  Q X   R      X   P  LԳ   R X d  T L     P  d          T     00匳  R    0p h    T0    P  
   <   4      R  
    0     P   
  P  0 `   P   -       |                P?  
8`   P;  
X P0@   Q0   P0@   8`P0 @X   P  ,0 @\P圱   R    x   R   v   `   q  P   8`\P,08`   P
 pP 0@40  U W L      `    00   R;  
0 0/0         00            X  T  P              7            Y                        _I                                        X   P  8   R  r     m 0  2       L    ` 0* `   T`5     T`P@    $  `   T`P@    $      x0   R    ` "runtime.newobject    runtime.makemap    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    "runtime.growslice   
 runtime.convT2I   
 .runtime.writebarrierptr    .runtime.writebarrierptr    zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign    runtime.convT2I    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    runtime.ifaceeq    runtime.convT2I    golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyRevocationSignature    "runtime.growslice    .runtime.writebarrierptr    .runtime.writebarrierptr    runtime.convT2I    $runtime.ifacethash    "runtime.growslice     type."".Entity     8type.map[string]*"".Identity     (runtime.writeBarrier     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey      ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey      `type.[]golang.org/x/crypto/openpgp/packet.Packet      jgo.string."first packet was not a public/private key"      ntype.golang.org/x/crypto/openpgp/errors.StructuralError      type.error      go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error      jgo.string."primary key cannot be used for signatures"      io.EOF     io.EOF      Rgo.string."entity without any identities"      htype.[]*golang.org/x/crypto/openpgp/packet.Signature      pgo.string."revocation signature signed by alternate key"   ! .runtime.writebarrierptr   ! .runtime.writebarrierptr   " "".addSubkey   % "runtime.growslice   ' .runtime.writebarrierptr   ( .runtime.writebarrierptr   ( "".addSubkey   , "runtime.growslice   - .runtime.writebarrierptr   / runtime.convT2I   0 "runtime.growslice   2 .runtime.writebarrierptr   3 .runtime.writebarrierptr   4 "runtime.newobject   5 (runtime.typedmemmove   7 $runtime.mapassign1   7 bgolang.org/x/crypto/openpgp/packet.(*Reader).Next   8 runtime.ifaceeq   < runtime.convT2I   = "runtime.growslice   ? .runtime.writebarrierptr   @ .runtime.writebarrierptr   B golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyUserIdSignature   B       C *runtime.concatstring2   D runtime.convT2I   E  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey   E  `type.[]golang.org/x/crypto/openpgp/packet.Packet   E  (runtime.writeBarrier   E  dtype.*golang.org/x/crypto/openpgp/packet.Signature   E  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   E  pgo.string."signature packet found before user id packet"   E  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   E  type.error   E  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   E  ^type.*golang.org/x/crypto/openpgp/packet.UserId   F   type."".Identity   F  type.string   F  8type.map[string]*"".Identity   F  io.EOF   F io.EOF   F  &io.ErrUnexpectedEOF   F &io.ErrUnexpectedEOF   F  rgo.string."user ID packet not followed by self-signature"   F  Xgo.string."user ID self-signature invalid: "   G .runtime.writebarrierptr   G .runtime.writebarrierptr   H .runtime.writebarrierptr   I .runtime.writebarrierptr   I .runtime.writebarrierptr   J .runtime.writebarrierptr   J 0runtime.morestack_noctxt   J  (runtime.writeBarrier      N"".autotmp_0228  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0227 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0226 type.int "".autotmp_0225  type.int "".autotmp_0223  type.bool "".autotmp_0222 _\type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0221  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0220 htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0219  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0218 type.int "".autotmp_0217  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0216  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0215 Otype.string "".autotmp_0214  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0212 "type.*"".Identity "".autotmp_0211  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0209 ?ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".revocation dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt \type.golang.org/x/crypto/openpgp/packet.Packet "".pkt dtype.*golang.org/x/crypto/openpgp/packet.Signature "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt ^type.*golang.org/x/crypto/openpgp/packet.UserId "".err type.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".revocations /htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".current "type.*"".Identity 
"".ok type.bool "".err otype.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".e type.*"".Entity "".~r2 type.error "".~r1 type.*"".Entity "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader 	 	 

0	

		+	T3*)*)	_f3	<"KLKL+[\[\
M		,%&%&
<	=>=,	%
  ^.		<256"8!7#(!
"	/
)' Tgclocals·59a081aa56aea3db12c49708a232e907 Tgclocals·a22f48e06a7657c6080f17b67fc4b601   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".addSubkey     ] X-  l p   L P T d L h P `      ,  0  080ȳ  R  4  0嬳 夳    804    P  
  l |  p X4   R#  
0 0/0    H   D00H      <  @    <         l  p X    ,   P   
  P  0 0T    P  < ' @    <         l  p XL   P  
L  ( P  
4<   @    <         l  p X\  L  T      0804   R#  
0 0/0    x   D00H      <  @ H D @ <         l  p X\ P0 @   Q,    P0@   P0 @\   P  $0  @(P尰   R    L      l p X  P   (P$0   0\0                                                           : bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    runtime.ifaceeq           *runtime.concatstring2    runtime.convT2I    runtime.convT2I   	 runtime.convT2I   
 golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyKeySignature   
        *runtime.concatstring2    runtime.convT2I    "runtime.growslice    (runtime.typedmemmove    .runtime.writebarrierptr    0runtime.morestack_noctxt     io.EOF    io.EOF     &io.ErrUnexpectedEOF    &io.ErrUnexpectedEOF     Lgo.string."subkey signature invalid: "     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     dtype.*golang.org/x/crypto/openpgp/packet.Signature     fgo.string."subkey packet not followed by signature"     Xgo.string."subkey signature with wrong type"      type.[]"".Subkey     (runtime.writeBarrier     type."".Subkey   0  "".autotmp_0258  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0257  type.string "".autotmp_0256  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0255  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0253 7ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0252 'type.string "".err Gtype.error "".p W\type.golang.org/x/crypto/openpgp/packet.Packet "".subKey type."".Subkey "".~r4  type.error "".priv ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".pub dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".e  type.*"".Entity   \
$
$+	 . O	 Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·a3f332e265628a83ebf74125fa889474   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".NewEntity  %  %̷  RM -                    ,   R  
    P  
 ,                0   R  x * |       x                 R 
   Q 
 0 `00d  ,      4  0t0p   R  
    0     R 
   Q 
 0 h00l  ,      8  0t0p   R  
    0        4     P      X         4      T T               P $    0  Q      H0  S 0X   R    S 0TԴ   Rr   S 0P崴   Rd <0     \       RS 
   PO 
(\       0   P  D     D   P  0쳟   R*     @  Q      @@ 唳   R $ (\d   R  <    Q 00    R  D   P     R  D L  < 0     P  L               0  <   P  00   @P   R          8     P      X         8     0     R  
   P~  
$     X  0    @  Q      @@ @   RZ  $ $<    Q 00䰟   R=  @<   P     P              <   R     P        8   P        8     X                                                         @@$     @@ $      S  @   #     @@     @@$     @@      (      H0     H0 0   H0y0 0,  $ 0   0           h` `golang.org/x/crypto/openpgp/packet.(*Config).Now    Xgolang.org/x/crypto/openpgp/packet.NewUserId    runtime.convT2I    ,crypto/rsa.GenerateKey    ,crypto/rsa.GenerateKey   	 dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey   
 fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey   
 runtime.makemap    "runtime.newobject   ꁀ  runtime.duffzero    "runtime.newobject    "runtime.newobject    (runtime.typedmemmove    "runtime.newobject     runtime.duffzero    $runtime.mapassign1    "runtime.makeslice    dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey    fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey    "runtime.newobject     runtime.duffzero    $runtime.panicindex    (runtime.typedmemmove    $runtime.panicindex    $runtime.panicindex     lgo.string."user id field contained invalid characters"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     8type.map[string]*"".Identity     type."".Entity     (runtime.writeBarrier     type.bool      type."".Identity      type.string      btype.golang.org/x/crypto/openpgp/packet.Signature       type.[]"".Subkey      type."".Subkey     .runtime.writebarrierptr     .runtime.writebarrierptr   ! .runtime.writebarrierptr   ! .runtime.writebarrierptr   " .runtime.writebarrierptr   " .runtime.writebarrierptr   " .runtime.writebarrierptr   # .runtime.writebarrierptr   # .runtime.writebarrierptr   $ .runtime.writebarrierptr   $ .runtime.writebarrierptr   % 0runtime.morestack_noctxt   %  $crypto/rand.Reader   % $crypto/rand.Reader   P  >"".autotmp_0274  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0273 Otype."".Subkey "".autotmp_0272 dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0271 "type.*"".Identity "".autotmp_0270 type.*"".Entity "".autotmp_0269  ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0268  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0267 7 type.[]"".Subkey "".autotmp_0266 "type.*"".Identity "".autotmp_0265 8type.map[string]*"".Identity "".autotmp_0264 ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0263 dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0262 _xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".&isPrimaryId type.*bool "".~r0  type.crypto.Hash "".~r0  type.crypto.Hash "".~r0 type.io.Reader "".~r0 type.io.Reader "".e type.*"".Entity """.encryptingPriv 6type.*crypto/rsa.PrivateKey "".err otype.error "".signingPriv 6type.*crypto/rsa.PrivateKey "".uid ^type.*golang.org/x/crypto/openpgp/packet.UserId "".bits type.int "".currentTime type.time.Time "".~r5 @type.error "".~r4 8type.*"".Entity "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".email  type.string "".comment type.string "".name  type.string   
/
	
	 v !#T,3)	.-', Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3 Tgclocals·abdb7871fad8719ab9d9b29665788f59   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go:"".(*Entity).SerializePrivate      R  -                    R   
  X       X     X   PA  
\   X   P  ,        0, @  @  T   
                  R   
,              R   
X     X   P   P  LP T 0P $ L     $ SA   0   R   P @(0@P4PD H<8               R   
<  4              R   
<               R   
0  ( 0    0   :x     tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize   䁀  runtime.duffzero    &runtime.mapiterinit    lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize    tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId    rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    &runtime.mapiternext   	 tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize   
 ngolang.org/x/crypto/openpgp/packet.(*Signature).SignKey   
 rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    0runtime.morestack_noctxt     8type.map[string]*"".Identity   0  "".autotmp_0282 type."".Subkey "".autotmp_0281 type.*"".Subkey "".autotmp_0280 type.int "".autotmp_0279 type.int "".autotmp_0277 w type.[]"".Subkey "".autotmp_0276 _Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err  type.error "".config ^type.*golang.org/x/crypto/openpgp/packet.Config "".w type.io.Writer "".e  type.*"".Entity   p
 


  '5 Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".(*Entity).Serialize    <  R  -              000,   R  
 0  d       d     d   PY  
h   d   P            000,   R  
 0          000,   R  
 0    P  X\` 0\  X      S  (  0         000,   R  
 0(   0d     d   P   P  LP T 0P  L      S4   $   R    P@0@ DP8PH<4          000,   R  
 0<          000,   R  
 0$   0    0   .l     rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize   䁀  runtime.duffzero    &runtime.mapiterinit    lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize    rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    &runtime.mapiternext   
 rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize    rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    0runtime.morestack_noctxt     8type.map[string]*"".Identity   (   "".autotmp_0295 type."".Subkey "".autotmp_0294 type.*"".Subkey "".autotmp_0293  type.int "".autotmp_0292  type.int "".autotmp_0290 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0289 type.int "".autotmp_0288 type.int "".autotmp_0286  type.[]"".Subkey "".autotmp_0285 whtype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0284 _Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err type.error "".~r1 type.error "".w type.io.Writer "".e  type.*"".Entity   l		  


 " 6+ Tgclocals·b385d9a51ca4f468987863aa65654328 Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go2"".(*Entity).SignIdentity     ] d-t   |     P  L & P    L         |   d
  P  
L . P    L         |   dl0p P h D00H     x@0  0  R  L ) P    L         |   d     T  
   P  
$@    T  X  \  ` p    @  Q       t  $8@TX\ `   Rl  $  T @t   Q 00ܱ   RY   ,@@l  p  h  t x       0@0<   R  
| 0d0 P0@   Q4  D P0@   P0 @0   P  (0 @4P   R    ,̰   R     |  d        |  d  P   4P(0     8@$     8@ $ b0                                           0 runtime.convT2I    runtime.convT2I    4runtime.mapaccess2_faststr    runtime.convT2I    `golang.org/x/crypto/openpgp/packet.(*Config).Now    "runtime.newobject     runtime.duffzero   
 tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId    "runtime.growslice    .runtime.writebarrierptr    .runtime.writebarrierptr    .runtime.writebarrierptr    .runtime.writebarrierptr    0runtime.morestack_noctxt     dgo.string."signing Entity must have a private key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     tgo.string."signing Entity's private key must be decrypted"     8type.map[string]*"".Identity     jgo.string."given identity string not found in Entity"     btype.golang.org/x/crypto/openpgp/packet.Signature     (runtime.writeBarrier     htype.[]*golang.org/x/crypto/openpgp/packet.Signature   8  "".autotmp_0302 Wdtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0300 type.time.Time "".autotmp_0299  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0298 ?type.string "".autotmp_0297  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0296 /xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".~r0  type.crypto.Hash "".err Otype.error "".sig odtype.*golang.org/x/crypto/openpgp/packet.Signature "".ident g"type.*"".Identity "".~r3 (type.error "".config  ^type.*golang.org/x/crypto/openpgp/packet.Config "".signer type.*"".Entity "".identity type.string "".e  type.*"".Entity   t	
	+			 * )8<		 Tgclocals·949580c181e84412df3073e61f463446 Tgclocals·ba2c509b55e4bcd7dfa9cabca2e05dcc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".readArmored     ]d  D-      ` d   X \ H  L      0 d `0  S   
D0   R   04088 T P  08PT   0    P	  
  R  X\  ` d D     
  P  T        R           ( < , @ \  X  T  <        0   X \ `0d D0                        Pgolang.org/x/crypto/openpgp/armor.Decode     runtime.eqstring    *runtime.concatstring4    runtime.convT2I    0runtime.morestack_noctxt     ,go.string."expected '"     (go.string."', got: "     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   @  "".autotmp_0307 type.string "".autotmp_0306 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".block 'Ztype.*golang.org/x/crypto/openpgp/armor.Block "".err 0type.error "".body  type.io.Reader "".expectedType type.string "".r  type.io.Reader d q 2	
7  % Tgclocals·537385343e646e25b1b6fced99dbb969 Tgclocals·79d0667feac83fcec4421590bfc5b188   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go"".ReadMessage  J  JL  R X-      x|            \ `        |          P  TXP   儷   R] | TXPX   RM | \ @     t" \     0 @ |xB  T  
  tX0 00     tr@0 Ķ R   Rw     T   
  P P   Pk  
@0!  RP  !  RM  \ @0X  P0@   Q?  8 P0@   P0 @X   P  40 @lPԵ   R       娵   R  \     d h     @0t"xB|2X        P   lP404 . ( $          0   tx2|"X촟 R8       T   
  P d0P   P*  
1!A  P  0 @    0  @ A1  d   R   3      .ܳ R)     T   
  PT     P
P0  DHL    L  H        p     z      h tx|  < x@ ]    t < @ P{ t   P   `P@0aaQQAA11  P  t  t <  < k
  P     Q    p       R
P  k 	  P                  $0|2x"  R  
  R   0報 嘱       P  
   P
kt  Q    X    tL   R  P\ T $        T@0 00         QG                  0 0 00     P  
  t x |X                sRjq%                        :>                                    \  t d h     @0t"xB|2X P0@   Q4   P0@   P0 @T   P  00 @lP   R     唷   R   0       0   P   lP00P     [  tX  P      R  @0   h! lA@p   0 0  h  00         QD1H!LA  P)  P0 @    0  @ HLAD1  g         ,  h    ,     HH  P    P   0匵    tx2|"Xl  P  \ 0X    tx2|"X!D H L   Rv     lr 1/   $ (  $00   R  
  tx"|2X!  R
   P
\`d 0`8 W    8 Sp  D0   $ (    `8aP<Q@@A  $0(  0  S&  P    `P@         $00   R  
  R   0夳 圳    0    P	  
   P`p  D 0  tx"|2X   0    d  Pi P R     T   
  P  P   Pܲ R       T   
  P  `P   P  
``  HL P0@   Q  l P0@   ``P0 @t  P  40 @lP   R    HL      P    ,04 @ 0  Rq    Tn  h d 0/@0 ,AA0114!! 0<     < SKx   R   @0QA1!  QQAA11!!` 1!A  P.  0 @    0  @ A1  u T   x  @ 0                             ^     	}                   h d 0/@0   Ps
  Pp
  P   ``lP40[Y꘰ R   T   
 | P      P     P ` P P          0   _֤     "runtime.newobject    "runtime.newobject    "runtime.newobject    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    $runtime.ifacethash   	 "runtime.growslice    ("".readSignedMessage    .runtime.writebarrierptr    .runtime.writebarrierptr    runtime.convT2I    "runtime.growslice    .runtime.writebarrierptr   ҁ  runtime.duffzero    runtime.makemap    tgolang.org/x/crypto/openpgp/packet.(*EncryptedKey).Decrypt    golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt    runtime.ifaceeq    (runtime.typedmemmove    runtime.convI2I     runtime.convT2I   !  \type.golang.org/x/crypto/openpgp/packet.Reader   !  "type.[1]io.Reader   !  (runtime.writeBarrier   !  ,type."".MessageDetails   !  htype.*golang.org/x/crypto/openpgp/packet.LiteralData   !  `type.[]golang.org/x/crypto/openpgp/packet.Packet   !  tgo.string."key material not followed by encrypted message"   "  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   "  type.error   "  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   "  |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   "  type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   "  ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted   "  (type.map[string]bool   "  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   " dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   "  type."".Key   "  type.io.Reader   "  Lgo.string."too many layers of packets"   # ("".readSignedMessage   $ "runtime.growslice   ' .runtime.writebarrierptr   ' .runtime.writebarrierptr   ( .runtime.writebarrierptr   ) 2runtime.slicebytetostring   * 4runtime.mapaccess1_faststr   + "runtime.growslice   - (runtime.typedmemmove   . $runtime.mapassign1   0       3 golang.org/x/crypto/openpgp/packet.(*SymmetricKeyEncrypted).Decrypt   5 golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt   6 runtime.ifaceeq   ; "runtime.growslice   ?       C "runtime.growslice   D (runtime.typedmemmove   D   type.[]io.Reader   D  (runtime.writeBarrier   D  (type.map[string]bool   D  type.[]"".Key   D  type."".Key   E  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   E dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   E  ftype.*golang.org/x/crypto/openpgp/packet.Compressed   E  jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   E  type.[]uint64   E  2type.[]"".keyEnvelopePair   E  .type."".keyEnvelopePair   F       G .runtime.writebarrierptr   I .runtime.writebarrierptr   I .runtime.writebarrierptr   I 0runtime.morestack_noctxt   J  rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature   H	  "".autotmp_0361  type.error "".autotmp_0360 type.io.Reader "".autotmp_0358 ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0357 type.int "".autotmp_0356  type.int "".autotmp_0355  type.error "".autotmp_0354  type.error "".autotmp_0353  type."".Key "".autotmp_0352 .type."".keyEnvelopePair "".autotmp_0351 0type.*"".keyEnvelopePair "".autotmp_0350  type.int "".autotmp_0349  type.int "".autotmp_0348 6type.map.bucket[string]bool "".autotmp_0347 0type.map.hdr[string]bool "".autotmp_0346 type.error "".autotmp_0345 .type."".keyEnvelopePair "".autotmp_0344 type."".Key "".autotmp_0343 type.*"".Key "".autotmp_0342 type.int "".autotmp_0341 type.int "".autotmp_0339 type.uint64 "".autotmp_0336 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0334  type.[]io.Reader "".autotmp_0333 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0332  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0331  type.error "".autotmp_0330  .type.*"".MessageDetails "".autotmp_0329  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0328  type.int "".autotmp_0327 type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0326  type.int "".autotmp_0325  type.int "".autotmp_0324  type.int "".autotmp_0323  type.int "".autotmp_0322 type.bool "".autotmp_0321 type.string "".autotmp_0320  type.bool "".autotmp_0319 type.string "".autotmp_0318 type.[]uint8 "".autotmp_0317  type.int "".autotmp_0316 type.int "".autotmp_0315 2type.[]"".keyEnvelopePair "".autotmp_0314  type.error "".autotmp_0312 ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0311  type.int "".autotmp_0310  type.int "".autotmp_0309 type.[]"".Key Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".err type.error "".err type.error "".key type.[]uint8 "".err type.error "".passphrase type.[]uint8 "".fpr type.string 
"".pk .type."".keyEnvelopePair 0"".candidateFingerprints (type.map[string]bool "".decrypted $type.io.ReadCloser "".candidates type.[]"".Key "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".k type."".Key "".keys type.[]"".Key "".p jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey "".p |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader 
"".se ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted "".pubKeys 2type.[]"".keyEnvelopePair "".symKeys type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err 8type.error 
"".md 0.type.*"".MessageDetails "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".prompt  ,type."".PromptFunction "".keyring type."".KeyRing "".r  type.io.Reader 				 	 040	9!0$	
X	1@_)10
		
).
	1
  	"1,&9>)/5D-2$	-2,Tr $+ Tgclocals·073d2fd56d13eddb795b325d75824174 Tgclocals·d1b731863bfe975d4592d09ee097675c   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go("".readSignedMessage  !  !吷  R	 -             R  X         L P   T X   < @      0 @  @  T  
   L0P |00     p|`P 弶 R       V   
  P @0   P  
  W pt   R  40   Pc  
T    040  S 00   RQ   TX   RC  <@   R5    S 0е   R'  40    R         4   P  l 8 0pd   R  <    <              40     40     40 0   40L  Q'  
  8pĴ    R        p 8  W pl 8 0pX   R  <    <         4  Q  8           4  @   pW䳟 Rz       V   
  P 0@   Pl  
@  S 0 DH  \ `    R  p   d ` \         0 t0x \0` h d0  S
   0  (@P0@   Q4   P0@   P0 @(   P  $0 @0PT   R    D H(   R    0       0  P   0P$0 R     V   
  P   0   P
  P                0    0 ,     0,@ T  X  <  @        R  
   $  0( ,0        0/         R.  ڴ   P     R           R  07`    jq%                                         ^                        ֤                0        0{ 0 @ @ 060   Z "runtime.newobject    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    $runtime.ifacethash    "runtime.newobject     runtime.typ2Itab   	 .runtime.writebarrierptr   
 .runtime.writebarrierptr   
 .runtime.writebarrierptr    .runtime.writebarrierptr    .runtime.writebarrierptr     runtime.typ2Itab    .runtime.writebarrierptr    (runtime.typedmemmove    .runtime.writebarrierptr    runtime.convT2I    "runtime.growslice    .runtime.writebarrierptr    .runtime.writebarrierptr    runtime.convT2I    &"".hashForSignature           $runtime.panicindex     ,type."".MessageDetails     htype.*golang.org/x/crypto/openpgp/packet.LiteralData     (runtime.writeBarrier     8type."".signatureCheckReader     Tgo.itab.*"".signatureCheckReader.io.Reader     :type.*"".signatureCheckReader     type.io.Reader     Tgo.itab.*"".signatureCheckReader.io.Reader     @go.itab."".checkReader.io.Reader     &type."".checkReader     @go.itab."".checkReader.io.Reader     ftype.*golang.org/x/crypto/openpgp/packet.Compressed     Lgo.string."too many layers of packets"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error      type.[]io.Reader     rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature     :go.string."nested signatures"     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     .runtime.writebarrierptr   ! 0runtime.morestack_noctxt   8  0"".autotmp_0394  type.*uint8 "".autotmp_0392 :type.*"".signatureCheckReader "".autotmp_0391  type.error "".autotmp_0390 Wtype.error "".autotmp_0387 G\type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0386 &type."".checkReader "".autotmp_0385  :type.*"".signatureCheckReader "".autotmp_0384  type.int "".autotmp_0383 7ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0382 'ntype.golang.org/x/crypto/openpgp/errors.StructuralError Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".keys type.[]"".Key "".p rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature "".err wtype.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err (type.error 
"".md  .type.*"".MessageDetails "".keyring type."".KeyRing "".mdin .type.*"".MessageDetails "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader   .
@
	

7'A/0/ Z $/	0 $)%& Tgclocals·32b59a2f714914dd65254a6ea209e9bc Tgclocals·5532e819bd29530b183fefa3baac8db4   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go&"".hashForSignature     ]  L-P0  X \   ` d   h l    S  *  S  :         P  
    R(  0   0    l   D00H      <  @   X \   ` d $    <         h  l L0   TP@,@000    P  X@\0`@d0  h l L  P2  4@80  $ (     0 04 8h   R    0L    R  < 8 4      0, X 0 \ ` d0  h l L      0   0        D00H      <  @   X \   ` d X  T  P  <         h  l L  ^0   ;                                                0 $runtime.panicindex    strconv.Itoa    *runtime.concatstring2    runtime.convT2I    crypto.Hash.New    "runtime.newobject     runtime.typ2Itab   	 .runtime.writebarrierptr   	 strconv.Itoa   
 *runtime.concatstring2    runtime.convT2I    0runtime.morestack_noctxt     crypto.hashes     @go.string."hash not available: "     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     2type."".canonicalTextHash     (runtime.writeBarrier     Ngo.itab.*"".canonicalTextHash.hash.Hash     4type.*"".canonicalTextHash     type.hash.Hash     Ngo.itab.*"".canonicalTextHash.hash.Hash     Pgo.string."unsupported signature type: "   @  "".autotmp_0409 W4type.*"".canonicalTextHash "".autotmp_0406  ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0405  type.string "".autotmp_0404  4type.*"".canonicalTextHash "".autotmp_0403 ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0402 type.string "".~r1 Otype.hash.Hash "".h /type.hash.Hash "".h ?type.hash.Hash "".~r4 0type.error "".~r3  type.hash.Hash "".~r2 type.hash.Hash "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashId   type.crypto.Hash   0)3* " 0" Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea Tgclocals·75b04d23becfbadc005b25375f880226   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go&"".checkReader.Read     ]?  0-      H L   4 4  Q 0 8  <  @  ,  (0 0/ D  0L0H 吰  R   0x p       P  
4   P  L0P $ 0 0/ 0  R  
H L000                   runtime.ifaceeq           0runtime.morestack_noctxt     io.EOF    io.EOF   8X  "".err (type.error "".n  type.int "".buf type.[]uint8 
"".cr  &type."".checkReader `?_` I  
   Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec Tgclocals·64ca935d1a2110a30e2d604686188539   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go>"".(*signatureCheckReader).Read     ]  `-      x |   d 4   P  0 h  l  p  @  <0 0/  x  | t p R  h@`Pd   P  0 T@@X``\PP8  40$ 0/x ܲ  R   | 帲       P  
  $ ( d     d0 $  ( @   Q D@@@H P   R  D @   P   
`    $   P   
  Po  (      Q  䱟   R^  H     P#  L % P    L        0 d   Q D0@0 H `   R  D `D      ` 0       H   d@0   Q D0@0H ذ   R  D L   P  
  Q L0P 0  ,0 0/ 0  R  
x |0`D      d@H      d0      D      d0v   0                                   *               runtime.ifaceeq    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next   	 runtime.convT2I   
 .runtime.writebarrierptr    ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature           .runtime.writebarrierptr    .runtime.writebarrierptr    .runtime.writebarrierptr    $runtime.panicslice    0runtime.morestack_noctxt     io.EOF    io.EOF     (runtime.writeBarrier     dtype.*golang.org/x/crypto/openpgp/packet.Signature     bgo.string."LiteralData not followed by Signature"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   8  "".autotmp_0420 7type.error "".autotmp_0419  type.error "".autotmp_0418 'ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0416 type.[]uint8 
"".ok type.bool "".p w\type.golang.org/x/crypto/openpgp/packet.Packet "".err (type.error "".n  type.int "".buf type.[]uint8 "".scr  :type.*"".signatureCheckReader 	  l



  X#7 Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go2"".CheckDetachedSignature    唷  R -                      ` d  X \            <          P      X \弶   R < < 4 4      `  d 0 !`  S  10 D <    1   P  
  0    1!1  S  
  `0d x00|     x`|P@ĵ T      V   
  PS 0    P  
P@  ( $P@      0/         Rڔ   R                      (  $      h  l 0 @  A  T  
   @00D                   0t0p   R  
   R   0賟 ೟    t0p    P  
       0 ,      , Sz  8   R   `P@00``PP@@`0d x00|     hlpx`|P@ T%       V   
  PN   0   P  
p      !  R     8  0 0ꈲ T       V   
 h P"   0   P  
p      H`LP                        0   0    !1䔱 T0       V   
 t P?  0    P"  
   P  H    < 8 4         0   1! P@ ( $P`TP                  0   1! 0   0       Y0                                           Y                        H "runtime.newobject    bgolang.org/x/crypto/openpgp/packet.(*Reader).Next    runtime.ifaceeq    $runtime.ifacethash   	        runtime.convT2E    runtime.gopanic    &"".hashForSignature    runtime.convI2I    io.Copy    runtime.ifaceeq    $runtime.ifacethash    golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignatureV3    ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature    runtime.convT2E    runtime.gopanic    runtime.convT2I    runtime.convT2I    .runtime.writebarrierptr    0runtime.morestack_noctxt     "type.[1]io.Reader     (runtime.writeBarrier     io.EOF    io.EOF     fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer    fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer     htype.*golang.org/x/crypto/openpgp/packet.SignatureV3     .go.string."unreachable"     type.string     type.io.Writer     dtype.*golang.org/x/crypto/openpgp/packet.Signature     Xgo.string."signature doesn't have an issuer"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     Lgo.string."non signature packet found"   H  L"".autotmp_0449  type.uint32 "".autotmp_0448  type.bool "".autotmp_0447  \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0446 Otype."".Key "".autotmp_0445 type.*"".Key "".autotmp_0444 type.int "".autotmp_0443  type.int "".autotmp_0442  type.error "".autotmp_0441  type.error "".autotmp_0438 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0435  type.[]io.Reader "".autotmp_0434 /\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0433 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0432  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0431  type.string "".autotmp_0430 type.[]"".Key "".autotmp_0429 type.string "".autotmp_0428  type.int "".autotmp_0427 type.int "".autotmp_0426  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0425 ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".key otype."".Key "".err type.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".keys type.[]"".Key "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashFunc  type.crypto.Hash "".err 8type.error "".signer 0type.*"".Entity "".signature  type.io.Reader "".signed type.io.Reader "".keyring  type."".KeyRing   0
	

*
#? > +%+:	:2 Tgclocals·33353b89c8d716aa30f1cbcff483ff29 Tgclocals·510abbe02d5ba0858c7154a80d9fec44   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go@"".CheckArmoredDetachedSignature     ]/  0-      P T   L D  H  嘰   吰      0 @  T P@  T   
04  8  <  @  (00,     @ 0$ L@P0T 00           
 "".readArmored    2"".CheckDetachedSignature    0runtime.morestack_noctxt      "".SignatureType     "".SignatureType   HX  "".body type.io.Reader "".err 8type.error "".signer 0type.*"".Entity "".signature  type.io.Reader "".signed type.io.Reader "".keyring  type."".KeyRing `/_` 9    Tgclocals·3a5692de2bcadad506bd8b6dd1491c00 Tgclocals·c55cf99de9cdd8c8202a466952fa1a45   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go"".DetachSign     ]  (-  D H ,  0  4  8  <     @      0$ D0H (0    "".detachSign    0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer PO  
0 
 	 Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go("".ArmoredDetachSign     ]  (-    D H ,  0  4  8  <     @      0$ D0H (0    ("".armoredDetachSign    0runtime.morestack_noctxt   @H  
"".err 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer PO  
> 
 	 Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go""".DetachSignText     ]  (-  D H ,  0  4  8  <    @      0$ D0H (0    "".detachSign    0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer PO  
N 
 	 Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".ArmoredDetachSignText     ]  (-  D H ,  0  4  8  <    @      0$ D0H (0    ("".armoredDetachSign    0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer PO  
^ 
 	 Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go("".armoredDetachSign     ]C  0-    P T 4  8     찟         0  @$ T P@  T   
0  (00,          <  @  D  H  L       $ T P   R   
0,  (  0/0 P0T 00                Pgolang.org/x/crypto/openpgp/armor.Encode    runtime.convI2I    "".detachSign           0runtime.morestack_noctxt      "".SignatureType     "".SignatureType     type.io.Writer   HX  "".out &type.io.WriteCloser "".err 8type.error "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType (jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer `C_` N "f   Tgclocals·236601f43b36f8c15cf70bb83f74cf9b Tgclocals·21a8f585a14d020f181242c5256583dc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".detachSign     ]  P-\     p t    P  8 & <    8         p  t P
  P  
8  < p l h 8         p  t P@    l@0h \      Tw  
   Pt  
 $0 @   $`P@0  V `@PPD@@H0 0L嬱   RV  $  V `\   Q 00x   RC       0  4 0 @  t p@  T   
P  (00,          `  d     $  0  4  \ l       t p   R   
P$  T  X     0 p0t P     $`$     $` 0   :                                ( runtime.convT2I    runtime.convT2I    "runtime.newobject    `golang.org/x/crypto/openpgp/packet.(*Config).Now    &"".hashForSignature    runtime.convI2I   	 io.Copy   
 hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign   
 rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize    .runtime.writebarrierptr    .runtime.writebarrierptr    0runtime.morestack_noctxt     dgo.string."signing key doesn't have a private key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     Hgo.string."signing key is encrypted"     btype.golang.org/x/crypto/openpgp/packet.Signature     (runtime.writeBarrier     type.io.Writer   H  "".autotmp_0459 type.time.Time "".autotmp_0458  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0457 /xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".wrappedHash Otype.hash.Hash "".h ?type.hash.Hash "".sig Wdtype.*golang.org/x/crypto/openpgp/packet.Signature "".err 8type.error "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType (jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer 	  b~	 "  9	 Tgclocals·69607a593e43f6fa2bc465446e592f44 Tgclocals·ce5958795429f4e02af1bac306c025c7   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go."".SymmetricallyEncrypt    @  R  -  l                  P    l p t x |   l                   `P @$0( ,     R   
    V  
   P  
       @PPD@@H00`   p` P$@( ,     R   
0P8P4@<@    V^    0  S  
    V  
 P@      p       R   
 0  W p@ PTPX  L@P   R3    T0    U.      R    W p0 dh   \0`  0     08<     0   P @$0( P@0     y0   -x 	n@  runtime.duffzero    golang.org/x/crypto/openpgp/packet.SerializeSymmetricKeyEncrypted    golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted    lgolang.org/x/crypto/openpgp/packet.SerializeCompressed    fgolang.org/x/crypto/openpgp/packet.SerializeLiteral    0runtime.morestack_noctxt   X  "".autotmp_0466  type.int64 "".autotmp_0464 7"type."".FileHints time.t·2 Wtype.time.Time time.t·2 wtype.time.Time "".literaldata &type.io.WriteCloser "".w &type.io.WriteCloser "".key type.[]uint8 "".err Htype.error "".plaintext 8&type.io.WriteCloser "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".hints ($type.*"".FileHints "".passphrase type.[]uint8 "".ciphertext  type.io.Writer   d  3 Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f Tgclocals·d02e8ebf325cdf993e86e63fb430cf55   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go."".intersectPreferences     ]K   -     `$  (  ,         p X(   @0  4  8   0      S   P  P  $   V  :      `p 0, V
  $ `  <  @  D     0    $runtime.panicindex    $runtime.panicslice    0runtime.morestack_noctxt   H8  "".autotmp_0481  type.uint8 "".autotmp_0475 7type.int "".autotmp_0473  type.[]uint8 "".autotmp_0472  type.int "".autotmp_0471 /type.[]uint8 "".autotmp_0470 type.[]uint8 "".intersection 0type.[]uint8 "".b type.[]uint8 "".a  type.[]uint8 @K? R ,
 
 -% Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa Tgclocals·709a14768fab2805a378215c02f0d27f   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".hashToHashId     ]   -  $     0	   R  `    T                   (  0           8 Xgolang.org/x/crypto/openpgp/s2k.HashToHashId    runtime.convT2E    runtime.gopanic    0runtime.morestack_noctxt     Rgo.string."tried to convert unknown hash"     type.string   8  "".autotmp_0483 type.string "".~r1 type.uint8 "".h   type.crypto.Hash @?@ ( 	   Tgclocals·c55cf99de9cdd8c8202a466952fa1a45 Tgclocals·d8fdd2a55187867c76648dc792366181   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".Encrypt  L  Lغ  R T-             x|   l  Pj  
t    P@0 l RPB@20"       01$ (   R  
$ (
  
 	 I       0   x|2"T   S  	$ (	 	 	 I       0   x|2"T0
  P  
H	$ ((	 $	  	 I       0   x|2"TL 츟  丟 ܸ !      H       D       @ 	     0  ` a b c `   P  x|t]  H ]  D]  @]  0 @! P  A  B1  R   
 0lp!h1x @x|! P  A  Bt1  R   
 0`d!\1d / ?P@ 0    P T  X  dd d R  h P   t    `P@0&P  Q  :      b`RPB@20       $  ( 4 P  Q  :       } H   P 4   P:  &  Q  :        04       0     #  10 !  "       $$ (h d ` I       0   x|2"T&  Q  :             R  @<@<1  S@  hAl<p@  R  DHLH!  R/  \D`HdL   8A@< @       $ t x | D H L     t  x$ |h  *!  R 
x!  R 
  Q        <t"    R 
   P 
 P 0af     S   @ T  <   T tx| 0d f    d S      h0     0   Pv 
   Sz *  S  :         Pl 
    Pa 
T0t"    RY 
   PU 
 \    RM *,  Q  :         P? 
    R  
tx| 0h f    h S     d0      0  S 
\ R T T   P]  ]  Q          8    @@00   R  8   0       10 !    @0     L  @@00         $$ (L  H  D  I       0   x|2"T                                                                    <      / ?P@ 0   `P @t"    R 
   Q 
 0 00  ,a`0QP4A@     00   R  
  x|"2TPTX 0d c    d S4      R   ` P@h0aa!QQX \ ! <  , 0 4 t     $ (00   R  
  x|"2T  h 0X \ <  , 0 4 t    0 P$@( , "  R   
T  SA  
  t x |    t      T   P       P  0 40 0    PP A@             P A0       P  
  x|  Tp  P     $(,     pPP A@  S  
   P@   E       E             X p  P    0 1  P    S    P    0 0   P  p  P     l p0"  0l pl pX     pp  P       X          $ ( "  R  
  x|T   P2  
T       #.    0 4 8 <T @DH LtP |  #         x|  T x |  T  } 0  g  d 0     h 0s   0V H $@ (      I       0   x|2"T      0   E                     	n                                    @  runtime.duffzero    `golang.org/x/crypto/openpgp/packet.(*Config).Now    ."".(*Entity).signingKey    runtime.convT2I    runtime.convT2I    runtime.convT2I   	 "".hashToHashId   	 "".hashToHashId   	 "".hashToHashId   
 "".hashToHashId    "runtime.makeslice    `golang.org/x/crypto/openpgp/packet.(*Config).Now    $runtime.panicindex    4"".(*Entity).encryptionKey    $runtime.panicindex    (runtime.typedmemmove    $runtime.panicindex    $strconv.FormatUint    *runtime.concatstring3    runtime.convT2I    $runtime.panicindex    8"".(*Entity).primaryIdentity    ."".intersectPreferences    ."".intersectPreferences    $runtime.panicindex   ! Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   ! $runtime.panicindex   # $runtime.panicindex   & Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   ' $runtime.panicindex   ' \golang.org/x/crypto/openpgp/s2k.HashIdToString   ( strconv.Itoa   ) *runtime.concatstring2   * *runtime.concatstring3   + runtime.convT2I   +  Bgo.string."no valid signing keys"   +  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   +  type.error   +  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   +  Rgo.string."no private key in signing key"   +  Rgo.string."signing key must be decrypted"   ,  """.statictmp_0519   , """.statictmp_0519   , """.statictmp_0519   ,  type.[]"".Key   ,  type."".Key   ,  ^go.string."cannot encrypt a message to key id "   ,  \go.string." because it has no encryption keys"   ,  crypto.hashes   ,  go.string."#"   ,  go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   ,  6go.string." in this case.)"   , rgolang.org/x/crypto/openpgp/packet.CipherFunction.KeySize   - "runtime.makeslice   / io.ReadFull   3 pgolang.org/x/crypto/openpgp/packet.SerializeEncryptedKey   5 golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted   8 runtime.convI2I   8 golang.org/x/crypto/openpgp/packet.(*OnePassSignature).Serialize   < runtime.convI2I   = runtime.convT2I   B fgolang.org/x/crypto/openpgp/packet.SerializeLiteral   D crypto.Hash.New   D؃  runtime.duffcopy   F runtime.convT2I   J runtime.convT2I   K $runtime.panicslice   K $runtime.panicslice   K 0runtime.morestack_noctxt   K  type.[]uint8   K  type.io.Writer   K  $type."".noOpCloser   K  &type.io.WriteCloser   K  Hgo.itab."".noOpCloser.io.WriteCloser   L  """.statictmp_0556   L  .type."".signatureWriter   L  Rgo.itab."".signatureWriter.io.WriteCloser   L  $crypto/rand.Reader   L $crypto/rand.Reader   L  go.string."cannot encrypt because recipient set shares no common algorithms"   L  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   L  type.error   L  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   `	  "".autotmp_0557 &type.io.WriteCloser "".autotmp_0555  type.int64 "".autotmp_0554  type.bool "".autotmp_0553 "type."".FileHints "".autotmp_0552 $type.*"".FileHints "".autotmp_0551 ptype.golang.org/x/crypto/openpgp/packet.OnePassSignature "".autotmp_0550 rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature "".autotmp_0549 type."".Key "".autotmp_0548 type.*"".Key "".autotmp_0547  type.int "".autotmp_0546  type.int "".autotmp_0545  type.error "".autotmp_0544 type.[32]uint8 "".autotmp_0543  type.uint8 "".autotmp_0542  type.*uint8 "".autotmp_0541  type.int "".autotmp_0540  type.int "".autotmp_0539  type.bool "".autotmp_0537  type.uint8 "".autotmp_0536  type.*uint8 "".autotmp_0535  type.int "".autotmp_0534  type.int "".autotmp_0533  type.uint8 "".autotmp_0532 type.*uint8 "".autotmp_0531  type.int "".autotmp_0530  type.int "".autotmp_0529  type.error "".autotmp_0528  type.error "".autotmp_0527 type."".Key "".autotmp_0526  type.int "".autotmp_0525  type.int "".autotmp_0524 type.[4]uint8 "".autotmp_0521 type.[3]uint8 "".autotmp_0518  type.error "".autotmp_0517  type.error "".autotmp_0515 G.type."".signatureWriter "".autotmp_0514 type.hash.Hash "".autotmp_0513 $type."".noOpCloser "".autotmp_0512 type.[]"".Key "".autotmp_0511  type.int "".autotmp_0510  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0509  type.string "".autotmp_0508  type.[]uint8 "".autotmp_0507  type.[]uint8 "".autotmp_0506 type.[]uint8 "".autotmp_0505  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0504  type.int "".autotmp_0503  type.int "".autotmp_0502  type.int "".autotmp_0499  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0498 type.string "".autotmp_0497  type.time.Time "".autotmp_0496  type.int "".autotmp_0495  type.int "".autotmp_0494  type.int "".autotmp_0493 type.int "".autotmp_0492 type.int "".autotmp_0490 type.uint8 "".autotmp_0489 type.uint8 "".autotmp_0488 type.uint8 "".autotmp_0487  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0486  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0485 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0484 type.time.Time "".~r0 type.int64 time.t·2 type.time.Time "".~r0 type.bool time.t·2 type.time.Time "".~r0 type.io.Reader "".literalData &type.io.WriteCloser "".epochSeconds type.uint32 "".w &type.io.WriteCloser "".err type.error "".ops rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature  "".encryptedData &type.io.WriteCloser "".err type.error "".key type."".Key "".err type.error "".symKey type.[]uint8 "".name type.string "".hashId type.uint8 """.configuredHash  type.crypto.Hash "".hash  type.crypto.Hash "".cipher ltype.golang.org/x/crypto/openpgp/packet.CipherFunction $"".preferredHashes type.[]uint8 *"".preferredSymmetric type.[]uint8 
"".ok type.bool "".i type.int "".encryptKeys type.[]"".Key  "".defaultHashes type.[]uint8 """.defaultCiphers type.[]uint8 $"".candidateHashes type.[]uint8 &"".candidateCiphers type.[]uint8 "".signKey type."".Key "".signer ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".err Ptype.error "".plaintext @&type.io.WriteCloser "".config 8^type.*golang.org/x/crypto/openpgp/packet.Config "".hints 0$type.*"".FileHints "".signed (type.*"".Entity 
"".to "type.[]*"".Entity "".ciphertext  type.io.Writer 				 	 8;#"	

!
		8 
3Q#	1  )QY

-/9D?&="4	:c$E	 Tgclocals·79278f1b3c02451b235b26e0d050a9f3 Tgclocals·cc9864a176c1d5112af33aade2eb2ba9   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Write     ]%  0-    h l H0L X  \  `  ,  (0$ 0/<0@ X  \  `  $   0 0/@0 d@h0l 00                  0runtime.morestack_noctxt   xX  "".~r2 htype.error "".~r1 `type.int "".data Htype.[]uint8 "".s  .type."".signatureWriter `%_ ,  
  Tgclocals·d9f9402b3f7d1c398b577a45048cc887 Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Close  	  	 ]  X-    |      H  L  P  T     @  Q        \  l$@HLP T帱   R`  $  T @x  Q 00   RN    @@p     x  |      0,0(   R  
 0Xd0h D  @0 0/ 0<08   R  
 0X  \                    0400   R  
 0X\0` D  @0 0/0 0 X     $@$     $@0   f            H `golang.org/x/crypto/openpgp/packet.(*Config).Now    "runtime.newobject     runtime.duffzero    hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign           runtime.convI2I    rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize           .runtime.writebarrierptr   	 .runtime.writebarrierptr   	 0runtime.morestack_noctxt   	  btype.golang.org/x/crypto/openpgp/packet.Signature   	  (runtime.writeBarrier   	  type.io.Writer   X  "".autotmp_0577 gdtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0575 type.time.Time "".err Otype.error "".err ?type.error "".err _type.error "".sig odtype.*golang.org/x/crypto/openpgp/packet.Signature "".~r0 Htype.error "".s  .type."".signatureWriter   L
		  	5+ Tgclocals·5705c76a0bc7db77dc7faa07cb35699a Tgclocals·47e81b9b582fcfba016f557768a0f4be   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Write     ]  (-      D H   ,00 4  8  <  $   0 0/@0 @@D0H (0           0runtime.morestack_noctxt   @H  "".err 0type.error "".n (type.int "".data type.[]uint8 "".c  $type."".noOpCloser PO ! 
 
  Tgclocals·dacebcad73eed5073009fd67170948d0 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Close  (  (           "".~r0 type.error "".c  $type."".noOpCloser     Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".init     ]  -|    P  
l   P       L                                      0       h "runtime.throwinit    hash.init    crypto/rsa.init    io.init    time.init    Lgolang.org/x/crypto/openpgp/armor.init    Ngolang.org/x/crypto/openpgp/errors.init    Ngolang.org/x/crypto/openpgp/packet.init    crypto.init    $crypto/sha256.init    strconv.init    Hgolang.org/x/crypto/openpgp/s2k.init    0runtime.morestack_noctxt     "".initdone·         & & 
  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go>type..hash."".canonicalTextHash    ]  -       P             P               0   ` "runtime.interhash    runtime.memhash    0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  4type.*"".canonicalTextHash (' " " 
  Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go:type..eq."".canonicalTextHash    ])  (-  0   P   0P,   P    @ R    @@ 00$PP      P  
, 0  P  
  4 ( 4 (  4 (0    runtime.ifaceeq    0runtime.morestack_noctxt   H  
"".autotmp_0585 type.hash.Hash "".autotmp_0584 type.hash.Hash "".~r2 type.bool "".q 4type.*"".canonicalTextHash "".p  4type.*"".canonicalTextHash P)O 0 0 
  Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go(type..hash.[8]string    ]  - 0       R      P      00   0  $00    runtime.strhash    0runtime.morestack_noctxt   (  
"".autotmp_0587 type.int "".autotmp_0586 type.int "".~r2 type.uintptr "".h type.uintptr "".p  type.*[8]string 0/ " " 
  Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go$type..eq.[8]string    ]4  0-       R)   04   P   @,8   P    $, $ P  (@@,   $      P  
    < 0 < 00     runtime.eqstring    0runtime.morestack_noctxt   X  "".autotmp_0592 type.string "".autotmp_0591 type.string "".autotmp_0590 /type.int "".autotmp_0589 'type.int "".~r2 type.bool "".q type.*[8]string "".p  type.*[8]string `4_ ; ; 
 * Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go2"".(*EntityList).KeysById     ]4  $-  Q  
  (0 S  @ @    4 8 < (   P        
  x       (       , 0    @0  4@80< $0                "runtime.panicwrap    ,"".EntityList.KeysById    0runtime.morestack_noctxt     &go.string."openpgp"     ,go.string."EntityList"     (go.string."KeysById"   0@  "".keys type.[]"".Key 
"".id type.uint64 ""..this  &type.*"".EntityList H4GH ? ? 
 " Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated><"".(*EntityList).KeysByIdUsage     ]6  (-  Q  
  ,0 S  @ @    < @ D ,   P        
         ,       0 4 8     @ 0$ <@@0D (0                "runtime.panicwrap    6"".EntityList.KeysByIdUsage    0runtime.morestack_noctxt     &go.string."openpgp"     ,go.string."EntityList"     2go.string."KeysByIdUsage"   8H  "".keys  type.[]"".Key  "".requiredUsage type.uint8 
"".id type.uint64 ""..this  &type.*"".EntityList P6OP A A 
 " Tgclocals·a041240a37ce609efec56707c330d1a4 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>"".(*EntityList).DecryptionKeys     ]0  -  Q  
   0 S  @ @    $ ( ,     P      t  
  h                  @0 $@(0, 0                "runtime.panicwrap    8"".EntityList.DecryptionKeys    0runtime.morestack_noctxt     &go.string."openpgp"     ,go.string."EntityList"     4go.string."DecryptionKeys"    0  "".keys type.[]"".Key ""..this  &type.*"".EntityList 8078 ; ; 
 " Tgclocals·2fccd208efe70893f9ac8d682812ae72 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash.[1]io.Reader    ]  - 0       R      P      00   0  $00    "runtime.interhash    0runtime.morestack_noctxt   (  
"".autotmp_0599 type.int "".autotmp_0598 type.int "".~r2 type.uintptr "".h type.uintptr "".p  $type.*[1]io.Reader 0/ " " 
  Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq.[1]io.Reader    ]1  0-       R&   08   P   @P4   P    0 R     $00(@@,PP      P  
    < 0 < 00    runtime.ifaceeq    0runtime.morestack_noctxt   X  "".autotmp_0604 type.io.Reader "".autotmp_0603 type.io.Reader "".autotmp_0602 /type.int "".autotmp_0601 'type.int "".~r2 type.bool "".q $type.*[1]io.Reader "".p  $type.*[1]io.Reader `1_ 8 8 
 ' Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go2"".KeyRing.DecryptionKeys    ]  -  Q  
  0 S  @ @    $ (     0/@0  @$0( 0           0runtime.morestack_noctxt   (   "".~r0 type.[]"".Key ""..this  type."".KeyRing ('   
  
  Tgclocals·1347047f6245a35b91e9a4f213167d52 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>&"".KeyRing.KeysById    ]  -  Q  
   0 S  @ @  0 4 8 ( , $     0/@0 0@408 0           0runtime.morestack_noctxt   80  "".~r1  type.[]"".Key 
"".id type.uint64 ""..this  type."".KeyRing 87 $ $ 
  Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>0"".KeyRing.KeysByIdUsage    ]   -  Q  
  $0 S  @ @  8 < @ , 0 4  (  $  0/@0 8@<0@  0           0runtime.morestack_noctxt   @8  "".~r2 (type.[]"".Key  "".requiredUsage  type.uint8 
"".id type.uint64 ""..this  type."".KeyRing @? & & 
  Tgclocals·6d46c0650eba7dbebc0db316e0e0cf3b Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>Dtype..hash."".signatureCheckReader    ]7  -       P               P                P                P               0   
p runtime.memhash    "runtime.interhash    "runtime.interhash    runtime.memhash    0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  :type.*"".signatureCheckReader (7' > > 
 0 Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go@type..eq."".signatureCheckReader    ]I  (-,@00      P  
  4 ( 0P @ R4    @@ 00$PP      P'  
0   P  0P,   P   @ R    @@ 00$PP      P  
, 0  P  
  4 ( 4 (  4 (  4 (0    runtime.ifaceeq    runtime.ifaceeq    0runtime.morestack_noctxt   H  "".autotmp_0613  type.hash.Hash "".autotmp_0612  type.hash.Hash "".autotmp_0611 type.hash.Hash "".autotmp_0610 type.hash.Hash "".~r2 type.bool "".q :type.*"".signatureCheckReader "".p  :type.*"".signatureCheckReader PIO P P 
 2 Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*checkReader).Read    ]3   -  Q  
  $0 S  @ @      8 <   $   P      |    p       $   (  ,  0     @0 4@80<  0                "runtime.panicwrap    &"".checkReader.Read    0runtime.morestack_noctxt     &go.string."openpgp"     .go.string."checkReader"      go.string."Read"   88  "".err (type.error "".n  type.int "".buf type.[]uint8 ""..this  (type.*"".checkReader @3?@ > > 
 # Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash."".FileHints    ]*  -       P               P                P               0   p runtime.memhash    runtime.strhash    runtime.memhash    0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  $type.*"".FileHints (*' 1 1 
 # Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq."".FileHints    ]D  (-,00@    P  
  4 ( 0$ $  P+   00$        P  
,   R  @0   R  0 p `  W   X
    P    P   4 (  4 (  4 (0     runtime.eqstring    0runtime.morestack_noctxt   H  
"".autotmp_0617 type.string "".autotmp_0616 type.string "".~r2 type.bool "".q $type.*"".FileHints "".p  $type.*"".FileHints PDO K K 
 !* Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*noOpCloser).Write    ]5  $-  Q  
  (0 S  @ @      < @   (   P        
  x       (     ,  0  4     @0  8@<0@ $0                "runtime.panicwrap    &"".noOpCloser.Write    0runtime.morestack_noctxt     &go.string."openpgp"     ,go.string."noOpCloser"     "go.string."Write"   8@  "".err (type.error "".n  type.int "".data type.[]uint8 ""..this  &type.*"".noOpCloser H5GH @ @ 
 # Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>,"".(*noOpCloser).Close    ]&  -  Q  
   0 S  @ @      P  h    \  
  P           P       $ ( 0               
 "runtime.panicwrap    0runtime.morestack_noctxt     &go.string."openpgp"     ,go.string."noOpCloser"     "go.string."Close"   0  "".~r0 type.error ""..this  &type.*"".noOpCloser 8&78 1 1 
  Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>:type..hash."".signatureWriter    ]D  -       P             P                P                  P                P               0   ` "runtime.interhash    "runtime.interhash    runtime.memhash    "runtime.interhash    runtime.memhash    0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  0type.*"".signatureWriter (D' K K 
 ? Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6type..eq."".signatureWriter    ]l  8-  @   P   0P<   P    @ R[  (  ,@@0004PP      PN  
@   P  0P<   P   @ R?  (  ,@@0004PP   @0<@   P0  
  P  
  D 8 0P @ R    @@ 00$PP   @@<0   P  
  P  
  D 8    P  
  D 8 D 8  D 8  D 8  D 80    runtime.ifaceeq    runtime.ifaceeq    runtime.ifaceeq    0runtime.morestack_noctxt   h  "".autotmp_0629 ?type.hash.Hash "".autotmp_0628 /type.hash.Hash "".autotmp_0627  &type.io.WriteCloser "".autotmp_0626  &type.io.WriteCloser "".autotmp_0625 &type.io.WriteCloser "".autotmp_0624 &type.io.WriteCloser "".~r2 type.bool "".q 0type.*"".signatureWriter "".p  0type.*"".signatureWriter plo s s 
 Y Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·895d0569a38a56443b84805daa09d838   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*signatureWriter).Write    ]2  @-  Q  
  D0 S  @ @    X \ D   P          t       D  Q     H ( L , P 0    4@80< T@X0\ @0                "runtime.panicwrap   ؃  runtime.duffcopy    0"".signatureWriter.Write    0runtime.morestack_noctxt     &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Write"   8x  "".~r2 (type.error "".~r1  type.int "".data type.[]uint8 ""..this  0type.*"".signatureWriter 2 = = 
 ! Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>6"".(*signatureWriter).Close    ])  0-  Q  
  40 S  @ @  8 < 4   P  l    `    T       4  Q        (0, 80< 00                "runtime.panicwrap   ؃  runtime.duffcopy    0"".signatureWriter.Close    0runtime.morestack_noctxt     &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Close"   X  "".~r0 type.error ""..this  0type.*"".signatureWriter `)_` 4 4 
   Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>Ngo.itab.*"".canonicalTextHash.hash.Hash     Tgclocals·0c8aa8e80191a30eac23f1a218103f16                   Tgclocals·aefd16b155593f6f07980a05b297ad1f                  Tgclocals·fdec177485cbfa40ac91f85390ec1fea        	           Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f                  Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·87d20ce1b58390b294df80b886db78bf             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·c00bf85eed6a8e40863dfe64526ae817                  Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa                  Tgclocals·cb89d0b1dc42d7fe829dd0c50f899290      C                           @  @                   @      Tgclocals·7cfe9a03a21b8328cb9dc32a81e0154a 8  8   
                   Tgclocals·6a65d73685d660726632329622a6d393 P  P   3                     @        Tgclocals·4db28316a1e41bcee736a1197adee0e9 0  0   
                Tgclocals·7f7e31e410d386547ddc0047dc2faa98 p  p   $                 
      
                     Tgclocals·75e979049760da58a03960363c73f8d8 @  @         !      !      !    Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc 0  0                    Tgclocals·182a0b7256216f75ea61640d3418698d 0  0   	      A      A    Tgclocals·1bcec613e24368dd337b6dd546e388e5 (  (               Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 (  (            	    >go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     Jgo.string.hdr."no armored data found"             Bgo.string."no armored data found"   Bgo.string."no armored data found" 0  ,no armored data found  vgo.string.hdr."expected public or private key block, got: "       +      ngo.string."expected public or private key block, got: "   ngo.string."expected public or private key block, got: " X  Xexpected public or private key block, got:   Tgclocals·07c886799a88ac80d684b8bca7c92573 0  0                     Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 0  0                   Tgclocals·db08f305c468200e3cf791eda6a8ebaa @  @          $  $  a$  a$  c$   Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad @  @                  g       6go.string.hdr."unreachable"             .go.string."unreachable"   .go.string."unreachable"   unreachable  Tgclocals·51562c45243a0c5ce48841e15ba48784 8  8          0              Tgclocals·725f69b7ae8520ac59af51db7db265d1 8  8                      >go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     rgo.string.hdr."first packet was not a public/private key"       )      jgo.string."first packet was not a public/private key"   jgo.string."first packet was not a public/private key" X  Tfirst packet was not a public/private key  rgo.string.hdr."primary key cannot be used for signatures"       )      jgo.string."primary key cannot be used for signatures"   jgo.string."primary key cannot be used for signatures" X  Tprimary key cannot be used for signatures  zgo.string.hdr."user ID packet not followed by self-signature"       -      rgo.string."user ID packet not followed by self-signature"   rgo.string."user ID packet not followed by self-signature" `  \user ID packet not followed by self-signature  `go.string.hdr."user ID self-signature invalid: "              Xgo.string."user ID self-signature invalid: "   Xgo.string."user ID self-signature invalid: " H  Buser ID self-signature invalid:   xgo.string.hdr."signature packet found before user id packet"       ,      pgo.string."signature packet found before user id packet"   pgo.string."signature packet found before user id packet" `  Zsignature packet found before user id packet  Zgo.string.hdr."entity without any identities"             Rgo.string."entity without any identities"   Rgo.string."entity without any identities" @  <entity without any identities  xgo.string.hdr."revocation signature signed by alternate key"       ,      pgo.string."revocation signature signed by alternate key"   pgo.string."revocation signature signed by alternate key" `  Zrevocation signature signed by alternate key  Tgclocals·a22f48e06a7657c6080f17b67fc4b601      (                                                 0   00   0     2                                                                 	     0                   Tgclocals·59a081aa56aea3db12c49708a232e907                                                                                           Tgo.string.hdr."subkey signature invalid: "             Lgo.string."subkey signature invalid: "   Lgo.string."subkey signature invalid: " 8  6subkey signature invalid:   ngo.string.hdr."subkey packet not followed by signature"       '      fgo.string."subkey packet not followed by signature"   fgo.string."subkey packet not followed by signature" P  Psubkey packet not followed by signature  `go.string.hdr."subkey signature with wrong type"              Xgo.string."subkey signature with wrong type"   Xgo.string."subkey signature with wrong type" H  Bsubkey signature with wrong type  Tgclocals·a3f332e265628a83ebf74125fa889474 8  8                      Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      tgo.string.hdr."user id field contained invalid characters"       *      lgo.string."user id field contained invalid characters"   lgo.string."user id field contained invalid characters" X  Vuser id field contained invalid characters  Tgclocals·abdb7871fad8719ab9d9b29665788f59                                   E  E  E        -  =  =   -            p  p     Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3      
   U   U      U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U    Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2 8  8                    Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022 @  @                     Tgclocals·b385d9a51ca4f468987863aa65654328 @  @                         lgo.string.hdr."signing Entity must have a private key"       &      dgo.string."signing Entity must have a private key"   dgo.string."signing Entity must have a private key" P  Nsigning Entity must have a private key  |go.string.hdr."signing Entity's private key must be decrypted"       .      tgo.string."signing Entity's private key must be decrypted"   tgo.string."signing Entity's private key must be decrypted" `  ^signing Entity's private key must be decrypted  rgo.string.hdr."given identity string not found in Entity"       )      jgo.string."given identity string not found in Entity"   jgo.string."given identity string not found in Entity" X  Tgiven identity string not found in Entity  Tgclocals·ba2c509b55e4bcd7dfa9cabca2e05dcc H  H                   
          Tgclocals·949580c181e84412df3073e61f463446 H  H                            4go.string.hdr."expected '"       
      ,go.string."expected '"   ,go.string."expected '"   expected '  0go.string.hdr."', got: "             (go.string."', got: "   (go.string."', got: "   ', got:   Tgclocals·79d0667feac83fcec4421590bfc5b188 0  0                     Tgclocals·537385343e646e25b1b6fced99dbb969 0  0         7          |go.string.hdr."key material not followed by encrypted message"       .      tgo.string."key material not followed by encrypted message"   tgo.string."key material not followed by encrypted message" `  ^key material not followed by encrypted message  Tgo.string.hdr."too many layers of packets"             Lgo.string."too many layers of packets"   Lgo.string."too many layers of packets" 8  6too many layers of packets  Tgclocals·d1b731863bfe975d4592d09ee097675c 
  
!                           0   @              8   @                 @                @                 @                 @                @             (                  	    @      *   I   @    *   I  @    *              *   I@  @    *   I@  @   x  *   I@  @      *   I   A      *   	   @      *   	 @      *   
            *              *   
           *              *               *                *       @                 @                @      >          @                                                                                        Tgclocals·073d2fd56d13eddb795b325d75824174   !   	   ?   ?   ?   ?   ?   ?                                                        ?               ?   ?   ?   ?    >go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     >Tgo.itab.*"".signatureCheckReader.io.Reader     >@go.itab."".checkReader.io.Reader     Bgo.string.hdr."nested signatures"             :go.string."nested signatures"   :go.string."nested signatures" (  $nested signatures  Tgclocals·5532e819bd29530b183fefa3baac8db4 x  x          `  `` h  h             `            Tgclocals·32b59a2f714914dd65254a6ea209e9bc x  x                                              Hgo.string.hdr."hash not available: "             @go.string."hash not available: "   @go.string."hash not available: " 0  *hash not available:   Xgo.string.hdr."unsupported signature type: "             Pgo.string."unsupported signature type: "   Pgo.string."unsupported signature type: " @  :unsupported signature type:   Tgclocals·75b04d23becfbadc005b25375f880226 0  0             x       Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea 0  0          <            Tgclocals·64ca935d1a2110a30e2d604686188539                    Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec              c    jgo.string.hdr."LiteralData not followed by Signature"       %      bgo.string."LiteralData not followed by Signature"   bgo.string."LiteralData not followed by Signature" P  LLiteralData not followed by Signature  Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818 0  0                     Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 0  0         c   c   c    `go.string.hdr."signature doesn't have an issuer"              Xgo.string."signature doesn't have an issuer"   Xgo.string."signature doesn't have an issuer" H  Bsignature doesn't have an issuer  Tgo.string.hdr."non signature packet found"             Lgo.string."non signature packet found"   Lgo.string."non signature packet found" 8  6non signature packet found  Tgclocals·510abbe02d5ba0858c7154a80d9fec44      .              	     	      	     	    	       	     	      	     	   x  	     	  x 	  x  	   Tgclocals·33353b89c8d716aa30f1cbcff483ff29      	   ?   ?   ?   ?     ?   ?   ?   ?   ?       ?   ?    Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    Tgclocals·3a5692de2bcadad506bd8b6dd1491c00        	   ?       Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·21a8f585a14d020f181242c5256583dc                   Tgclocals·236601f43b36f8c15cf70bb83f74cf9b        	   _   _    lgo.string.hdr."signing key doesn't have a private key"       &      dgo.string."signing key doesn't have a private key"   dgo.string."signing key doesn't have a private key" P  Nsigning key doesn't have a private key  Pgo.string.hdr."signing key is encrypted"             Hgo.string."signing key is encrypted"   Hgo.string."signing key is encrypted" 8  2signing key is encrypted  Tgclocals·ce5958795429f4e02af1bac306c025c7 0  0                     Tgclocals·69607a593e43f6fa2bc465446e592f44 0  0   	   _   _   _   _    Tgclocals·d02e8ebf325cdf993e86e63fb430cf55 (  (            !   !  Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f (  (      g     g    Tgclocals·709a14768fab2805a378215c02f0d27f              Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa      	   	    Zgo.string.hdr."tried to convert unknown hash"             Rgo.string."tried to convert unknown hash"   Rgo.string."tried to convert unknown hash" @  <tried to convert unknown hash  Tgclocals·d8fdd2a55187867c76648dc792366181                   Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    >Hgo.itab."".noOpCloser.io.WriteCloser     >Rgo.itab."".signatureWriter.io.WriteCloser     Jgo.string.hdr."no valid signing keys"             Bgo.string."no valid signing keys"   Bgo.string."no valid signing keys" 0  ,no valid signing keys  Zgo.string.hdr."no private key in signing key"             Rgo.string."no private key in signing key"   Rgo.string."no private key in signing key" @  <no private key in signing key  Zgo.string.hdr."signing key must be decrypted"             Rgo.string."signing key must be decrypted"   Rgo.string."signing key must be decrypted" @  <signing key must be decrypted  fgo.string.hdr."cannot encrypt a message to key id "       #      ^go.string."cannot encrypt a message to key id "   ^go.string."cannot encrypt a message to key id " H  Hcannot encrypt a message to key id   dgo.string.hdr." because it has no encryption keys"       "      \go.string." because it has no encryption keys"   \go.string." because it has no encryption keys" H  F because it has no encryption keys  go.string.hdr."cannot encrypt because recipient set shares no common algorithms"       @      go.string."cannot encrypt because recipient set shares no common algorithms"   go.string."cannot encrypt because recipient set shares no common algorithms"   cannot encrypt because recipient set shares no common algorithms  "go.string.hdr."#"             go.string."#"   go.string."#"   #  go.string.hdr."cannot encrypt because no candidate hash functions are compiled in. (Wanted "       L      go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   cannot encrypt because no candidate hash functions are compiled in. (Wanted   >go.string.hdr." in this case.)"             6go.string." in this case.)"   6go.string." in this case.)"      in this case.)  Tgclocals·cc9864a176c1d5112af33aade2eb2ba9      j                                    @                           $           $                        @                   !                                                            0            0            0          00                         Tgclocals·79278f1b3c02451b235b26e0d050a9f3                                                        Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·d9f9402b3f7d1c398b577a45048cc887            Tgclocals·47e81b9b582fcfba016f557768a0f4be 0  0                     Tgclocals·5705c76a0bc7db77dc7faa07cb35699a 0  0               Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·dacebcad73eed5073009fd67170948d0             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578             Hgo.string.hdr."PGP PUBLIC KEY BLOCK"             @go.string."PGP PUBLIC KEY BLOCK"   @go.string."PGP PUBLIC KEY BLOCK" 0  *PGP PUBLIC KEY BLOCK  Jgo.string.hdr."PGP PRIVATE KEY BLOCK"             Bgo.string."PGP PRIVATE KEY BLOCK"   Bgo.string."PGP PRIVATE KEY BLOCK" 0  ,PGP PRIVATE KEY BLOCK  :go.string.hdr."PGP SIGNATURE"             2go.string."PGP SIGNATURE"   2go.string."PGP SIGNATURE"    PGP SIGNATURE  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           <"".newline  type.[]uint8              """.statictmp_0583   < "".PublicKeyType  type.string           @go.string."PGP PUBLIC KEY BLOCK"   <""".PrivateKeyType  type.string           Bgo.string."PGP PRIVATE KEY BLOCK"   < "".SignatureType  type.string           2go.string."PGP SIGNATURE"   """.statictmp_0519  type.[3]uint8 	 """.statictmp_0556  H.type."".signatureWriter   >""".statictmp_0583  type.[2]uint8 
 >"".initdone·  type.uint8   4"".NewCanonicalTextHash·f          ."".NewCanonicalTextHash   @"".(*canonicalTextHash).Write·f          :"".(*canonicalTextHash).Write   <"".(*canonicalTextHash).Sum·f          6"".(*canonicalTextHash).Sum   @"".(*canonicalTextHash).Reset·f          :"".(*canonicalTextHash).Reset   >"".(*canonicalTextHash).Size·f          8"".(*canonicalTextHash).Size   H"".(*canonicalTextHash).BlockSize·f          B"".(*canonicalTextHash).BlockSize   >"".(*Entity).primaryIdentity·f          8"".(*Entity).primaryIdentity   :"".(*Entity).encryptionKey·f          4"".(*Entity).encryptionKey   4"".(*Entity).signingKey·f          ."".(*Entity).signingKey   2"".EntityList.KeysById·f          ,"".EntityList.KeysById   <"".EntityList.KeysByIdUsage·f          6"".EntityList.KeysByIdUsage   >"".EntityList.DecryptionKeys·f          8"".EntityList.DecryptionKeys   0"".ReadArmoredKeyRing·f          *"".ReadArmoredKeyRing   """.ReadKeyRing·f          "".ReadKeyRing   2"".readToNextPublicKey·f          ,"".readToNextPublicKey    "".ReadEntity·f          "".ReadEntity   "".addSubkey·f          "".addSubkey   "".NewEntity·f          "".NewEntity   @"".(*Entity).SerializePrivate·f          :"".(*Entity).SerializePrivate   2"".(*Entity).Serialize·f          ,"".(*Entity).Serialize   8"".(*Entity).SignIdentity·f          2"".(*Entity).SignIdentity   """.readArmored·f          "".readArmored   """.ReadMessage·f          "".ReadMessage   ."".readSignedMessage·f          ("".readSignedMessage   ,"".hashForSignature·f          &"".hashForSignature   ,"".checkReader.Read·f          &"".checkReader.Read   D"".(*signatureCheckReader).Read·f          >"".(*signatureCheckReader).Read   8"".CheckDetachedSignature·f          2"".CheckDetachedSignature   F"".CheckArmoredDetachedSignature·f          @"".CheckArmoredDetachedSignature    "".DetachSign·f          "".DetachSign   ."".ArmoredDetachSign·f          ("".ArmoredDetachSign   ("".DetachSignText·f          """.DetachSignText   6"".ArmoredDetachSignText·f          0"".ArmoredDetachSignText   ."".armoredDetachSign·f          ("".armoredDetachSign    "".detachSign·f          "".detachSign   4"".SymmetricallyEncrypt·f          ."".SymmetricallyEncrypt   4"".intersectPreferences·f          ."".intersectPreferences   $"".hashToHashId·f          "".hashToHashId   "".Encrypt·f          "".Encrypt   6"".signatureWriter.Write·f          0"".signatureWriter.Write   6"".signatureWriter.Close·f          0"".signatureWriter.Close   ,"".noOpCloser.Write·f          &"".noOpCloser.Write   ,"".noOpCloser.Close·f          &"".noOpCloser.Close   "".init·f          "".init   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ftype..hashfunc."".canonicalTextHash          >type..hash."".canonicalTextHash   Btype..eqfunc."".canonicalTextHash          :type..eq."".canonicalTextHash   <type..alg."".canonicalTextHash              Ftype..hashfunc."".canonicalTextHash     Btype..eqfunc."".canonicalTextHash   "runtime.gcbits.01    Tgo.string.hdr."*openpgp.canonicalTextHash"             Lgo.string."*openpgp.canonicalTextHash"   Lgo.string."*openpgp.canonicalTextHash" 8  6*openpgp.canonicalTextHash  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"       $      `go.string."func(*openpgp.canonicalTextHash) int"   `go.string."func(*openpgp.canonicalTextHash) int" P  Jfunc(*openpgp.canonicalTextHash) int  Htype.func(*"".canonicalTextHash) int         $D[ 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"   @  Zgo.weak.type.*func(*"".canonicalTextHash) int   P Htype.func(*"".canonicalTextHash) int   h Htype.func(*"".canonicalTextHash) int     4type.*"".canonicalTextHash     type.int   go.typelink.func(*openpgp.canonicalTextHash) int	func(*"".canonicalTextHash) int          Htype.func(*"".canonicalTextHash) int   `go.string.hdr."func(*openpgp.canonicalTextHash)"              Xgo.string."func(*openpgp.canonicalTextHash)"   Xgo.string."func(*openpgp.canonicalTextHash)" H  Bfunc(*openpgp.canonicalTextHash)  @type.func(*"".canonicalTextHash)         % 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  `go.string.hdr."func(*openpgp.canonicalTextHash)"   @  Rgo.weak.type.*func(*"".canonicalTextHash)   P @type.func(*"".canonicalTextHash)   h @type.func(*"".canonicalTextHash)     4type.*"".canonicalTextHash   go.typelink.func(*openpgp.canonicalTextHash)	func(*"".canonicalTextHash)          @type.func(*"".canonicalTextHash)   .go.string.hdr."[]uint8"             &go.string."[]uint8"   &go.string."[]uint8"   []uint8  type.[]uint8 P  P      ~.8                         
   runtime.algarray   (  "runtime.gcbits.01   0  .go.string.hdr."[]uint8"   @  *go.weak.type.*[]uint8   H  type.uint8   6go.typelink.[]uint8	[]uint8          type.[]uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"       1      zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8"   zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8" h  dfunc(*openpgp.canonicalTextHash, []uint8) []uint8  btype.func(*"".canonicalTextHash, []uint8) []uint8         |# 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"   @  tgo.weak.type.*func(*"".canonicalTextHash, []uint8) []uint8   P btype.func(*"".canonicalTextHash, []uint8) []uint8   h btype.func(*"".canonicalTextHash, []uint8) []uint8     4type.*"".canonicalTextHash     type.[]uint8     type.[]uint8   go.typelink.func(*openpgp.canonicalTextHash, []uint8) []uint8	func(*"".canonicalTextHash, []uint8) []uint8          btype.func(*"".canonicalTextHash, []uint8) []uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"       6      go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)" p  nfunc(*openpgp.canonicalTextHash, []uint8) (int, error)  ltype.func(*"".canonicalTextHash, []uint8) (int, error)         ^- 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   @  ~go.weak.type.*func(*"".canonicalTextHash, []uint8) (int, error)   P ltype.func(*"".canonicalTextHash, []uint8) (int, error)   h ltype.func(*"".canonicalTextHash, []uint8) (int, error)     4type.*"".canonicalTextHash     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.canonicalTextHash, []uint8) (int, error)	func(*"".canonicalTextHash, []uint8) (int, error)          ltype.func(*"".canonicalTextHash, []uint8) (int, error)   2go.string.hdr."BlockSize"       	      *go.string."BlockSize"   *go.string."BlockSize"   BlockSize  4go.string.hdr."func() int"       
      ,go.string."func() int"   ,go.string."func() int"   func() int  type.func() int         9 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  4go.string.hdr."func() int"   @  0go.weak.type.*func() int   P type.func() int   h type.func() int     type.int   Bgo.typelink.func() int	func() int          type.func() int   *go.string.hdr."Reset"             "go.string."Reset"   "go.string."Reset"   Reset  ,go.string.hdr."func()"             $go.string."func()"   $go.string."func()"   func()  type.func()          3                                                   runtime.algarray   (  "runtime.gcbits.01   0  ,go.string.hdr."func()"   @  (go.weak.type.*func()   P type.func()   h type.func()   2go.typelink.func()	func()          type.func()   (go.string.hdr."Size"              go.string."Size"    go.string."Size"   
Size  &go.string.hdr."Sum"             go.string."Sum"   go.string."Sum"   Sum  Jgo.string.hdr."func([]uint8) []uint8"             Bgo.string."func([]uint8) []uint8"   Bgo.string."func([]uint8) []uint8" 0  ,func([]uint8) []uint8  4type.func([]uint8) []uint8         & 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Jgo.string.hdr."func([]uint8) []uint8"   @  Fgo.weak.type.*func([]uint8) []uint8   P 4type.func([]uint8) []uint8   h 4type.func([]uint8) []uint8     type.[]uint8     type.[]uint8   ngo.typelink.func([]uint8) []uint8	func([]uint8) []uint8          4type.func([]uint8) []uint8   *go.string.hdr."Write"             "go.string."Write"   "go.string."Write"   Write  Tgo.string.hdr."func([]uint8) (int, error)"             Lgo.string."func([]uint8) (int, error)"   Lgo.string."func([]uint8) (int, error)" 8  6func([]uint8) (int, error)  >type.func([]uint8) (int, error)         N4P 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."func([]uint8) (int, error)"   @  Pgo.weak.type.*func([]uint8) (int, error)   P >type.func([]uint8) (int, error)   h >type.func([]uint8) (int, error)     type.[]uint8     type.int     type.error   go.typelink.func([]uint8) (int, error)	func([]uint8) (int, error)          >type.func([]uint8) (int, error)   4type.*"".canonicalTextHash          -	} 6                                                                                                                                                                  @ @  runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."*openpgp.canonicalTextHash"   @  Fgo.weak.type.**"".canonicalTextHash   H  2type."".canonicalTextHash   8P 4type.*"".canonicalTextHash   `x 4type.*"".canonicalTextHash   x  2go.string.hdr."BlockSize"     type.func() int     Htype.func(*"".canonicalTextHash) int     B"".(*canonicalTextHash).BlockSize     B"".(*canonicalTextHash).BlockSize     *go.string.hdr."Reset"     type.func()     @type.func(*"".canonicalTextHash)     :"".(*canonicalTextHash).Reset     :"".(*canonicalTextHash).Reset     (go.string.hdr."Size"     type.func() int     Htype.func(*"".canonicalTextHash) int     8"".(*canonicalTextHash).Size     8"".(*canonicalTextHash).Size     &go.string.hdr."Sum"     4type.func([]uint8) []uint8     btype.func(*"".canonicalTextHash, []uint8) []uint8     6"".(*canonicalTextHash).Sum     6"".(*canonicalTextHash).Sum     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ltype.func(*"".canonicalTextHash, []uint8) (int, error)     :"".(*canonicalTextHash).Write     :"".(*canonicalTextHash).Write   "runtime.gcbits.03    Rgo.string.hdr."openpgp.canonicalTextHash"             Jgo.string."openpgp.canonicalTextHash"   Jgo.string."openpgp.canonicalTextHash" 8  4openpgp.canonicalTextHash  "go.string.hdr."h"             go.string."h"   go.string."h"   h  Vgo.string.hdr."golang.org/x/crypto/openpgp"             Ngo.string."golang.org/x/crypto/openpgp"   Ngo.string."golang.org/x/crypto/openpgp" 8  8golang.org/x/crypto/openpgp  "go.importpath."".             Ngo.string."golang.org/x/crypto/openpgp"   "go.string.hdr."s"             go.string."s"   go.string."s"   s  Bgo.string.hdr."canonicalTextHash"             :go.string."canonicalTextHash"   :go.string."canonicalTextHash" (  $canonicalTextHash  2type."".canonicalTextHash          Xݏ                                                                                             <type..alg."".canonicalTextHash   (  "runtime.gcbits.03   0  Rgo.string.hdr."openpgp.canonicalTextHash"   @  4type.*"".canonicalTextHash   H` 2type."".canonicalTextHash   `  "go.string.hdr."h"   h  "go.importpath."".   p  type.hash.Hash     "go.string.hdr."s"     "go.importpath."".     type.int   8 2type."".canonicalTextHash     Bgo.string.hdr."canonicalTextHash"     "go.importpath."".    2type."".canonicalTextHash   Fgo.string.hdr."[]*packet.Signature"             >go.string."[]*packet.Signature"   >go.string."[]*packet.Signature" (  ([]*packet.Signature  htype.[]*golang.org/x/crypto/openpgp/packet.Signature P  P      ,Ž                         
   runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."[]*packet.Signature"   @  zgo.weak.type.*[]*golang.org/x/crypto/openpgp/packet.Signature   H  dtype.*golang.org/x/crypto/openpgp/packet.Signature   go.typelink.[]*packet.Signature	[]*golang.org/x/crypto/openpgp/packet.Signature          htype.[]*golang.org/x/crypto/openpgp/packet.Signature   "runtime.gcbits.1d    @go.string.hdr."openpgp.Identity"             8go.string."openpgp.Identity"   8go.string."openpgp.Identity" (  "openpgp.Identity  (go.string.hdr."Name"              go.string."Name"    go.string."Name"   
Name  ,go.string.hdr."UserId"             $go.string."UserId"   $go.string."UserId"   UserId  :go.string.hdr."SelfSignature"             2go.string."SelfSignature"   2go.string."SelfSignature"    SelfSignature  4go.string.hdr."Signatures"       
      ,go.string."Signatures"   ,go.string."Signatures"   Signatures  0go.string.hdr."Identity"             (go.string."Identity"   (go.string."Identity"   Identity   type."".Identity          r                                                                                                                                " p  runtime.algarray   (  "runtime.gcbits.1d   0  @go.string.hdr."openpgp.Identity"   @  "type.*"".Identity   H`  type."".Identity   `  (go.string.hdr."Name"   p  type.string     ,go.string.hdr."UserId"     ^type.*golang.org/x/crypto/openpgp/packet.UserId     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     4go.string.hdr."Signatures"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature   8  type."".Identity     0go.string.hdr."Identity"     "go.importpath."".     type."".Identity   Bgo.string.hdr."*openpgp.Identity"             :go.string."*openpgp.Identity"   :go.string."*openpgp.Identity" (  $*openpgp.Identity  "type.*"".Identity  P  P      w* 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."*openpgp.Identity"   @  4go.weak.type.**"".Identity   H   type."".Identity   runtime.gcbits.      0go.string.hdr."[8]uint8"             (go.string."[8]uint8"   (go.string."[8]uint8"   [8]uint8  type.[8]uint8 `  `       >0                                 P  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[8]uint8"   @  ,go.weak.type.*[8]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[8]uint8	[8]uint8          type.[8]uint8   0go.string.hdr."[]string"             (go.string."[]string"   (go.string."[]string"   []string  type.[]string P  P      Ө
                         
   runtime.algarray   (  "runtime.gcbits.01   0  0go.string.hdr."[]string"   @  ,go.weak.type.*[]string   H  type.string   :go.typelink.[]string	[]string          type.[]string   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             0type..hashfunc.[8]string          (type..hash.[8]string   ,type..eqfunc.[8]string          $type..eq.[8]string   &type..alg.[8]string              0type..hashfunc.[8]string     ,type..eqfunc.[8]string   &runtime.gcbits.5555   UU 2go.string.hdr."[8]string"       	      *go.string."[8]string"   *go.string."[8]string"   [8]string  type.[8]string `  `@   <   US>                                   &type..alg.[8]string   (  &runtime.gcbits.5555   0  2go.string.hdr."[8]string"   @  .go.weak.type.*[8]string   H  type.string   P  type.[]string   >go.typelink.[8]string	[8]string          type.[8]string   Fgo.string.hdr."[]*openpgp.Identity"             >go.string."[]*openpgp.Identity"   >go.string."[]*openpgp.Identity" (  ([]*openpgp.Identity  &type.[]*"".Identity P  P      ԁ                         
   runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."[]*openpgp.Identity"   @  8go.weak.type.*[]*"".Identity   H  "type.*"".Identity   \go.typelink.[]*openpgp.Identity	[]*"".Identity          &type.[]*"".Identity    type..hashfunc32              ,runtime.memhash_varlen   type..eqfunc32              .runtime.memequal_varlen   type..alg32               type..hashfunc32     type..eqfunc32   "runtime.gcbits.ff    Hgo.string.hdr."[8]*openpgp.Identity"             @go.string."[8]*openpgp.Identity"   @go.string."[8]*openpgp.Identity" 0  *[8]*openpgp.Identity  (type.[8]*"".Identity `  `        j0                                   type..alg32   (  "runtime.gcbits.ff   0  Hgo.string.hdr."[8]*openpgp.Identity"   @  :go.weak.type.*[8]*"".Identity   H  "type.*"".Identity   P  &type.[]*"".Identity   `go.typelink.[8]*openpgp.Identity	[8]*"".Identity          (type.[8]*"".Identity   hgo.string.hdr."*map.bucket[string]*openpgp.Identity"       $      `go.string."*map.bucket[string]*openpgp.Identity"   `go.string."*map.bucket[string]*openpgp.Identity" P  J*map.bucket[string]*openpgp.Identity  Htype.*map.bucket[string]*"".Identity P  P      崞 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."*map.bucket[string]*openpgp.Identity"   @  Zgo.weak.type.**map.bucket[string]*"".Identity   H  Ftype.map.bucket[string]*"".Identity   .runtime.gcbits.5455fd07   TU fgo.string.hdr."map.bucket[string]*openpgp.Identity"       #      ^go.string."map.bucket[string]*openpgp.Identity"   ^go.string."map.bucket[string]*openpgp.Identity" H  Hmap.bucket[string]*openpgp.Identity  .go.string.hdr."topbits"             &go.string."topbits"   &go.string."topbits"   topbits  (go.string.hdr."keys"              go.string."keys"    go.string."keys"   
keys  ,go.string.hdr."values"             $go.string."values"   $go.string."values"   values  0go.string.hdr."overflow"             (go.string."overflow"   (go.string."overflow"   overflow  Ftype.map.bucket[string]*"".Identity   l   l   x|                                                                                      H                   h    p  runtime.algarray   (  .runtime.gcbits.5455fd07   0  fgo.string.hdr."map.bucket[string]*openpgp.Identity"   @  Xgo.weak.type.*map.bucket[string]*"".Identity   H` Ftype.map.bucket[string]*"".Identity   `  .go.string.hdr."topbits"   p  type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     (type.[8]*"".Identity     0go.string.hdr."overflow"     Htype.*map.bucket[string]*"".Identity   "runtime.gcbits.58   X `go.string.hdr."map.hdr[string]*openpgp.Identity"              Xgo.string."map.hdr[string]*openpgp.Identity"   Xgo.string."map.hdr[string]*openpgp.Identity" H  Bmap.hdr[string]*openpgp.Identity  *go.string.hdr."count"             "go.string."count"   "go.string."count"   count  *go.string.hdr."flags"             "go.string."flags"   "go.string."flags"   flags  "go.string.hdr."B"             go.string."B"   go.string."B"   B  *go.string.hdr."hash0"             "go.string."hash0"   "go.string."hash0"   hash0  .go.string.hdr."buckets"             &go.string."buckets"   &go.string."buckets"   buckets  4go.string.hdr."oldbuckets"       
      ,go.string."oldbuckets"   ,go.string."oldbuckets"   oldbuckets  2go.string.hdr."nevacuate"       	      *go.string."nevacuate"   *go.string."nevacuate"   nevacuate  @type.map.hdr[string]*"".Identity         P                                                                                                                                                                                        * p  runtime.algarray   (  "runtime.gcbits.58   0  `go.string.hdr."map.hdr[string]*openpgp.Identity"   @  Rgo.weak.type.*map.hdr[string]*"".Identity   H` @type.map.hdr[string]*"".Identity   `  *go.string.hdr."count"   p  type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     4go.string.hdr."oldbuckets"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   Xgo.string.hdr."map[string]*openpgp.Identity"             Pgo.string."map[string]*openpgp.Identity"   Pgo.string."map[string]*openpgp.Identity" @  :map[string]*openpgp.Identity  8type.map[string]*"".Identity x  x      % 5                                      l    runtime.algarray   (  "runtime.gcbits.01   0  Xgo.string.hdr."map[string]*openpgp.Identity"   @  Jgo.weak.type.*map[string]*"".Identity   H  type.string   P  "type.*"".Identity   X  Ftype.map.bucket[string]*"".Identity   `  @type.map.hdr[string]*"".Identity   go.typelink.map[string]*openpgp.Identity	map[string]*"".Identity          8type.map[string]*"".Identity    type..hashfunc12             ,runtime.memhash_varlen   type..eqfunc12             .runtime.memequal_varlen   type..alg12               type..hashfunc12     type..eqfunc12   >go.string.hdr."*openpgp.Subkey"             6go.string."*openpgp.Subkey"   6go.string."*openpgp.Subkey"     *openpgp.Subkey  type.*"".Subkey  P  P      	 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."*openpgp.Subkey"   @  0go.weak.type.**"".Subkey   H  type."".Subkey   "runtime.gcbits.07    <go.string.hdr."openpgp.Subkey"             4go.string."openpgp.Subkey"   4go.string."openpgp.Subkey"    openpgp.Subkey  2go.string.hdr."PublicKey"       	      *go.string."PublicKey"   *go.string."PublicKey"   PublicKey  4go.string.hdr."PrivateKey"       
      ,go.string."PrivateKey"   ,go.string."PrivateKey"   PrivateKey  &go.string.hdr."Sig"             go.string."Sig"   go.string."Sig"   Sig  ,go.string.hdr."Subkey"             $go.string."Subkey"   $go.string."Subkey"   Subkey  type."".Subkey          Y                                                                                                                type..alg12   (  "runtime.gcbits.07   0  <go.string.hdr."openpgp.Subkey"   @  type.*"".Subkey   H` type."".Subkey   `  2go.string.hdr."PublicKey"   p  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     &go.string.hdr."Sig"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   8 type."".Subkey     ,go.string.hdr."Subkey"     "go.importpath."".    type."".Subkey   @go.string.hdr."[]openpgp.Subkey"             8go.string."[]openpgp.Subkey"   8go.string."[]openpgp.Subkey" (  "[]openpgp.Subkey   type.[]"".Subkey P  P      Fp                         
   runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."[]openpgp.Subkey"   @  2go.weak.type.*[]"".Subkey   H  type."".Subkey   Pgo.typelink.[]openpgp.Subkey	[]"".Subkey           type.[]"".Subkey   "runtime.gcbits.4f   O <go.string.hdr."openpgp.Entity"             4go.string."openpgp.Entity"   4go.string."openpgp.Entity"    openpgp.Entity  4go.string.hdr."PrimaryKey"       
      ,go.string."PrimaryKey"   ,go.string."PrimaryKey"   PrimaryKey  4go.string.hdr."Identities"       
      ,go.string."Identities"   ,go.string."Identities"   Identities  6go.string.hdr."Revocations"             .go.string."Revocations"   .go.string."Revocations"   Revocations  .go.string.hdr."Subkeys"             &go.string."Subkeys"   &go.string."Subkeys"   Subkeys  ,go.string.hdr."Entity"             $go.string."Entity"   $go.string."Entity"   Entity  type."".Entity    $                                                                                                                                                         & p  runtime.algarray   (  "runtime.gcbits.4f   0  <go.string.hdr."openpgp.Entity"   @  type.*"".Entity   H` type."".Entity   `  4go.string.hdr."PrimaryKey"   p  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     4go.string.hdr."Identities"     8type.map[string]*"".Identity     6go.string.hdr."Revocations"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     .go.string.hdr."Subkeys"      type.[]"".Subkey   8 type."".Entity     ,go.string.hdr."Entity"     "go.importpath."".    type."".Entity   >go.string.hdr."*openpgp.Entity"             6go.string."*openpgp.Entity"   6go.string."*openpgp.Entity"     *openpgp.Entity  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"       &      dgo.string."func(*openpgp.Entity, io.Writer) error"   dgo.string."func(*openpgp.Entity, io.Writer) error" P  Nfunc(*openpgp.Entity, io.Writer) error  Ltype.func(*"".Entity, io.Writer) error         Wf 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"   @  ^go.weak.type.*func(*"".Entity, io.Writer) error   P Ltype.func(*"".Entity, io.Writer) error   h Ltype.func(*"".Entity, io.Writer) error     type.*"".Entity     type.io.Writer     type.error   go.typelink.func(*openpgp.Entity, io.Writer) error	func(*"".Entity, io.Writer) error          Ltype.func(*"".Entity, io.Writer) error   go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"       6      go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error"   go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error" p  nfunc(*openpgp.Entity, io.Writer, *packet.Config) error  type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error         = 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"   @  go.weak.type.*func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, io.Writer, *packet.Config) error	func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"       D      go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error  type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error         P 3                                                                   runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   @  go.weak.type.*func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error	func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   8go.string.hdr."*openpgp.Key"             0go.string."*openpgp.Key"   0go.string."*openpgp.Key"    *openpgp.Key  type.*"".Key  P  P      ?n 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  8go.string.hdr."*openpgp.Key"   @  *go.weak.type.**"".Key   H  type."".Key   "runtime.gcbits.0f    6go.string.hdr."openpgp.Key"             .go.string."openpgp.Key"   .go.string."openpgp.Key"   openpgp.Key  &go.string.hdr."Key"             go.string."Key"   go.string."Key"   Key  type."".Key          M,                                                                                                                                " `  runtime.algarray   (  "runtime.gcbits.0f   0  6go.string.hdr."openpgp.Key"   @  type.*"".Key   H` type."".Key   `  ,go.string.hdr."Entity"   p  type.*"".Entity     2go.string.hdr."PublicKey"     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   8 type."".Key     &go.string.hdr."Key"     "go.importpath."".    type."".Key   go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"       4      go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)" p  jfunc(*openpgp.Entity, time.Time) (openpgp.Key, bool)  ^type.func(*"".Entity, time.Time) ("".Key, bool)         k 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   @  pgo.weak.type.*func(*"".Entity, time.Time) ("".Key, bool)   P ^type.func(*"".Entity, time.Time) ("".Key, bool)   h ^type.func(*"".Entity, time.Time) ("".Key, bool)     type.*"".Entity     type.time.Time     type."".Key     type.bool   go.typelink.func(*openpgp.Entity, time.Time) (openpgp.Key, bool)	func(*"".Entity, time.Time) ("".Key, bool)          ^type.func(*"".Entity, time.Time) ("".Key, bool)   ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"       '      fgo.string."func(*openpgp.Entity) *openpgp.Identity"   fgo.string."func(*openpgp.Entity) *openpgp.Identity" P  Pfunc(*openpgp.Entity) *openpgp.Identity  Dtype.func(*"".Entity) *"".Identity         ! 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"   @  Vgo.weak.type.*func(*"".Entity) *"".Identity   P Dtype.func(*"".Entity) *"".Identity   h Dtype.func(*"".Entity) *"".Identity     type.*"".Entity     "type.*"".Identity   go.typelink.func(*openpgp.Entity) *openpgp.Identity	func(*"".Entity) *"".Identity          Dtype.func(*"".Entity) *"".Identity   2go.string.hdr."Serialize"       	      *go.string."Serialize"   *go.string."Serialize"   Serialize  Jgo.string.hdr."func(io.Writer) error"             Bgo.string."func(io.Writer) error"   Bgo.string."func(io.Writer) error" 0  ,func(io.Writer) error  4type.func(io.Writer) error         _9 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Jgo.string.hdr."func(io.Writer) error"   @  Fgo.weak.type.*func(io.Writer) error   P 4type.func(io.Writer) error   h 4type.func(io.Writer) error     type.io.Writer     type.error   ngo.typelink.func(io.Writer) error	func(io.Writer) error          4type.func(io.Writer) error   @go.string.hdr."SerializePrivate"             8go.string."SerializePrivate"   8go.string."SerializePrivate" (  "SerializePrivate  jgo.string.hdr."func(io.Writer, *packet.Config) error"       %      bgo.string."func(io.Writer, *packet.Config) error"   bgo.string."func(io.Writer, *packet.Config) error" P  Lfunc(io.Writer, *packet.Config) error  type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error         o` 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  jgo.string.hdr."func(io.Writer, *packet.Config) error"   @  go.weak.type.*func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(io.Writer, *packet.Config) error	func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   8go.string.hdr."SignIdentity"             0go.string."SignIdentity"   0go.string."SignIdentity"    SignIdentity  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"       3      ~go.string."func(string, *openpgp.Entity, *packet.Config) error"   ~go.string."func(string, *openpgp.Entity, *packet.Config) error" h  hfunc(string, *openpgp.Entity, *packet.Config) error  type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error         0= 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"   @  go.weak.type.*func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(string, *openpgp.Entity, *packet.Config) error	func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   :go.string.hdr."encryptionKey"             2go.string."encryptionKey"   2go.string."encryptionKey"    encryptionKey  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"       #      ^go.string."func(time.Time) (openpgp.Key, bool)"   ^go.string."func(time.Time) (openpgp.Key, bool)" H  Hfunc(time.Time) (openpgp.Key, bool)  Ftype.func(time.Time) ("".Key, bool)         3I 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"   @  Xgo.weak.type.*func(time.Time) ("".Key, bool)   P Ftype.func(time.Time) ("".Key, bool)   h Ftype.func(time.Time) ("".Key, bool)     type.time.Time     type."".Key     type.bool   go.typelink.func(time.Time) (openpgp.Key, bool)	func(time.Time) ("".Key, bool)          Ftype.func(time.Time) ("".Key, bool)   >go.string.hdr."primaryIdentity"             6go.string."primaryIdentity"   6go.string."primaryIdentity"     primaryIdentity  Pgo.string.hdr."func() *openpgp.Identity"             Hgo.string."func() *openpgp.Identity"   Hgo.string."func() *openpgp.Identity" 8  2func() *openpgp.Identity  0type.func() *"".Identity         $ 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."func() *openpgp.Identity"   @  Bgo.weak.type.*func() *"".Identity   P 0type.func() *"".Identity   h 0type.func() *"".Identity     "type.*"".Identity   pgo.typelink.func() *openpgp.Identity	func() *"".Identity          0type.func() *"".Identity   4go.string.hdr."signingKey"       
      ,go.string."signingKey"   ,go.string."signingKey"   signingKey  type.*"".Entity          U㈡ 6                                                                                                                                                                                          P @  runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."*openpgp.Entity"   @  0go.weak.type.**"".Entity   H  type."".Entity   8P type.*"".Entity   `x type.*"".Entity   x  2go.string.hdr."Serialize"     4type.func(io.Writer) error     Ltype.func(*"".Entity, io.Writer) error     ,"".(*Entity).Serialize     ,"".(*Entity).Serialize     @go.string.hdr."SerializePrivate"     type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     :"".(*Entity).SerializePrivate     :"".(*Entity).SerializePrivate     8go.string.hdr."SignIdentity"     type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     2"".(*Entity).SignIdentity     2"".(*Entity).SignIdentity     :go.string.hdr."encryptionKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     4"".(*Entity).encryptionKey     4"".(*Entity).encryptionKey     >go.string.hdr."primaryIdentity"     "go.importpath."".     0type.func() *"".Identity     Dtype.func(*"".Entity) *"".Identity     8"".(*Entity).primaryIdentity     8"".(*Entity).primaryIdentity     4go.string.hdr."signingKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     ."".(*Entity).signingKey     ."".(*Entity).signingKey   Dgo.string.hdr."**openpgp.Identity"             <go.string."**openpgp.Identity"   <go.string."**openpgp.Identity" (  &**openpgp.Identity  $type.**"".Identity P  P      yqZ 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."**openpgp.Identity"   @  6go.weak.type.***"".Identity   H  "type.*"".Identity   bgo.string.hdr."*map.hdr[string]*openpgp.Identity"       !      Zgo.string."*map.hdr[string]*openpgp.Identity"   Zgo.string."*map.hdr[string]*openpgp.Identity" H  D*map.hdr[string]*openpgp.Identity  Btype.*map.hdr[string]*"".Identity P  P      nu 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  bgo.string.hdr."*map.hdr[string]*openpgp.Identity"   @  Tgo.weak.type.**map.hdr[string]*"".Identity   H  @type.map.hdr[string]*"".Identity   bgo.string.hdr."map.iter[string]*openpgp.Identity"       !      Zgo.string."map.iter[string]*openpgp.Identity"   Zgo.string."map.iter[string]*openpgp.Identity" H  Dmap.iter[string]*openpgp.Identity  &go.string.hdr."key"             go.string."key"   go.string."key"   key  &go.string.hdr."val"             go.string."val"   go.string."val"   val  "go.string.hdr."t"             go.string."t"   go.string."t"   t  (go.string.hdr."bptr"              go.string."bptr"    go.string."bptr"   
bptr  2go.string.hdr."overflow0"       	      *go.string."overflow0"   *go.string."overflow0"   overflow0  2go.string.hdr."overflow1"       	      *go.string."overflow1"   *go.string."overflow1"   overflow1  6go.string.hdr."startBucket"             .go.string."startBucket"   .go.string."startBucket"   startBucket  *go.string.hdr."stuff"             "go.string."stuff"   "go.string."stuff"   stuff  ,go.string.hdr."bucket"             $go.string."bucket"   $go.string."bucket"   bucket  6go.string.hdr."checkBucket"             .go.string."checkBucket"   .go.string."checkBucket"   checkBucket  Btype.map.iter[string]*"".Identity   0       λ%                                                                                                                                                                                                                            $                   (                   ,   : p  runtime.algarray   (  "runtime.gcbits.ff   0  bgo.string.hdr."map.iter[string]*openpgp.Identity"   @  Tgo.weak.type.*map.iter[string]*"".Identity   H` Btype.map.iter[string]*"".Identity   `  &go.string.hdr."key"   p  type.*string     &go.string.hdr."val"     $type.**"".Identity     "go.string.hdr."t"     type.*uint8     "go.string.hdr."h"     Btype.*map.hdr[string]*"".Identity     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     (go.string.hdr."bptr"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."overflow0"     &type.unsafe.Pointer     2go.string.hdr."overflow1"     &type.unsafe.Pointer     6go.string.hdr."startBucket"     type.uintptr     *go.string.hdr."stuff"     type.uintptr     ,go.string.hdr."bucket"     type.uintptr     6go.string.hdr."checkBucket"     type.uintptr   Fgo.string.hdr."*openpgp.EntityList"             >go.string."*openpgp.EntityList"   >go.string."*openpgp.EntityList" (  (*openpgp.EntityList  .go.string.hdr."openpgp"             &go.string."openpgp"   &go.string."openpgp"   openpgp  4go.string.hdr."EntityList"       
      ,go.string."EntityList"   ,go.string."EntityList"   EntityList  0go.string.hdr."KeysById"             (go.string."KeysById"   (go.string."KeysById"   KeysById  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a             :go.string.hdr."KeysByIdUsage"             2go.string."KeysByIdUsage"   2go.string."KeysByIdUsage"    KeysByIdUsage  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·a041240a37ce609efec56707c330d1a4             <go.string.hdr."DecryptionKeys"             4go.string."DecryptionKeys"   4go.string."DecryptionKeys"    DecryptionKeys  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·2fccd208efe70893f9ac8d682812ae72             :go.string.hdr."[]openpgp.Key"             2go.string."[]openpgp.Key"   2go.string."[]openpgp.Key"    []openpgp.Key  type.[]"".Key P  P      F                         
   runtime.algarray   (  "runtime.gcbits.01   0  :go.string.hdr."[]openpgp.Key"   @  ,go.weak.type.*[]"".Key   H  type."".Key   Dgo.typelink.[]openpgp.Key	[]"".Key          type.[]"".Key   ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"       '      fgo.string."func(*openpgp.EntityList) []openpgp.Key"   fgo.string."func(*openpgp.EntityList) []openpgp.Key" P  Pfunc(*openpgp.EntityList) []openpgp.Key  Dtype.func(*"".EntityList) []"".Key         5X 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"   @  Vgo.weak.type.*func(*"".EntityList) []"".Key   P Dtype.func(*"".EntityList) []"".Key   h Dtype.func(*"".EntityList) []"".Key     &type.*"".EntityList     type.[]"".Key   go.typelink.func(*openpgp.EntityList) []openpgp.Key	func(*"".EntityList) []"".Key          Dtype.func(*"".EntityList) []"".Key   ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"       /      vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key"   vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key" `  `func(*openpgp.EntityList, uint64) []openpgp.Key  Ttype.func(*"".EntityList, uint64) []"".Key         Űȟ 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"   @  fgo.weak.type.*func(*"".EntityList, uint64) []"".Key   P Ttype.func(*"".EntityList, uint64) []"".Key   h Ttype.func(*"".EntityList, uint64) []"".Key     &type.*"".EntityList     type.uint64     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64) []openpgp.Key	func(*"".EntityList, uint64) []"".Key          Ttype.func(*"".EntityList, uint64) []"".Key   go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"       6      go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key" p  nfunc(*openpgp.EntityList, uint64, uint8) []openpgp.Key  btype.func(*"".EntityList, uint64, uint8) []"".Key         uJ? 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   @  tgo.weak.type.*func(*"".EntityList, uint64, uint8) []"".Key   P btype.func(*"".EntityList, uint64, uint8) []"".Key   h btype.func(*"".EntityList, uint64, uint8) []"".Key     &type.*"".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64, uint8) []openpgp.Key	func(*"".EntityList, uint64, uint8) []"".Key          btype.func(*"".EntityList, uint64, uint8) []"".Key   Hgo.string.hdr."func() []openpgp.Key"             @go.string."func() []openpgp.Key"   @go.string."func() []openpgp.Key" 0  *func() []openpgp.Key  (type.func() []"".Key         · 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  Hgo.string.hdr."func() []openpgp.Key"   @  :go.weak.type.*func() []"".Key   P (type.func() []"".Key   h (type.func() []"".Key     type.[]"".Key   `go.typelink.func() []openpgp.Key	func() []"".Key          (type.func() []"".Key   Tgo.string.hdr."func(uint64) []openpgp.Key"             Lgo.string."func(uint64) []openpgp.Key"   Lgo.string."func(uint64) []openpgp.Key" 8  6func(uint64) []openpgp.Key  4type.func(uint64) []"".Key         m 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."func(uint64) []openpgp.Key"   @  Fgo.weak.type.*func(uint64) []"".Key   P 4type.func(uint64) []"".Key   h 4type.func(uint64) []"".Key     type.uint64     type.[]"".Key   xgo.typelink.func(uint64) []openpgp.Key	func(uint64) []"".Key          4type.func(uint64) []"".Key   bgo.string.hdr."func(uint64, uint8) []openpgp.Key"       !      Zgo.string."func(uint64, uint8) []openpgp.Key"   Zgo.string."func(uint64, uint8) []openpgp.Key" H  Dfunc(uint64, uint8) []openpgp.Key  Btype.func(uint64, uint8) []"".Key         "GV 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  bgo.string.hdr."func(uint64, uint8) []openpgp.Key"   @  Tgo.weak.type.*func(uint64, uint8) []"".Key   P Btype.func(uint64, uint8) []"".Key   h Btype.func(uint64, uint8) []"".Key     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(uint64, uint8) []openpgp.Key	func(uint64, uint8) []"".Key          Btype.func(uint64, uint8) []"".Key   &type.*"".EntityList           6                                                                                                                  , @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."*openpgp.EntityList"   @  8go.weak.type.**"".EntityList   H  $type."".EntityList   8P &type.*"".EntityList   `x &type.*"".EntityList   x  <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Dtype.func(*"".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     >"".(*EntityList).DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Ttype.func(*"".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     2"".(*EntityList).KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     btype.func(*"".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     <"".(*EntityList).KeysByIdUsage   Dgo.string.hdr."openpgp.EntityList"             <go.string."openpgp.EntityList"   <go.string."openpgp.EntityList" (  &openpgp.EntityList  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"       &      dgo.string."func(openpgp.EntityList) []openpgp.Key"   dgo.string."func(openpgp.EntityList) []openpgp.Key" P  Nfunc(openpgp.EntityList) []openpgp.Key  Btype.func("".EntityList) []"".Key         "} 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"   @  Tgo.weak.type.*func("".EntityList) []"".Key   P Btype.func("".EntityList) []"".Key   h Btype.func("".EntityList) []"".Key     $type."".EntityList     type.[]"".Key   go.typelink.func(openpgp.EntityList) []openpgp.Key	func("".EntityList) []"".Key          Btype.func("".EntityList) []"".Key   |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"       .      tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key"   tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key" `  ^func(openpgp.EntityList, uint64) []openpgp.Key  Rtype.func("".EntityList, uint64) []"".Key          3                                                           runtime.algarray   (  "runtime.gcbits.01   0  |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"   @  dgo.weak.type.*func("".EntityList, uint64) []"".Key   P Rtype.func("".EntityList, uint64) []"".Key   h Rtype.func("".EntityList, uint64) []"".Key     $type."".EntityList     type.uint64     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64) []openpgp.Key	func("".EntityList, uint64) []"".Key          Rtype.func("".EntityList, uint64) []"".Key   go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"       5      go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key" p  lfunc(openpgp.EntityList, uint64, uint8) []openpgp.Key  `type.func("".EntityList, uint64, uint8) []"".Key         eᒑ 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   @  rgo.weak.type.*func("".EntityList, uint64, uint8) []"".Key   P `type.func("".EntityList, uint64, uint8) []"".Key   h `type.func("".EntityList, uint64, uint8) []"".Key     $type."".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64, uint8) []openpgp.Key	func("".EntityList, uint64, uint8) []"".Key          `type.func("".EntityList, uint64, uint8) []"".Key   $type."".EntityList          G                                                                                                                   0   runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."openpgp.EntityList"   @  &type.*"".EntityList   H  type.*"".Entity   8P $type."".EntityList   P  4go.string.hdr."EntityList"   X  "go.importpath."".   `x $type."".EntityList   x  <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Btype.func("".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     8"".EntityList.DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Rtype.func("".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     ,"".EntityList.KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     `type.func("".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     6"".EntityList.KeysByIdUsage   @go.string.hdr."**openpgp.Entity"             8go.string."**openpgp.Entity"   8go.string."**openpgp.Entity" (  "**openpgp.Entity   type.**"".Entity P  P      \f 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."**openpgp.Entity"   @  2go.weak.type.***"".Entity   H  type.*"".Entity   6go.string.hdr."[]io.Reader"             .go.string."[]io.Reader"   .go.string."[]io.Reader"   []io.Reader   type.[]io.Reader P  P      ~z|                         
   runtime.algarray   (  "runtime.gcbits.01   0  6go.string.hdr."[]io.Reader"   @  2go.weak.type.*[]io.Reader   H  type.io.Reader   Fgo.typelink.[]io.Reader	[]io.Reader           type.[]io.Reader   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc.[1]io.Reader          .type..hash.[1]io.Reader   2type..eqfunc.[1]io.Reader          *type..eq.[1]io.Reader   ,type..alg.[1]io.Reader              6type..hashfunc.[1]io.Reader     2type..eqfunc.[1]io.Reader   8go.string.hdr."[1]io.Reader"             0go.string."[1]io.Reader"   0go.string."[1]io.Reader"    [1]io.Reader  "type.[1]io.Reader `  `      Rx                                   ,type..alg.[1]io.Reader   (  "runtime.gcbits.03   0  8go.string.hdr."[1]io.Reader"   @  4go.weak.type.*[1]io.Reader   H  type.io.Reader   P   type.[]io.Reader   Jgo.typelink.[1]io.Reader	[1]io.Reader          "type.[1]io.Reader   :go.string.hdr."*[1]io.Reader"             2go.string."*[1]io.Reader"   2go.string."*[1]io.Reader"    *[1]io.Reader  $type.*[1]io.Reader P  P      &2 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  :go.string.hdr."*[1]io.Reader"   @  6go.weak.type.**[1]io.Reader   H  "type.[1]io.Reader   >go.string.hdr."[]packet.Packet"             6go.string."[]packet.Packet"   6go.string."[]packet.Packet"     []packet.Packet  `type.[]golang.org/x/crypto/openpgp/packet.Packet P  P      qM                          
   runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."[]packet.Packet"   @  rgo.weak.type.*[]golang.org/x/crypto/openpgp/packet.Packet   H  \type.golang.org/x/crypto/openpgp/packet.Packet   go.typelink.[]packet.Packet	[]golang.org/x/crypto/openpgp/packet.Packet          `type.[]golang.org/x/crypto/openpgp/packet.Packet   Dgo.string.hdr."**packet.Signature"             <go.string."**packet.Signature"   <go.string."**packet.Signature" (  &**packet.Signature  ftype.**golang.org/x/crypto/openpgp/packet.Signature P  P      d:u 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."**packet.Signature"   @  xgo.weak.type.***golang.org/x/crypto/openpgp/packet.Signature   H  dtype.*golang.org/x/crypto/openpgp/packet.Signature   0go.string.hdr."[]uint64"             (go.string."[]uint64"   (go.string."[]uint64"   []uint64  type.[]uint64 P  P      ?i                          
   runtime.algarray   (  "runtime.gcbits.01   0  0go.string.hdr."[]uint64"   @  ,go.weak.type.*[]uint64   H  type.uint64   :go.typelink.[]uint64	[]uint64          type.[]uint64   Ngo.string.hdr."*openpgp.MessageDetails"             Fgo.string."*openpgp.MessageDetails"   Fgo.string."*openpgp.MessageDetails" 0  0*openpgp.MessageDetails  .type.*"".MessageDetails  P  P      N 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*openpgp.MessageDetails"   @  @go.weak.type.**"".MessageDetails   H  ,type."".MessageDetails   *runtime.gcbits.e2f11f    Lgo.string.hdr."openpgp.MessageDetails"             Dgo.string."openpgp.MessageDetails"   Dgo.string."openpgp.MessageDetails" 0  .openpgp.MessageDetails  6go.string.hdr."IsEncrypted"             .go.string."IsEncrypted"   .go.string."IsEncrypted"   IsEncrypted  Bgo.string.hdr."EncryptedToKeyIds"             :go.string."EncryptedToKeyIds"   :go.string."EncryptedToKeyIds" (  $EncryptedToKeyIds  Pgo.string.hdr."IsSymmetricallyEncrypted"             Hgo.string."IsSymmetricallyEncrypted"   Hgo.string."IsSymmetricallyEncrypted" 8  2IsSymmetricallyEncrypted  :go.string.hdr."DecryptedWith"             2go.string."DecryptedWith"   2go.string."DecryptedWith"    DecryptedWith  0go.string.hdr."IsSigned"             (go.string."IsSigned"   (go.string."IsSigned"   IsSigned  :go.string.hdr."SignedByKeyId"             2go.string."SignedByKeyId"   2go.string."SignedByKeyId"    SignedByKeyId  0go.string.hdr."SignedBy"             (go.string."SignedBy"   (go.string."SignedBy"   SignedBy  6go.string.hdr."LiteralData"             .go.string."LiteralData"   .go.string."LiteralData"   LiteralData  <go.string.hdr."UnverifiedBody"             4go.string."UnverifiedBody"   4go.string."UnverifiedBody"    UnverifiedBody  <go.string.hdr."SignatureError"             4go.string."SignatureError"   4go.string."SignatureError"    SignatureError  2go.string.hdr."Signature"       	      *go.string."Signature"   *go.string."Signature"   Signature  2go.string.hdr."decrypted"       	      *go.string."decrypted"   *go.string."decrypted"   decrypted  <go.string.hdr."MessageDetails"             4go.string."MessageDetails"   4go.string."MessageDetails"    MessageDetails  ,type."".MessageDetails    T   T   1                                                                                                                            $                   (                   0                   4                   8                   @                   H                   L                       D p  runtime.algarray   (  *runtime.gcbits.e2f11f   0  Lgo.string.hdr."openpgp.MessageDetails"   @  .type.*"".MessageDetails   H` ,type."".MessageDetails   `  6go.string.hdr."IsEncrypted"   p  type.bool     Bgo.string.hdr."EncryptedToKeyIds"     type.[]uint64     Pgo.string.hdr."IsSymmetricallyEncrypted"     type.bool     :go.string.hdr."DecryptedWith"     type."".Key     0go.string.hdr."IsSigned"     type.bool     :go.string.hdr."SignedByKeyId"     type.uint64     0go.string.hdr."SignedBy"     type.*"".Key     6go.string.hdr."LiteralData"     htype.*golang.org/x/crypto/openpgp/packet.LiteralData     <go.string.hdr."UnverifiedBody"     type.io.Reader     <go.string.hdr."SignatureError"     type.error     2go.string.hdr."Signature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     2go.string.hdr."decrypted"     "go.importpath."".     $type.io.ReadCloser   8 ,type."".MessageDetails     <go.string.hdr."MessageDetails"     "go.importpath."".    ,type."".MessageDetails   ,go.string.hdr."[]bool"             $go.string."[]bool"   $go.string."[]bool"   []bool  type.[]bool P  P                               
   runtime.algarray   (  "runtime.gcbits.01   0  ,go.string.hdr."[]bool"   @  (go.weak.type.*[]bool   H  type.bool   2go.typelink.[]bool	[]bool          type.[]bool   .go.string.hdr."[8]bool"             &go.string."[8]bool"   &go.string."[8]bool"   [8]bool  type.[8]bool `  `       s5                                 P  runtime.algarray   (  runtime.gcbits.   0  .go.string.hdr."[8]bool"   @  *go.weak.type.*[8]bool   H  type.bool   P  type.[]bool   6go.typelink.[8]bool	[8]bool          type.[8]bool   Ngo.string.hdr."*map.bucket[string]bool"             Fgo.string."*map.bucket[string]bool"   Fgo.string."*map.bucket[string]bool" 0  0*map.bucket[string]bool  8type.*map.bucket[string]bool P  P      [E 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*map.bucket[string]bool"   @  Jgo.weak.type.**map.bucket[string]bool   H  6type.map.bucket[string]bool   *runtime.gcbits.545511   TU Lgo.string.hdr."map.bucket[string]bool"             Dgo.string."map.bucket[string]bool"   Dgo.string."map.bucket[string]bool" 0  .map.bucket[string]bool  6type.map.bucket[string]bool   T   T   2aB                                                                                      H                   P    p  runtime.algarray   (  *runtime.gcbits.545511   0  Lgo.string.hdr."map.bucket[string]bool"   @  Hgo.weak.type.*map.bucket[string]bool   H` 6type.map.bucket[string]bool   `  .go.string.hdr."topbits"   p  type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     type.[8]bool     0go.string.hdr."overflow"     8type.*map.bucket[string]bool   Fgo.string.hdr."map.hdr[string]bool"             >go.string."map.hdr[string]bool"   >go.string."map.hdr[string]bool" (  (map.hdr[string]bool  0type.map.hdr[string]bool         3(                                                                                                                                                                                        * p  runtime.algarray   (  "runtime.gcbits.58   0  Fgo.string.hdr."map.hdr[string]bool"   @  Bgo.weak.type.*map.hdr[string]bool   H` 0type.map.hdr[string]bool   `  *go.string.hdr."count"   p  type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     8type.*map.bucket[string]bool     4go.string.hdr."oldbuckets"     8type.*map.bucket[string]bool     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   >go.string.hdr."map[string]bool"             6go.string."map[string]bool"   6go.string."map[string]bool"     map[string]bool  (type.map[string]bool x  x       5                                      T    runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."map[string]bool"   @  :go.weak.type.*map[string]bool   H  type.string   P  type.bool   X  6type.map.bucket[string]bool   `  0type.map.hdr[string]bool   Vgo.typelink.map[string]bool	map[string]bool          (type.map[string]bool   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·1347047f6245a35b91e9a4f213167d52             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·6d46c0650eba7dbebc0db316e0e0cf3b             @go.string.hdr."*openpgp.KeyRing"             8go.string."*openpgp.KeyRing"   8go.string."*openpgp.KeyRing" (  "*openpgp.KeyRing   type.*"".KeyRing  P  P      $ 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."*openpgp.KeyRing"   @  2go.weak.type.**"".KeyRing   H  type."".KeyRing   >go.string.hdr."openpgp.KeyRing"             6go.string."openpgp.KeyRing"   6go.string."openpgp.KeyRing"     openpgp.KeyRing  .go.string.hdr."KeyRing"             &go.string."KeyRing"   &go.string."KeyRing"   KeyRing  type."".KeyRing          N                                                                                          runtime.algarray   (  "runtime.gcbits.03   0  >go.string.hdr."openpgp.KeyRing"   @   type.*"".KeyRing   H` type."".KeyRing   `  <go.string.hdr."DecryptionKeys"   p  (type.func() []"".Key   x  0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key   8 type."".KeyRing     .go.string.hdr."KeyRing"     "go.importpath."".    type."".KeyRing   Ngo.string.hdr."*openpgp.PromptFunction"             Fgo.string."*openpgp.PromptFunction"   Fgo.string."*openpgp.PromptFunction" 0  0*openpgp.PromptFunction  .type.*"".PromptFunction  P  P      !g 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*openpgp.PromptFunction"   @  @go.weak.type.**"".PromptFunction   H  ,type."".PromptFunction   Lgo.string.hdr."openpgp.PromptFunction"             Dgo.string."openpgp.PromptFunction"   Dgo.string."openpgp.PromptFunction" 0  .openpgp.PromptFunction  <go.string.hdr."PromptFunction"             4go.string."PromptFunction"   4go.string."PromptFunction"    PromptFunction  ,type."".PromptFunction          4 3                                                                                   runtime.algarray   (  "runtime.gcbits.01   0  Lgo.string.hdr."openpgp.PromptFunction"   @  .type.*"".PromptFunction   P ,type."".PromptFunction   h ,type."".PromptFunction     type.[]"".Key     type.bool     type.[]uint8     type.error   8 ,type."".PromptFunction     <go.string.hdr."PromptFunction"     "go.importpath."".    ,type."".PromptFunction   ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"             Vgo.string."[]*packet.SymmetricKeyEncrypted"   Vgo.string."[]*packet.SymmetricKeyEncrypted" @  @[]*packet.SymmetricKeyEncrypted  type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted P  P      ް-                         
   runtime.algarray   (  "runtime.gcbits.01   0  ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"   @  go.weak.type.*[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   H  |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   go.typelink.[]*packet.SymmetricKeyEncrypted	[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted          type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted    type..hashfunc20             ,runtime.memhash_varlen   type..eqfunc20             .runtime.memequal_varlen   type..alg20               type..hashfunc20     type..eqfunc20   Pgo.string.hdr."*openpgp.keyEnvelopePair"             Hgo.string."*openpgp.keyEnvelopePair"   Hgo.string."*openpgp.keyEnvelopePair" 8  2*openpgp.keyEnvelopePair  0type.*"".keyEnvelopePair  P  P      GR4 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."*openpgp.keyEnvelopePair"   @  Bgo.weak.type.**"".keyEnvelopePair   H  .type."".keyEnvelopePair   "runtime.gcbits.1f    Ngo.string.hdr."openpgp.keyEnvelopePair"             Fgo.string."openpgp.keyEnvelopePair"   Fgo.string."openpgp.keyEnvelopePair" 0  0openpgp.keyEnvelopePair  8go.string.hdr."encryptedKey"             0go.string."encryptedKey"   0go.string."encryptedKey"    encryptedKey  >go.string.hdr."keyEnvelopePair"             6go.string."keyEnvelopePair"   6go.string."keyEnvelopePair"     keyEnvelopePair  .type."".keyEnvelopePair                                                                                                       type..alg20   (  "runtime.gcbits.1f   0  Ngo.string.hdr."openpgp.keyEnvelopePair"   @  0type.*"".keyEnvelopePair   H` .type."".keyEnvelopePair   `  &go.string.hdr."key"   h  "go.importpath."".   p  type."".Key     8go.string.hdr."encryptedKey"     "go.importpath."".     jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   8 .type."".keyEnvelopePair     >go.string.hdr."keyEnvelopePair"     "go.importpath."".    .type."".keyEnvelopePair   Rgo.string.hdr."[]openpgp.keyEnvelopePair"             Jgo.string."[]openpgp.keyEnvelopePair"   Jgo.string."[]openpgp.keyEnvelopePair" 8  4[]openpgp.keyEnvelopePair  2type.[]"".keyEnvelopePair P  P      r                         
   runtime.algarray   (  "runtime.gcbits.01   0  Rgo.string.hdr."[]openpgp.keyEnvelopePair"   @  Dgo.weak.type.*[]"".keyEnvelopePair   H  .type."".keyEnvelopePair   tgo.typelink.[]openpgp.keyEnvelopePair	[]"".keyEnvelopePair          2type.[]"".keyEnvelopePair   \go.string.hdr."**packet.SymmetricKeyEncrypted"             Tgo.string."**packet.SymmetricKeyEncrypted"   Tgo.string."**packet.SymmetricKeyEncrypted" @  >**packet.SymmetricKeyEncrypted  ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted P  P      Z 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  \go.string.hdr."**packet.SymmetricKeyEncrypted"   @  go.weak.type.***golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   H  |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ltype..hashfunc."".signatureCheckReader          Dtype..hash."".signatureCheckReader   Htype..eqfunc."".signatureCheckReader          @type..eq."".signatureCheckReader   Btype..alg."".signatureCheckReader              Ltype..hashfunc."".signatureCheckReader     Htype..eqfunc."".signatureCheckReader   Zgo.string.hdr."*openpgp.signatureCheckReader"             Rgo.string."*openpgp.signatureCheckReader"   Rgo.string."*openpgp.signatureCheckReader" @  <*openpgp.signatureCheckReader  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"       9      go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)" x  tfunc(*openpgp.signatureCheckReader, []uint8) (int, error)  rtype.func(*"".signatureCheckReader, []uint8) (int, error)         @. 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   @  go.weak.type.*func(*"".signatureCheckReader, []uint8) (int, error)   P rtype.func(*"".signatureCheckReader, []uint8) (int, error)   h rtype.func(*"".signatureCheckReader, []uint8) (int, error)     :type.*"".signatureCheckReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureCheckReader, []uint8) (int, error)	func(*"".signatureCheckReader, []uint8) (int, error)          rtype.func(*"".signatureCheckReader, []uint8) (int, error)   (go.string.hdr."Read"              go.string."Read"    go.string."Read"   
Read  :type.*"".signatureCheckReader          :a 6                                                                   @  runtime.algarray   (  "runtime.gcbits.01   0  Zgo.string.hdr."*openpgp.signatureCheckReader"   @  Lgo.weak.type.**"".signatureCheckReader   H  8type."".signatureCheckReader   8P :type.*"".signatureCheckReader   `x :type.*"".signatureCheckReader   x  (go.string.hdr."Read"     >type.func([]uint8) (int, error)     rtype.func(*"".signatureCheckReader, []uint8) (int, error)     >"".(*signatureCheckReader).Read     >"".(*signatureCheckReader).Read   "runtime.gcbits.3f   ? Xgo.string.hdr."openpgp.signatureCheckReader"             Pgo.string."openpgp.signatureCheckReader"   Pgo.string."openpgp.signatureCheckReader" @  :openpgp.signatureCheckReader  .go.string.hdr."packets"             &go.string."packets"   &go.string."packets"   packets  6go.string.hdr."wrappedHash"             .go.string."wrappedHash"   .go.string."wrappedHash"   wrappedHash  $go.string.hdr."md"             go.string."md"   go.string."md"   md  Hgo.string.hdr."signatureCheckReader"             @go.string."signatureCheckReader"   @go.string."signatureCheckReader" 0  *signatureCheckReader  8type."".signatureCheckReader          MA                                                                                                                                *   Btype..alg."".signatureCheckReader   (  "runtime.gcbits.3f   0  Xgo.string.hdr."openpgp.signatureCheckReader"   @  :type.*"".signatureCheckReader   H` 8type."".signatureCheckReader   `  .go.string.hdr."packets"   h  "go.importpath."".   p  ^type.*golang.org/x/crypto/openpgp/packet.Reader     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     6go.string.hdr."wrappedHash"     "go.importpath."".     type.hash.Hash     $go.string.hdr."md"     "go.importpath."".     .type.*"".MessageDetails   8 8type."".signatureCheckReader     Hgo.string.hdr."signatureCheckReader"     "go.importpath."".    8type."".signatureCheckReader   Hgo.string.hdr."*openpgp.checkReader"             @go.string."*openpgp.checkReader"   @go.string."*openpgp.checkReader" 0  **openpgp.checkReader  6go.string.hdr."checkReader"             .go.string."checkReader"   .go.string."checkReader"   checkReader  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"       0      xgo.string."func(*openpgp.checkReader, []uint8) (int, error)"   xgo.string."func(*openpgp.checkReader, []uint8) (int, error)" h  bfunc(*openpgp.checkReader, []uint8) (int, error)  `type.func(*"".checkReader, []uint8) (int, error)         V#. 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"   @  rgo.weak.type.*func(*"".checkReader, []uint8) (int, error)   P `type.func(*"".checkReader, []uint8) (int, error)   h `type.func(*"".checkReader, []uint8) (int, error)     (type.*"".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.checkReader, []uint8) (int, error)	func(*"".checkReader, []uint8) (int, error)          `type.func(*"".checkReader, []uint8) (int, error)   (type.*"".checkReader           6                                                                   @  runtime.algarray   (  "runtime.gcbits.01   0  Hgo.string.hdr."*openpgp.checkReader"   @  :go.weak.type.**"".checkReader   H  &type."".checkReader   8P (type.*"".checkReader   `x (type.*"".checkReader   x  (go.string.hdr."Read"     >type.func([]uint8) (int, error)     `type.func(*"".checkReader, []uint8) (int, error)     ,"".(*checkReader).Read     ,"".(*checkReader).Read   Fgo.string.hdr."openpgp.checkReader"             >go.string."openpgp.checkReader"   >go.string."openpgp.checkReader" (  (openpgp.checkReader  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"       /      vgo.string."func(openpgp.checkReader, []uint8) (int, error)"   vgo.string."func(openpgp.checkReader, []uint8) (int, error)" `  `func(openpgp.checkReader, []uint8) (int, error)  ^type.func("".checkReader, []uint8) (int, error)         1f 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"   @  pgo.weak.type.*func("".checkReader, []uint8) (int, error)   P ^type.func("".checkReader, []uint8) (int, error)   h ^type.func("".checkReader, []uint8) (int, error)     &type."".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.checkReader, []uint8) (int, error)	func("".checkReader, []uint8) (int, error)          ^type.func("".checkReader, []uint8) (int, error)   &type."".checkReader          $ 9                                                                                            " @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."openpgp.checkReader"   @  (type.*"".checkReader   H` &type."".checkReader   `  $go.string.hdr."md"   h  "go.importpath."".   p  .type.*"".MessageDetails   8 &type."".checkReader     6go.string.hdr."checkReader"     "go.importpath."".    &type."".checkReader     (go.string.hdr."Read"     >type.func([]uint8) (int, error)     ^type.func("".checkReader, []uint8) (int, error)     &"".checkReader.Read     &"".checkReader.Read   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc."".FileHints          .type..hash."".FileHints   2type..eqfunc."".FileHints          *type..eq."".FileHints   ,type..alg."".FileHints              6type..hashfunc."".FileHints     2type..eqfunc."".FileHints   "runtime.gcbits.42   B Bgo.string.hdr."openpgp.FileHints"             :go.string."openpgp.FileHints"   :go.string."openpgp.FileHints" (  $openpgp.FileHints  0go.string.hdr."IsBinary"             (go.string."IsBinary"   (go.string."IsBinary"   IsBinary  0go.string.hdr."FileName"             (go.string."FileName"   (go.string."FileName"   FileName  .go.string.hdr."ModTime"             &go.string."ModTime"   &go.string."ModTime"   ModTime  2go.string.hdr."FileHints"       	      *go.string."FileHints"   *go.string."FileHints"   FileHints  "type."".FileHints          82                                                                                                                ,type..alg."".FileHints   (  "runtime.gcbits.42   0  Bgo.string.hdr."openpgp.FileHints"   @  $type.*"".FileHints   H` "type."".FileHints   `  0go.string.hdr."IsBinary"   p  type.bool     0go.string.hdr."FileName"     type.string     .go.string.hdr."ModTime"     type.time.Time   8 "type."".FileHints     2go.string.hdr."FileHints"     "go.importpath."".    "type."".FileHints   Dgo.string.hdr."*openpgp.FileHints"             <go.string."*openpgp.FileHints"   <go.string."*openpgp.FileHints" (  &*openpgp.FileHints  $type.*"".FileHints  P  P      j 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."*openpgp.FileHints"   @  6go.weak.type.**"".FileHints   H  "type."".FileHints   Fgo.string.hdr."*openpgp.noOpCloser"             >go.string."*openpgp.noOpCloser"   >go.string."*openpgp.noOpCloser" (  (*openpgp.noOpCloser  4go.string.hdr."noOpCloser"       
      ,go.string."noOpCloser"   ,go.string."noOpCloser"   noOpCloser  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             *go.string.hdr."Close"             "go.string."Close"   "go.string."Close"   Close  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             ^go.string.hdr."func(*openpgp.noOpCloser) error"             Vgo.string."func(*openpgp.noOpCloser) error"   Vgo.string."func(*openpgp.noOpCloser) error" @  @func(*openpgp.noOpCloser) error  >type.func(*"".noOpCloser) error         $_ 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ^go.string.hdr."func(*openpgp.noOpCloser) error"   @  Pgo.weak.type.*func(*"".noOpCloser) error   P >type.func(*"".noOpCloser) error   h >type.func(*"".noOpCloser) error     &type.*"".noOpCloser     type.error   go.typelink.func(*openpgp.noOpCloser) error	func(*"".noOpCloser) error          >type.func(*"".noOpCloser) error   ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"       /      vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)"   vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)" `  `func(*openpgp.noOpCloser, []uint8) (int, error)  ^type.func(*"".noOpCloser, []uint8) (int, error)         6rA 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"   @  pgo.weak.type.*func(*"".noOpCloser, []uint8) (int, error)   P ^type.func(*"".noOpCloser, []uint8) (int, error)   h ^type.func(*"".noOpCloser, []uint8) (int, error)     &type.*"".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.noOpCloser, []uint8) (int, error)	func(*"".noOpCloser, []uint8) (int, error)          ^type.func(*"".noOpCloser, []uint8) (int, error)   8go.string.hdr."func() error"             0go.string."func() error"   0go.string."func() error"    func() error  "type.func() error         ֵ 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  8go.string.hdr."func() error"   @  4go.weak.type.*func() error   P "type.func() error   h "type.func() error     type.error   Jgo.typelink.func() error	func() error          "type.func() error   &type.*"".noOpCloser          ML 6                                                                                          " @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."*openpgp.noOpCloser"   @  8go.weak.type.**"".noOpCloser   H  $type."".noOpCloser   8P &type.*"".noOpCloser   `x &type.*"".noOpCloser   x  *go.string.hdr."Close"     "type.func() error     >type.func(*"".noOpCloser) error     ,"".(*noOpCloser).Close     ,"".(*noOpCloser).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ^type.func(*"".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     ,"".(*noOpCloser).Write   Dgo.string.hdr."openpgp.noOpCloser"             <go.string."openpgp.noOpCloser"   <go.string."openpgp.noOpCloser" (  &openpgp.noOpCloser  "go.string.hdr."w"             go.string."w"   go.string."w"   w  \go.string.hdr."func(openpgp.noOpCloser) error"             Tgo.string."func(openpgp.noOpCloser) error"   Tgo.string."func(openpgp.noOpCloser) error" @  >func(openpgp.noOpCloser) error  <type.func("".noOpCloser) error         4Y9 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  \go.string.hdr."func(openpgp.noOpCloser) error"   @  Ngo.weak.type.*func("".noOpCloser) error   P <type.func("".noOpCloser) error   h <type.func("".noOpCloser) error     $type."".noOpCloser     type.error   go.typelink.func(openpgp.noOpCloser) error	func("".noOpCloser) error          <type.func("".noOpCloser) error   |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"       .      tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)"   tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)" `  ^func(openpgp.noOpCloser, []uint8) (int, error)  \type.func("".noOpCloser, []uint8) (int, error)         ~9 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"   @  ngo.weak.type.*func("".noOpCloser, []uint8) (int, error)   P \type.func("".noOpCloser, []uint8) (int, error)   h \type.func("".noOpCloser, []uint8) (int, error)     $type."".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.noOpCloser, []uint8) (int, error)	func("".noOpCloser, []uint8) (int, error)          \type.func("".noOpCloser, []uint8) (int, error)   $type."".noOpCloser          n                                                                                                                     ,   runtime.algarray   (  "runtime.gcbits.03   0  Dgo.string.hdr."openpgp.noOpCloser"   @  &type.*"".noOpCloser   H` $type."".noOpCloser   `  "go.string.hdr."w"   h  "go.importpath."".   p  type.io.Writer   8 $type."".noOpCloser     4go.string.hdr."noOpCloser"     "go.importpath."".    $type."".noOpCloser     *go.string.hdr."Close"     "type.func() error     <type.func("".noOpCloser) error     ,"".(*noOpCloser).Close     &"".noOpCloser.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     \type.func("".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     &"".noOpCloser.Write   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·895d0569a38a56443b84805daa09d838              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Btype..hashfunc."".signatureWriter          :type..hash."".signatureWriter   >type..eqfunc."".signatureWriter          6type..eq."".signatureWriter   8type..alg."".signatureWriter              Btype..hashfunc."".signatureWriter     >type..eqfunc."".signatureWriter   Pgo.string.hdr."*openpgp.signatureWriter"             Hgo.string."*openpgp.signatureWriter"   Hgo.string."*openpgp.signatureWriter" 8  2*openpgp.signatureWriter  >go.string.hdr."signatureWriter"             6go.string."signatureWriter"   6go.string."signatureWriter"     signatureWriter  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             hgo.string.hdr."func(*openpgp.signatureWriter) error"       $      `go.string."func(*openpgp.signatureWriter) error"   `go.string."func(*openpgp.signatureWriter) error" P  Jfunc(*openpgp.signatureWriter) error  Htype.func(*"".signatureWriter) error         / 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."func(*openpgp.signatureWriter) error"   @  Zgo.weak.type.*func(*"".signatureWriter) error   P Htype.func(*"".signatureWriter) error   h Htype.func(*"".signatureWriter) error     0type.*"".signatureWriter     type.error   go.typelink.func(*openpgp.signatureWriter) error	func(*"".signatureWriter) error          Htype.func(*"".signatureWriter) error   go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"       4      go.string."func(*openpgp.signatureWriter, []uint8) (int, error)"   go.string."func(*openpgp.signatureWriter, []uint8) (int, error)" p  jfunc(*openpgp.signatureWriter, []uint8) (int, error)  htype.func(*"".signatureWriter, []uint8) (int, error)         l 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"   @  zgo.weak.type.*func(*"".signatureWriter, []uint8) (int, error)   P htype.func(*"".signatureWriter, []uint8) (int, error)   h htype.func(*"".signatureWriter, []uint8) (int, error)     0type.*"".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureWriter, []uint8) (int, error)	func(*"".signatureWriter, []uint8) (int, error)          htype.func(*"".signatureWriter, []uint8) (int, error)   0type.*"".signatureWriter          + 6                                                                                          " @  runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."*openpgp.signatureWriter"   @  Bgo.weak.type.**"".signatureWriter   H  .type."".signatureWriter   8P 0type.*"".signatureWriter   `x 0type.*"".signatureWriter   x  *go.string.hdr."Close"     "type.func() error     Htype.func(*"".signatureWriter) error     6"".(*signatureWriter).Close     6"".(*signatureWriter).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     htype.func(*"".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     6"".(*signatureWriter).Write   &runtime.gcbits.ef01    Ngo.string.hdr."openpgp.signatureWriter"             Fgo.string."openpgp.signatureWriter"   Fgo.string."openpgp.signatureWriter" 0  0openpgp.signatureWriter  :go.string.hdr."encryptedData"             2go.string."encryptedData"   2go.string."encryptedData"    encryptedData  6go.string.hdr."literalData"             .go.string."literalData"   .go.string."literalData"   literalData  0go.string.hdr."hashType"             (go.string."hashType"   (go.string."hashType"   hashType  ,go.string.hdr."signer"             $go.string."signer"   $go.string."signer"   signer  ,go.string.hdr."config"             $go.string."config"   $go.string."config"   config  fgo.string.hdr."func(openpgp.signatureWriter) error"       #      ^go.string."func(openpgp.signatureWriter) error"   ^go.string."func(openpgp.signatureWriter) error" H  Hfunc(openpgp.signatureWriter) error  Ftype.func("".signatureWriter) error         ! 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  fgo.string.hdr."func(openpgp.signatureWriter) error"   @  Xgo.weak.type.*func("".signatureWriter) error   P Ftype.func("".signatureWriter) error   h Ftype.func("".signatureWriter) error     .type."".signatureWriter     type.error   go.typelink.func(openpgp.signatureWriter) error	func("".signatureWriter) error          Ftype.func("".signatureWriter) error   go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"       3      ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)"   ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)" h  hfunc(openpgp.signatureWriter, []uint8) (int, error)  ftype.func("".signatureWriter, []uint8) (int, error)         E 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"   @  xgo.weak.type.*func("".signatureWriter, []uint8) (int, error)   P ftype.func("".signatureWriter, []uint8) (int, error)   h ftype.func("".signatureWriter, []uint8) (int, error)     .type."".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.signatureWriter, []uint8) (int, error)	func("".signatureWriter, []uint8) (int, error)          ftype.func("".signatureWriter, []uint8) (int, error)   .type."".signatureWriter    $   $   դ                                                                                                                                                                                                                     J   8type..alg."".signatureWriter   (  &runtime.gcbits.ef01   0  Ngo.string.hdr."openpgp.signatureWriter"   @  0type.*"".signatureWriter   H` .type."".signatureWriter   `  :go.string.hdr."encryptedData"   h  "go.importpath."".   p  &type.io.WriteCloser     6go.string.hdr."literalData"     "go.importpath."".     &type.io.WriteCloser     0go.string.hdr."hashType"     "go.importpath."".      type.crypto.Hash     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     ,go.string.hdr."signer"     "go.importpath."".     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     ,go.string.hdr."config"     "go.importpath."".     ^type.*golang.org/x/crypto/openpgp/packet.Config   8 .type."".signatureWriter     >go.string.hdr."signatureWriter"     "go.importpath."".    .type."".signatureWriter     *go.string.hdr."Close"     "type.func() error     Ftype.func("".signatureWriter) error     6"".(*signatureWriter).Close     0"".signatureWriter.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ftype.func("".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     0"".signatureWriter.Write   Bgo.string.hdr."[]*openpgp.Entity"             :go.string."[]*openpgp.Entity"   :go.string."[]*openpgp.Entity" (  $[]*openpgp.Entity  "type.[]*"".Entity P  P      5^                         
   runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."[]*openpgp.Entity"   @  4go.weak.type.*[]*"".Entity   H  type.*"".Entity   Tgo.typelink.[]*openpgp.Entity	[]*"".Entity          "type.[]*"".Entity   type..hashfunc3             ,runtime.memhash_varlen   type..eqfunc3             .runtime.memequal_varlen   type..alg3              type..hashfunc3     type..eqfunc3   0go.string.hdr."[3]uint8"             (go.string."[3]uint8"   (go.string."[3]uint8"   [3]uint8  type.[3]uint8 `  `       ¹R                                   type..alg3   (  runtime.gcbits.   0  0go.string.hdr."[3]uint8"   @  ,go.weak.type.*[3]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[3]uint8	[3]uint8          type.[3]uint8   2go.string.hdr."*[3]uint8"       	      *go.string."*[3]uint8"   *go.string."*[3]uint8"   *[3]uint8  type.*[3]uint8 P  P      ifl 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  2go.string.hdr."*[3]uint8"   @  .go.weak.type.**[3]uint8   H  type.[3]uint8   0go.string.hdr."[4]uint8"             (go.string."[4]uint8"   (go.string."[4]uint8"   [4]uint8  type.[4]uint8 `  `       B                                 @  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[4]uint8"   @  ,go.weak.type.*[4]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[4]uint8	[4]uint8          type.[4]uint8   2go.string.hdr."*[4]uint8"       	      *go.string."*[4]uint8"   *go.string."*[4]uint8"   *[4]uint8  type.*[4]uint8 P  P      G 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  2go.string.hdr."*[4]uint8"   @  .go.weak.type.**[4]uint8   H  type.[4]uint8   2go.string.hdr."[32]uint8"       	      *go.string."[32]uint8"   *go.string."[32]uint8"   [32]uint8  type.[32]uint8 `  `        Y                                    type..alg32   (  runtime.gcbits.   0  2go.string.hdr."[32]uint8"   @  .go.weak.type.*[32]uint8   H  type.uint8   P  type.[]uint8   >go.typelink.[32]uint8	[32]uint8          type.[32]uint8   0go.string.hdr."[2]uint8"             (go.string."[2]uint8"   (go.string."[2]uint8"   [2]uint8  type.[2]uint8 `  `       F                                 0  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[2]uint8"   @  ,go.weak.type.*[2]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[2]uint8	[2]uint8          type.[2]uint8   4go.string.hdr."*[8]string"       
      ,go.string."*[8]string"   ,go.string."*[8]string"   *[8]string  type.*[8]string P  P      o 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  4go.string.hdr."*[8]string"   @  0go.weak.type.**[8]string   H  type.[8]string   (go.string.hdr."hash"              go.string."hash"    go.string."hash"   
hash  &go.importpath.hash.              go.string."hash"   $go.string.hdr."io"             go.string."io"   go.string."io"   io  "go.importpath.io.             go.string."io"   4go.string.hdr."crypto/rsa"       
      ,go.string."crypto/rsa"   ,go.string."crypto/rsa"   crypto/rsa  2go.importpath.crypto/rsa.       
      ,go.string."crypto/rsa"   ,go.string.hdr."crypto"             $go.string."crypto"   $go.string."crypto"   crypto  *go.importpath.crypto.             $go.string."crypto"   (go.string.hdr."time"              go.string."time"    go.string."time"   
time  &go.importpath.time.              go.string."time"   bgo.string.hdr."golang.org/x/crypto/openpgp/armor"       !      Zgo.string."golang.org/x/crypto/openpgp/armor"   Zgo.string."golang.org/x/crypto/openpgp/armor" H  Dgolang.org/x/crypto/openpgp/armor  `go.importpath.golang.org/x/crypto/openpgp/armor.       !      Zgo.string."golang.org/x/crypto/openpgp/armor"   dgo.string.hdr."golang.org/x/crypto/openpgp/errors"       "      \go.string."golang.org/x/crypto/openpgp/errors"   \go.string."golang.org/x/crypto/openpgp/errors" H  Fgolang.org/x/crypto/openpgp/errors  bgo.importpath.golang.org/x/crypto/openpgp/errors.       "      \go.string."golang.org/x/crypto/openpgp/errors"   .go.string.hdr."strconv"             &go.string."strconv"   &go.string."strconv"   strconv  ,go.importpath.strconv.             &go.string."strconv"   dgo.string.hdr."golang.org/x/crypto/openpgp/packet"       "      \go.string."golang.org/x/crypto/openpgp/packet"   \go.string."golang.org/x/crypto/openpgp/packet" H  Fgolang.org/x/crypto/openpgp/packet  bgo.importpath.golang.org/x/crypto/openpgp/packet.       "      \go.string."golang.org/x/crypto/openpgp/packet"   ^go.string.hdr."golang.org/x/crypto/openpgp/s2k"             Vgo.string."golang.org/x/crypto/openpgp/s2k"   Vgo.string."golang.org/x/crypto/openpgp/s2k" @  @golang.org/x/crypto/openpgp/s2k  \go.importpath.golang.org/x/crypto/openpgp/s2k.             Vgo.string."golang.org/x/crypto/openpgp/s2k"   :go.string.hdr."crypto/sha256"             2go.string."crypto/sha256"   2go.string."crypto/sha256"    crypto/sha256  8go.importpath.crypto/sha256.             2go.string."crypto/sha256"   Dtype..hash."".canonicalTextHash·f          >type..hash."".canonicalTextHash   @type..eq."".canonicalTextHash·f          :type..eq."".canonicalTextHash   .type..hash.[8]string·f          (type..hash.[8]string   *type..eq.[8]string·f          $type..eq.[8]string   8"".(*EntityList).KeysById·f          2"".(*EntityList).KeysById   B"".(*EntityList).KeysByIdUsage·f          <"".(*EntityList).KeysByIdUsage   D"".(*EntityList).DecryptionKeys·f          >"".(*EntityList).DecryptionKeys   4type..hash.[1]io.Reader·f          .type..hash.[1]io.Reader   0type..eq.[1]io.Reader·f          *type..eq.[1]io.Reader   8"".KeyRing.DecryptionKeys·f          2"".KeyRing.DecryptionKeys   ,"".KeyRing.KeysById·f          &"".KeyRing.KeysById   6"".KeyRing.KeysByIdUsage·f          0"".KeyRing.KeysByIdUsage   Jtype..hash."".signatureCheckReader·f          Dtype..hash."".signatureCheckReader   Ftype..eq."".signatureCheckReader·f          @type..eq."".signatureCheckReader   2"".(*checkReader).Read·f          ,"".(*checkReader).Read   4type..hash."".FileHints·f          .type..hash."".FileHints   0type..eq."".FileHints·f          *type..eq."".FileHints   2"".(*noOpCloser).Write·f          ,"".(*noOpCloser).Write   2"".(*noOpCloser).Close·f          ,"".(*noOpCloser).Close   @type..hash."".signatureWriter·f          :type..hash."".signatureWriter   <type..eq."".signatureWriter·f          6type..eq."".signatureWriter   <"".(*signatureWriter).Write·f          6"".(*signatureWriter).Write   <"".(*signatureWriter).Close·f          6"".(*signatureWriter).Close   go13ld 