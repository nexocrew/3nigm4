!<arch>
__.PKGDEF       0           0     0     644     61534     `
go object netbsd 386 go1.6.2 X:none
build id "2dfe78055535f31dfdfea9cc1760516684549ceb"

$$
package openpgp
	import hash "hash"
	import io "io"
	import rsa "crypto/rsa"
	import crypto "crypto"
	import time "time"
	import armor "golang.org/x/crypto/openpgp/armor"
	import errors "golang.org/x/crypto/openpgp/errors"
	import strconv "strconv"
	import packet "golang.org/x/crypto/openpgp/packet"
	import s2k "golang.org/x/crypto/openpgp/s2k"
	import sha256 "crypto/sha256"
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".NewCanonicalTextHash (@"".h·2 @"hash".Hash) (? @"hash".Hash) { return (&@"".canonicalTextHash{ @"".h:@"".h·2, @"".s:int(0x0) }) }
	var @"".PublicKeyType string
	var @"".PrivateKeyType string
	type @"time".zone struct { @"time".name string; @"time".offset int; @"time".isDST bool }
	type @"time".zoneTrans struct { @"time".when int64; @"time".index uint8; @"time".isstd bool; @"time".isutc bool }
	type @"time".Location struct { @"time".name string; @"time".zone []@"time".zone; @"time".tx []@"time".zoneTrans; @"time".cacheStart int64; @"time".cacheEnd int64; @"time".cacheZone *@"time".zone }
	func (@"time".l·2 *@"time".Location "esc:0x22") String () (? string)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".firstZoneUsed () (? bool)
	func (@"time".l·2 *@"time".Location "esc:0x12") @"time".get () (? *@"time".Location)
	func (@"time".l·6 *@"time".Location "esc:0x32") @"time".lookup (@"time".sec·7 int64) (@"time".name·1 string, @"time".offset·2 int, @"time".isDST·3 bool, @"time".start·4 int64, @"time".end·5 int64)
	func (@"time".l·2 *@"time".Location "esc:0x1") @"time".lookupFirstZone () (? int)
	func (@"time".l·4 *@"time".Location "esc:0x1") @"time".lookupName (@"time".name·5 string "esc:0x1", @"time".unix·6 int64) (@"time".offset·1 int, @"time".isDST·2 bool, @"time".ok·3 bool)
	type @"time".Duration int64
	func (@"time".d·2 @"time".Duration) Hours () (? float64) { var @"time".hour·3 @"time".Duration; ; @"time".hour·3 = @"time".d·2 / @"time".Duration(0x34630b8a000); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x34630b8a000); return float64(@"time".hour·3) + float64(@"time".nsec·4) * float64(8190022623310637111963488201822504381538623676021880892417778544696899264837610290203272971060556344039023584360473938041055625214280336402169897364226048p-553) }
	func (@"time".d·2 @"time".Duration) Minutes () (? float64) { var @"time".min·3 @"time".Duration; ; @"time".min·3 = @"time".d·2 / @"time".Duration(0xdf8475800); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0xdf8475800); return float64(@"time".min·3) + float64(@"time".nsec·4) * float64(7678146209353722106395056769533233877065564876941352542109479049699919628723768656821910653339403201031675627614471533358284117434246264392176261853609984p-547) }
	func (@"time".d·2 @"time".Duration) Nanoseconds () (? int64) { return int64(@"time".d·2) }
	func (@"time".d·2 @"time".Duration) Seconds () (? float64) { var @"time".sec·3 @"time".Duration; ; @"time".sec·3 = @"time".d·2 / @"time".Duration(0x3b9aca00); var @"time".nsec·4 @"time".Duration; ; @"time".nsec·4 = @"time".d·2 % @"time".Duration(0x3b9aca00); return float64(@"time".sec·3) + float64(@"time".nsec·4) * float64(7198262071269114660816079141112770740375861891461678802759824945047098083990024106014198994535558872472104883612039846078596891298747423852523262413111296p-541) }
	func (@"time".d·2 @"time".Duration) String () (? string)
	type @"time".Month int
	func (@"time".m·2 @"time".Month) String () (? string) { return @"time".months[@"time".m·2 - @"time".Month(0x1)] }
	type @"time".Weekday int
	func (@"time".d·2 @"time".Weekday) String () (? string) { return @"time".days[@"time".d·2] }
	type @"time".Time struct { @"time".sec int64; @"time".nsec int32; @"time".loc *@"time".Location }
	func (@"time".t·2 @"time".Time "esc:0x12") Add (@"time".d·3 @"time".Duration) (? @"time".Time) { @"time".t·2.@"time".sec += int64(@"time".d·3 / @"time".Duration(0x3b9aca00)); var @"time".nsec·4 int32; ; @"time".nsec·4 = int32(@"time".t·2.@"time".nsec) + int32(@"time".d·3 % @"time".Duration(0x3b9aca00)); if @"time".nsec·4 >= int32(0x3b9aca00) { @"time".t·2.@"time".sec++; @"time".nsec·4 -= int32(0x3b9aca00) } else { if @"time".nsec·4 < int32(0x0) { @"time".t·2.@"time".sec--; @"time".nsec·4 += int32(0x3b9aca00) } }; @"time".t·2.@"time".nsec = @"time".nsec·4; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") AddDate (@"time".years·3 int, @"time".months·4 int, @"time".days·5 int) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") After (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec > @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec > @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") AppendFormat (@"time".b·3 []byte "esc:0x1a", @"time".layout·4 string "esc:0x9") (? []byte)
	func (@"time".t·2 @"time".Time "esc:0x1") Before (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec < @"time".u·3.@"time".sec || @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec < @"time".u·3.@"time".nsec }
	func (@"time".t·4 @"time".Time "esc:0x1") Clock () (@"time".hour·1 int, @"time".min·2 int, @"time".sec·3 int)
	func (@"time".t·4 @"time".Time "esc:0x1") Date () (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int)
	func (@"time".t·2 @"time".Time "esc:0x1") Day () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Equal (@"time".u·3 @"time".Time "esc:0x1") (? bool) { return @"time".t·2.@"time".sec == @"time".u·3.@"time".sec && @"time".t·2.@"time".nsec == @"time".u·3.@"time".nsec }
	func (@"time".t·2 @"time".Time "esc:0x9") Format (@"time".layout·3 string "esc:0x9") (? string)
	func (@"time".t·2 *@"time".Time "esc:0x1") GobDecode (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·3 @"time".Time "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Hour () (? int)
	func (@"time".t·3 @"time".Time "esc:0x1") ISOWeek () (@"time".year·1 int, @"time".week·2 int)
	func (@"time".t·2 @"time".Time "esc:0x12") In (@"time".loc·3 *@"time".Location "esc:0x12") (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") IsZero () (? bool) { return @"time".t·2.@"time".sec == int64(0x0) && @"time".t·2.@"time".nsec == int32(0x0) }
	func (@"time".t·2 @"time".Time "esc:0x12") Local () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".Local; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x12") Location () (? *@"time".Location) { var @"time".l·3 *@"time".Location; ; @"time".l·3 = @"time".t·2.@"time".loc; if @"time".l·3 == nil { @"time".l·3 = @"time".UTC }; return @"time".l·3 }
	func (@"time".t·3 @"time".Time "esc:0x1") MarshalBinary () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"time".t·3 @"time".Time "esc:0x9") MarshalText () (? []byte, ? error)
	func (@"time".t·2 @"time".Time "esc:0x1") Minute () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") Month () (? @"time".Month)
	func (@"time".t·2 @"time".Time "esc:0x1") Nanosecond () (? int) { return int(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 @"time".Time "esc:0x12") Round (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x1") Second () (? int)
	func (@"time".t·2 @"time".Time "esc:0x9") String () (? string)
	func (@"time".t·2 @"time".Time "esc:0x1") Sub (@"time".u·3 @"time".Time "esc:0x1") (? @"time".Duration)
	func (@"time".t·2 @"time".Time "esc:0x12") Truncate (@"time".d·3 @"time".Duration) (? @"time".Time)
	func (@"time".t·2 @"time".Time "esc:0x12") UTC () (? @"time".Time) { @"time".t·2.@"time".loc = @"time".UTC; return @"time".t·2 }
	func (@"time".t·2 @"time".Time "esc:0x1") Unix () (? int64) { return @"time".t·2.@"time".sec + int64(-0xe7791f700) }
	func (@"time".t·2 @"time".Time "esc:0x1") UnixNano () (? int64) { return (@"time".t·2.@"time".sec + int64(-0xe7791f700)) * int64(0x3b9aca00) + int64(@"time".t·2.@"time".nsec) }
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalBinary (@"time".data·3 []byte "esc:0x1") (? error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalJSON (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 *@"time".Time "esc:0x1") UnmarshalText (@"time".data·3 []byte "esc:0x1") (@"time".err·1 error)
	func (@"time".t·2 @"time".Time "esc:0x1") Weekday () (? @"time".Weekday)
	func (@"time".t·2 @"time".Time "esc:0x1") Year () (? int)
	func (@"time".t·2 @"time".Time "esc:0x1") YearDay () (? int)
	func (@"time".t·3 @"time".Time "esc:0x32") Zone () (@"time".name·1 string, @"time".offset·2 int)
	func (@"time".t·2 @"time".Time "esc:0x1") @"time".abs () (? uint64)
	func (@"time".t·5 @"time".Time "esc:0x1") @"time".date (@"time".full·6 bool) (@"time".year·1 int, @"time".month·2 @"time".Month, @"time".day·3 int, @"time".yday·4 int)
	func (@"time".t·4 @"time".Time "esc:0x32") @"time".locabs () (@"time".name·1 string, @"time".offset·2 int, @"time".abs·3 uint64)
	type @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm uint8
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanEncrypt () (? bool)
	func (@"golang.org/x/crypto/openpgp/packet".pka·2 @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm) CanSign () (? bool)
	type @"golang.org/x/crypto/openpgp/packet".parsedMPI struct { @"golang.org/x/crypto/openpgp/packet".bytes []byte; @"golang.org/x/crypto/openpgp/packet".bitLength uint16 }
	import ecdsa "crypto/ecdsa" // indirect
	import elliptic "crypto/elliptic" // indirect
	import big "math/big" // indirect
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".n·3 int32) (? int32)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".n·3 int64) (? int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".n·3 int) (? int)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".n·3 int) (? []int)
	func (@"math/rand".r·3 *@"math/rand".Rand "esc:0x9") Read (@"math/rand".p·4 []byte "esc:0x1") (@"math/rand".n·1 int, @"math/rand".err·2 error)
	func (@"math/rand".r·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seed·2 int64)
	func (@"math/rand".r·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".z·2 @"math/big".nat) @"math/big".add (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".x·3 @"math/big".nat "esc:0x1", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".i·3 uint) (? uint) { var @"math/big".j·4 uint; ; @"math/big".j·4 = @"math/big".i·3 / uint(0x20); if @"math/big".j·4 >= uint(len(@"math/big".x·2)) { return uint(0x0) }; return uint(@"math/big".x·2[@"math/big".j·4] >> (@"math/big".i·3 % uint(0x20)) & @"math/big".Word(0x1)) }
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".z·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".buf·3 []byte "esc:0x1") (@"math/big".i·1 int)
	func (@"math/big".z·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".y·3 @"math/big".nat "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".q·1 @"math/big".nat) @"math/big".convertWords (@"math/big".s·2 []byte "esc:0x1", @"math/big".b·3 @"math/big".Word, @"math/big".ndigits·4 int, @"math/big".bb·5 @"math/big".Word, @"math/big".table·6 []@"math/big".divisor "esc:0x9")
	func (@"math/big".z·3 @"math/big".nat) @"math/big".div (@"math/big".z2·4 @"math/big".nat, @"math/big".u·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".u·4 @"math/big".nat, @"math/big".uIn·5 @"math/big".nat, @"math/big".v·6 @"math/big".nat) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".nat)
	func (@"math/big".z·3 @"math/big".nat) @"math/big".divW (@"math/big".x·4 @"math/big".nat, @"math/big".y·5 @"math/big".Word) (@"math/big".q·1 @"math/big".nat, @"math/big".r·2 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNN (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".expWW (@"math/big".x·3 @"math/big".Word, @"math/big".y·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".itoa (@"math/big".neg·3 bool, @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".n·3 int) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat) @"math/big".modW (@"math/big".d·3 @"math/big".Word) (@"math/big".r·1 @"math/big".Word)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".montgomery (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat "esc:0x1", @"math/big".m·5 @"math/big".nat, @"math/big".k·6 @"math/big".Word, @"math/big".n·7 int) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mul (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".Word, @"math/big".r·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".mulRange (@"math/big".a·3 uint64, @"math/big".b·4 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".n·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".reps·3 int) (? bool)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".rand·3 *@"math/rand".Rand "esc:0x9", @"math/big".limit·4 @"math/big".nat "esc:0x1", @"math/big".n·5 int) (? @"math/big".nat)
	func (@"math/big".z·5 @"math/big".nat) @"math/big".scan (@"math/big".r·6 @"io".ByteScanner, @"math/big".base·7 int, @"math/big".fracOk·8 bool) (@"math/big".res·1 @"math/big".nat, @"math/big".b·2 int, @"math/big".count·3 int, @"math/big".err·4 error)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".x·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".i·4 uint, @"math/big".b·5 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".buf·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".x·3 uint64) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".x·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shl (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".shr (@"math/big".x·3 @"math/big".nat, @"math/big".s·4 uint) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".i·3 uint) (? uint)
	func (@"math/big".z·2 @"math/big".nat) @"math/big".sub (@"math/big".x·3 @"math/big".nat, @"math/big".y·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".x·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".x·2 @"math/big".nat "esc:0x9") @"math/big".utoa (@"math/big".base·3 int) (? []byte)
	func (@"math/big".z·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".x·3 @"math/big".nat "esc:0x9", @"math/big".y·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") And (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Append (@"math/big".buf·3 []byte "esc:0x1a", @"math/big".base·4 int) (? []byte)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".n·3 int64, @"math/big".k·4 int64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".i·3 int) (? uint)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".x·2.@"math/big".abs }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".y·3 *@"math/big".Int "esc:0x1") (@"math/big".r·1 int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".m·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x1", @"math/big".m·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·1 *@"math/big".Int "esc:0x9") Format (@"math/big".s·2 @"fmt".State, @"math/big".ch·3 rune)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9", @"math/big".a·5 *@"math/big".Int "esc:0x9", @"math/big".b·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".buf·3 []byte "esc:0x1") (? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".v·3 int64; ; @"math/big".v·3 = int64(@"math/big".low64(@"math/big".x·2.@"math/big".abs)); if @"math/big".x·2.@"math/big".neg { @"math/big".v·3 = -@"math/big".v·3 }; return @"math/big".v·3 }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".x·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".text·1 []byte, @"math/big".err·2 error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".g·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".a·3 int64, @"math/big".b·4 int64) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".n·3 int) (? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".x·4 *@"math/big".Int "esc:0x9", @"math/big".y·5 *@"math/big".Int "esc:0x9", @"math/big".r·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rnd·3 *@"math/rand".Rand "esc:0x9", @"math/big".n·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".n·4 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".s·3 @"fmt".ScanState, @"math/big".ch·4 rune) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".x·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".i·4 int, @"math/big".b·5 uint) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".abs·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".buf·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".x·3 int64) (? *@"math/big".Int)
	func (@"math/big".z·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".s·4 string, @"math/big".base·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".x·3 uint64) (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".x·2.@"math/big".abs) == int(0x0) { return int(0x0) }; if @"math/big".x·2.@"math/big".neg { return int(-0x1) }; return int(0x1) }
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x9") Text (@"math/big".base·3 int) (? string)
	func (@"math/big".x·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".x·2.@"math/big".abs) }
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".text·3 []byte) (? error)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".y·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".a·3 *@"math/big".Int "esc:0x9", @"math/big".b·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrt3Mod4Prime (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".z·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrtTonelliShanks (@"math/big".x·3 *@"math/big".Int "esc:0x9", @"math/big".p·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".z·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".r·5 @"io".ByteScanner, @"math/big".base·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int; Name string }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Add (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") Double (@"crypto/elliptic".x1·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x9") IsOnCurve (@"crypto/elliptic".x·3 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·4 *@"math/big".Int "esc:0x9") (? bool)
	func (@"crypto/elliptic".curve·2 *@"crypto/elliptic".CurveParams "esc:0x12") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curve·2 }
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarBaseMult (@"crypto/elliptic".k·4 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarMult (@"crypto/elliptic".Bx·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".By·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".k·6 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z1·7 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2·8 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2·9 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z2·10 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curve·3 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".x·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·6 *@"math/big".Int "esc:0x9") (@"crypto/elliptic".xOut·1 *@"math/big".Int, @"crypto/elliptic".yOut·2 *@"math/big".Int)
	func (@"crypto/elliptic".curve·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".x·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"crypto/ecdsa".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"io".Writer interface { Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"golang.org/x/crypto/openpgp/packet".ecdsaKey struct { @"golang.org/x/crypto/openpgp/packet".oid []byte; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x1) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".oid) + int(0x2) + len(@"golang.org/x/crypto/openpgp/packet".f·2.@"golang.org/x/crypto/openpgp/packet".p.@"golang.org/x/crypto/openpgp/packet".bytes) }
	func (@"golang.org/x/crypto/openpgp/packet".f·3 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".newECDSA () (? *@"crypto/ecdsa".PublicKey, ? error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdsaKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".kdfHashFunction uint8
	type @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm uint8
	type @"golang.org/x/crypto/openpgp/packet".ecdhKdf struct { KdfHash @"golang.org/x/crypto/openpgp/packet".kdfHashFunction; KdfAlgo @"golang.org/x/crypto/openpgp/packet".kdfAlgorithm }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".byteLen () (? int) { return int(0x4) }
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".f·2 *@"golang.org/x/crypto/openpgp/packet".ecdhKdf "esc:0x1") @"golang.org/x/crypto/openpgp/packet".serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureType uint8
	type @"crypto".Hash uint
	func (@"crypto".h·2 @"crypto".Hash) Available () (? bool) { return @"crypto".h·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".h·2] != nil }
	func (@"crypto".h·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".h·2 }
	func (@"crypto".h·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".h·2 @"crypto".Hash) Size () (? int)
	type @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType uint8
	type @"golang.org/x/crypto/openpgp/packet".outputSubpacket struct { @"golang.org/x/crypto/openpgp/packet".hashed bool; @"golang.org/x/crypto/openpgp/packet".subpacketType @"golang.org/x/crypto/openpgp/packet".signatureSubpacketType; @"golang.org/x/crypto/openpgp/packet".isCritical bool; @"golang.org/x/crypto/openpgp/packet".contents []byte }
	import cipher "crypto/cipher" // indirect
	type @"crypto/cipher".Block interface { BlockSize() (? int); Decrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte); Encrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte) }
	type @"golang.org/x/crypto/openpgp/packet".CipherFunction uint8
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) KeySize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".blockSize () (? int)
	func (@"golang.org/x/crypto/openpgp/packet".cipher·2 @"golang.org/x/crypto/openpgp/packet".CipherFunction) @"golang.org/x/crypto/openpgp/packet".new (@"golang.org/x/crypto/openpgp/packet".key·3 []byte "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".block·1 @"crypto/cipher".Block)
	type @"golang.org/x/crypto/openpgp/packet".PrivateKey struct { ? @"golang.org/x/crypto/openpgp/packet".PublicKey; Encrypted bool; @"golang.org/x/crypto/openpgp/packet".encryptedData []byte; @"golang.org/x/crypto/openpgp/packet".cipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; @"golang.org/x/crypto/openpgp/packet".s2k func(@"golang.org/x/crypto/openpgp/packet".out []byte, @"golang.org/x/crypto/openpgp/packet".in []byte); PrivateKey interface {}; @"golang.org/x/crypto/openpgp/packet".sha1Checksum bool; @"golang.org/x/crypto/openpgp/packet".iv []byte }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Decrypt (@"golang.org/x/crypto/openpgp/packet".passphrase·3 []byte) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseDSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseElGamalPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parsePrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parseRSAPrivateKey (@"golang.org/x/crypto/openpgp/packet".data·3 []byte) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".CompressionAlgo uint8
	type @"golang.org/x/crypto/openpgp/packet".CompressionConfig struct { Level int }
	type @"golang.org/x/crypto/openpgp/packet".Config struct { Rand @"io".Reader; DefaultHash @"crypto".Hash; DefaultCipher @"golang.org/x/crypto/openpgp/packet".CipherFunction; Time func() (? @"time".Time); DefaultCompressionAlgo @"golang.org/x/crypto/openpgp/packet".CompressionAlgo; CompressionConfig *@"golang.org/x/crypto/openpgp/packet".CompressionConfig; S2KCount int; RSABits int }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Cipher () (? @"golang.org/x/crypto/openpgp/packet".CipherFunction) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint8(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher) == uint8(0x0) { return @"golang.org/x/crypto/openpgp/packet".CipherFunction(0x7) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCipher }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Compression () (? @"golang.org/x/crypto/openpgp/packet".CompressionAlgo) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil { return @"golang.org/x/crypto/openpgp/packet".CompressionAlgo(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultCompressionAlgo }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") Hash () (? @"crypto".Hash) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || uint(@"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash) == uint(0x0) { return @"crypto".Hash(0x5) }; return @"golang.org/x/crypto/openpgp/packet".c·2.DefaultHash }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x32") Now () (? @"time".Time)
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1") PasswordHashIterations () (? int) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount == int(0x0) { return int(0x0) }; return @"golang.org/x/crypto/openpgp/packet".c·2.S2KCount }
	func (@"golang.org/x/crypto/openpgp/packet".c·2 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x22") Random () (? @"io".Reader) { if @"golang.org/x/crypto/openpgp/packet".c·2 == nil || @"golang.org/x/crypto/openpgp/packet".c·2.Rand == nil { return @"crypto/rand".Reader }; return @"golang.org/x/crypto/openpgp/packet".c·2.Rand }
	type @"golang.org/x/crypto/openpgp/packet".Signature struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashSuffix []byte; HashTag [2]byte; CreationTime @"time".Time; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; ECDSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".rawSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket; SigLifetimeSecs *uint32; KeyLifetimeSecs *uint32; PreferredSymmetric []uint8; PreferredHash []uint8; PreferredCompression []uint8; IssuerKeyId *uint64; IsPrimaryId *bool; FlagsValid bool; FlagCertify bool; FlagSign bool; FlagEncryptCommunications bool; FlagEncryptStorage bool; RevocationReason *uint8; RevocationReasonText string; MDC bool; EmbeddedSignature *@"golang.org/x/crypto/openpgp/packet".Signature; @"golang.org/x/crypto/openpgp/packet".outSubpackets []@"golang.org/x/crypto/openpgp/packet".outputSubpacket }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x1") KeyExpired (@"golang.org/x/crypto/openpgp/packet".currentTime·3 @"time".Time "esc:0x1") (? bool) { if @"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs == nil { return bool(false) }; var @"golang.org/x/crypto/openpgp/packet".expiry·4 @"time".Time; ; @"golang.org/x/crypto/openpgp/packet".expiry·4 = @"golang.org/x/crypto/openpgp/packet".sig·2.CreationTime.Add(@"time".Duration(*@"golang.org/x/crypto/openpgp/packet".sig·2.KeyLifetimeSecs) * @"time".Duration(0x3b9aca00)); return @"golang.org/x/crypto/openpgp/packet".currentTime·3.After(@"golang.org/x/crypto/openpgp/packet".expiry·4) }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") Sign (@"golang.org/x/crypto/openpgp/packet".h·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignKey (@"golang.org/x/crypto/openpgp/packet".pub·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".priv·4 *@"golang.org/x/crypto/openpgp/packet".PrivateKey, @"golang.org/x/crypto/openpgp/packet".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") SignUserId (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".priv·5 *@"golang.org/x/crypto/openpgp/packet".PrivateKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildHashSuffix () (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".buildSubpackets () (@"golang.org/x/crypto/openpgp/packet".subpackets·1 []@"golang.org/x/crypto/openpgp/packet".outputSubpacket)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".Signature) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") @"golang.org/x/crypto/openpgp/packet".signPrepareHash (@"golang.org/x/crypto/openpgp/packet".h·4 @"hash".Hash) (@"golang.org/x/crypto/openpgp/packet".digest·1 []byte, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".SignatureV3 struct { SigType @"golang.org/x/crypto/openpgp/packet".SignatureType; CreationTime @"time".Time; IssuerKeyId uint64; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; Hash @"crypto".Hash; HashTag [2]byte; RSASignature @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigR @"golang.org/x/crypto/openpgp/packet".parsedMPI; DSASigS @"golang.org/x/crypto/openpgp/packet".parsedMPI }
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".sig·2 *@"golang.org/x/crypto/openpgp/packet".SignatureV3) @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"golang.org/x/crypto/openpgp/packet".PublicKey struct { CreationTime @"time".Time; PubKeyAlgo @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm; PublicKey interface {}; Fingerprint [20]byte; KeyId uint64; IsSubkey bool; @"golang.org/x/crypto/openpgp/packet".n @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".e @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".p @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".q @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".g @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".y @"golang.org/x/crypto/openpgp/packet".parsedMPI; @"golang.org/x/crypto/openpgp/packet".ec *@"golang.org/x/crypto/openpgp/packet".ecdsaKey; @"golang.org/x/crypto/openpgp/packet".ecdh *@"golang.org/x/crypto/openpgp/packet".ecdhKdf }
	func (@"golang.org/x/crypto/openpgp/packet".pk·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") BitLength () (@"golang.org/x/crypto/openpgp/packet".bitLength·1 uint16, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") CanSign () (? bool) { return @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x2) && @"golang.org/x/crypto/openpgp/packet".pk·2.PubKeyAlgo != @"golang.org/x/crypto/openpgp/packet".PublicKeyAlgorithm(0x10) }
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdShortString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) KeyIdString () (? string)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") SerializeSignaturePrefix (@"golang.org/x/crypto/openpgp/packet".h·2 @"io".Writer)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyKeySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (? error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey) VerifyRevocationSignature (@"golang.org/x/crypto/openpgp/packet".sig·3 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignature (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifySignatureV3 (@"golang.org/x/crypto/openpgp/packet".signed·3 @"hash".Hash, @"golang.org/x/crypto/openpgp/packet".sig·4 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignature (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9", @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".Signature "esc:0x9") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") VerifyUserIdSignatureV3 (@"golang.org/x/crypto/openpgp/packet".id·3 string "esc:0x1", @"golang.org/x/crypto/openpgp/packet".pub·4 *@"golang.org/x/crypto/openpgp/packet".PublicKey, @"golang.org/x/crypto/openpgp/packet".sig·5 *@"golang.org/x/crypto/openpgp/packet".SignatureV3 "esc:0x1") (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseDSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseElGamal (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parseRSA (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·2 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".serializeWithoutHeaders (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	func (@"golang.org/x/crypto/openpgp/packet".pk·1 *@"golang.org/x/crypto/openpgp/packet".PublicKey "esc:0x9") @"golang.org/x/crypto/openpgp/packet".setFingerPrintAndKeyId ()
	type @"golang.org/x/crypto/openpgp/packet".UserId struct { Id string; Name string; Comment string; Email string }
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x1") Serialize (@"golang.org/x/crypto/openpgp/packet".w·3 @"io".Writer) (? error)
	func (@"golang.org/x/crypto/openpgp/packet".uid·2 *@"golang.org/x/crypto/openpgp/packet".UserId "esc:0x9") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"".Identity struct { Name string; UserId *@"golang.org/x/crypto/openpgp/packet".UserId; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature; Signatures []*@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Subkey struct { PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Sig *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Key struct { Entity *@"".Entity; PublicKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; SelfSignature *@"golang.org/x/crypto/openpgp/packet".Signature }
	type @"".Entity struct { PrimaryKey *@"golang.org/x/crypto/openpgp/packet".PublicKey; PrivateKey *@"golang.org/x/crypto/openpgp/packet".PrivateKey; Identities map[string]*@"".Identity; Revocations []*@"golang.org/x/crypto/openpgp/packet".Signature; Subkeys []@"".Subkey }
	func (@"".e·2 *@"".Entity "esc:0x9") Serialize (@"".w·3 @"io".Writer) (? error)
	func (@"".e·2 *@"".Entity "esc:0x9") SerializePrivate (@"".w·3 @"io".Writer, @"".config·4 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func (@"".e·2 *@"".Entity "esc:0x9") SignIdentity (@"".identity·3 string "esc:0x1", @"".signer·4 *@"".Entity, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".encryptionKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	func (@"".e·2 *@"".Entity "esc:0x32") @"".primaryIdentity () (? *@"".Identity)
	func (@"".e·3 *@"".Entity "esc:0x12") @"".signingKey (@"".now·4 @"time".Time "esc:0x1") (? @"".Key, ? bool)
	type @"".KeyRing interface { DecryptionKeys() (? []@"".Key); KeysById(@"".id uint64) (? []@"".Key); KeysByIdUsage(@"".id uint64, @"".requiredUsage byte) (? []@"".Key) }
	type @"".EntityList []*@"".Entity
	func (@"".el·2 @"".EntityList "esc:0x9") DecryptionKeys () (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysById (@"".id·3 uint64) (@"".keys·1 []@"".Key)
	func (@"".el·2 @"".EntityList "esc:0x9") KeysByIdUsage (@"".id·3 uint64, @"".requiredUsage·4 byte) (@"".keys·1 []@"".Key)
	func @"".ReadArmoredKeyRing (@"".r·3 @"io".Reader) (? @"".EntityList, ? error)
	func @"".ReadKeyRing (@"".r·3 @"io".Reader) (@"".el·1 @"".EntityList, @"".err·2 error)
	type @"golang.org/x/crypto/openpgp/packet".Packet interface { @"golang.org/x/crypto/openpgp/packet".parse(? @"io".Reader) (? error) }
	type @"golang.org/x/crypto/openpgp/packet".Reader struct { @"golang.org/x/crypto/openpgp/packet".q []@"golang.org/x/crypto/openpgp/packet".Packet; @"golang.org/x/crypto/openpgp/packet".readers []@"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".r·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x3a") Next () (@"golang.org/x/crypto/openpgp/packet".p·1 @"golang.org/x/crypto/openpgp/packet".Packet, @"golang.org/x/crypto/openpgp/packet".err·2 error)
	func (@"golang.org/x/crypto/openpgp/packet".r·2 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Push (@"golang.org/x/crypto/openpgp/packet".reader·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error) { if len(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers) >= int(0x20) { return @"golang.org/x/crypto/openpgp/errors".StructuralError(@"golang.org/x/crypto/openpgp/errors".StructuralError("too many layers of packets")) }; @"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers = append(@"golang.org/x/crypto/openpgp/packet".r·2.@"golang.org/x/crypto/openpgp/packet".readers, @"golang.org/x/crypto/openpgp/packet".reader·3); return nil }
	func (@"golang.org/x/crypto/openpgp/packet".r·1 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") Unread (@"golang.org/x/crypto/openpgp/packet".p·2 @"golang.org/x/crypto/openpgp/packet".Packet) { @"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q = append(@"golang.org/x/crypto/openpgp/packet".r·1.@"golang.org/x/crypto/openpgp/packet".q, @"golang.org/x/crypto/openpgp/packet".p·2) }
	func @"".ReadEntity (@"".packets·3 *@"golang.org/x/crypto/openpgp/packet".Reader "esc:0x9") (? *@"".Entity, ? error)
	func @"".NewEntity (@"".name·3 string, @"".comment·4 string, @"".email·5 string, @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config) (? *@"".Entity, ? error)
	var @"".SignatureType string
	type @"golang.org/x/crypto/openpgp/packet".LiteralData struct { IsBinary bool; FileName string; Time uint32; Body @"io".Reader }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") ForEyesOnly () (? bool) { return @"golang.org/x/crypto/openpgp/packet".l·2.FileName == string("_CONSOLE") }
	func (@"golang.org/x/crypto/openpgp/packet".l·2 *@"golang.org/x/crypto/openpgp/packet".LiteralData "esc:0x1") @"golang.org/x/crypto/openpgp/packet".parse (@"golang.org/x/crypto/openpgp/packet".r·3 @"io".Reader) (@"golang.org/x/crypto/openpgp/packet".err·1 error)
	type @"io".ReadCloser interface { Close() (? error); Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"".MessageDetails struct { IsEncrypted bool; EncryptedToKeyIds []uint64; IsSymmetricallyEncrypted bool; DecryptedWith @"".Key; IsSigned bool; SignedByKeyId uint64; SignedBy *@"".Key; LiteralData *@"golang.org/x/crypto/openpgp/packet".LiteralData; UnverifiedBody @"io".Reader; SignatureError error; Signature *@"golang.org/x/crypto/openpgp/packet".Signature; @"".decrypted @"io".ReadCloser }
	type @"".PromptFunction func(@"".keys []@"".Key, @"".symmetric bool) (? []byte, ? error)
	func @"".ReadMessage (@"".r·3 @"io".Reader, @"".keyring·4 @"".KeyRing, @"".prompt·5 @"".PromptFunction "esc:0x10a", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".md·1 *@"".MessageDetails, @"".err·2 error)
	func @"".CheckDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".CheckArmoredDetachedSignature (@"".keyring·3 @"".KeyRing, @"".signed·4 @"io".Reader, @"".signature·5 @"io".Reader) (@"".signer·1 *@"".Entity, @"".err·2 error)
	func @"".DetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSign (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".err·1 error)
	func @"".DetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	func @"".ArmoredDetachSignText (@"".w·2 @"io".Writer, @"".signer·3 *@"".Entity "esc:0x9", @"".message·4 @"io".Reader, @"".config·5 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (? error)
	type @"".FileHints struct { IsBinary bool; FileName string; ModTime @"time".Time }
	type @"io".WriteCloser interface { Close() (? error); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".SymmetricallyEncrypt (@"".ciphertext·3 @"io".Writer, @"".passphrase·4 []byte "esc:0x9", @"".hints·5 *@"".FileHints "esc:0x1", @"".config·6 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x9") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".Encrypt (@"".ciphertext·3 @"io".Writer, @"".to·4 []*@"".Entity "esc:0x9", @"".signed·5 *@"".Entity "esc:0x12", @"".hints·6 *@"".FileHints "esc:0x1", @"".config·7 *@"golang.org/x/crypto/openpgp/packet".Config "esc:0x1a") (@"".plaintext·1 @"io".WriteCloser, @"".err·2 error)
	func @"".init ()
	type @"".canonicalTextHash struct { @"".h @"hash".Hash; @"".s int }
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") BlockSize () (? int)
	func (@"".cth·1 *@"".canonicalTextHash "esc:0x9") Reset ()
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Size () (? int)
	func (@"".cth·2 *@"".canonicalTextHash "esc:0x9") Sum (@"".in·3 []byte) (? []byte)
	func (@"".cth·3 *@"".canonicalTextHash "esc:0x9") Write (@"".buf·4 []byte) (? int, ? error)
	var @"time".months [12]string
	var @"time".days [7]string
	var @"time".Local *@"time".Location
	var @"time".UTC *@"time".Location
	func @"math/big".low64 (@"math/big".z·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".z·2) == int(0x0) { return uint64(0x0) }; var @"math/big".v·3 uint64; ; @"math/big".v·3 = uint64(@"math/big".z·2[int(0x0)]); if true && len(@"math/big".z·2) > int(0x1) { @"math/big".v·3 |= uint64(@"math/big".z·2[int(0x1)]) << uint(0x20) }; return @"math/big".v·3 }
	var @"crypto".hashes []func() (? @"hash".Hash)
	import rand "crypto/rand" // indirect
	var @"crypto/rand".Reader @"io".Reader
	type @"golang.org/x/crypto/openpgp/errors".StructuralError string
	func (@"golang.org/x/crypto/openpgp/errors".s·2 @"golang.org/x/crypto/openpgp/errors".StructuralError "esc:0x1") Error () (? string) { return string("openpgp: invalid data: ") + string(@"golang.org/x/crypto/openpgp/errors".s·2) }

$$
_go_.o          0           0     0     644     252119    `
go object netbsd 386 go1.6.2 X:none

!
  go13ldhash.acrypto/rsa.aio.atime.aFgolang.org/x/crypto/openpgp/armor.aHgolang.org/x/crypto/openpgp/errors.aHgolang.org/x/crypto/openpgp/packet.acrypto.acrypto/sha256.astrconv.aBgolang.org/x/crypto/openpgp/s2k.a ."".NewCanonicalTextHash    e    ;a   1ۉ\$ \$$$        L$L$l$)l$=     uJi1AL$    19t\$\$$D$ $    D$    D$        D$΍q4$l$    L$    S      @  2type."".canonicalTextHash   J  "runtime.newobject   z  (runtime.writeBarrier     Ngo.itab.*"".canonicalTextHash.hash.Hash     4type.*"".canonicalTextHash     type.hash.Hash     Ngo.itab.*"".canonicalTextHash.hash.Hash      runtime.typ2Itab     .runtime.writebarrierptr     0runtime.morestack_noctxt    (  "".autotmp_0002 4type.*"".canonicalTextHash "".autotmp_0001  4type.*"".canonicalTextHash "".~r1 type.hash.Hash "".h  type.hash.Hash (X'(7' GU "*U  $_- Tgclocals·aefd16b155593f6f07980a05b297ad1f Tgclocals·0c8aa8e80191a30eac23f1a218103f16   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go/usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go:"".(*canonicalTextHash).Write    e    ;a  Lt$P1ۉ\$d\$h1ҋL$TD$X\$\\$H1D$DD$ L$@L$(l$ 9}@\$(+|$$|$n k        F\$(C\$(Gl$ 9|ЋL$XT$\9we))L$T tl$8׉ʃ tCnT$4T$\$8\$|$<|$l$0,$L$,Y$Ӌ\$X\$`1ۉ\$d\$hLÉ    
kЋL$T$\9   9   ))L$T tl$8׉ʃ tnT$4T$\$8\$|$<|$l$0,$L$,Y$Ӌ\$P tEk    \$    \$    \$l$0,$L$,Y$Ӌ|$$t$PT$B뷉z    1F                   $runtime.panicslice            "".newline    "".newline    "".newline            $runtime.panicslice     0runtime.morestack_noctxt   8  "".autotmp_0012 Gtype.*uint8 "".autotmp_0011 Wtype.int "".autotmp_0010 Otype.int "".autotmp_0009  type.int "".autotmp_0008  type.[]uint8 "".autotmp_0007 /type.[]uint8 "".autotmp_0006 type.[]uint8 "".i _type.int "".~r2 (type.error "".~r1  type.int "".buf type.[]uint8 "".cth  4type.*"".canonicalTextHash "  Z.!;		Y	eD	  [2 Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f Tgclocals·fdec177485cbfa40ac91f85390ec1fea   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*canonicalTextHash).Sum    e    ;avg$1ۉ\$8\$<\$@\$( tIk\$,\$\$0\$\$4\$l$ ,$L$Y ӋT$L$D$T$8L$<D$@$É                   0runtime.morestack_noctxt   8H  "".~r1  type.[]uint8 
"".in type.[]uint8 "".cth  4type.*"".canonicalTextHash H_GHG  ZV 
 Q/ Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go:"".(*canonicalTextHash).Reset    e    ;av2\$ t"kl$,$L$Y1\$CÉ          V       ~  0runtime.morestack_noctxt     "".cth  4type.*"".canonicalTextHash * P b	 
 +% Tgclocals·87d20ce1b58390b294df80b886db78bf Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*canonicalTextHash).Size    e    ;av1\$ t!kl$,$L$YӋ\$\$É          V       |  0runtime.morestack_noctxt      "".~r0 type.int "".cth  4type.*"".canonicalTextHash  )  P l. 
 +% Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.goB"".(*canonicalTextHash).BlockSize    e    ;av1\$ t!kl$,$L$YӋ\$\$É          V       |  0runtime.morestack_noctxt      "".~r0 type.int "".cth  4type.*"".canonicalTextHash  )  P t. 
 +% Tgclocals·3f5c1f818fa7055d0400cecd34057162 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go8"".(*Entity).primaryIdentity    e    ;a   @D$    \$Dk|$1    $    l$\$\$    D$19t[\$\$ tX\$19uD$h   19th    tD$H@Í\$$    D$19u\$\$H@É    <      R  runtime.duffzero   `  8type.map[string]*"".Identity     &runtime.mapiterinit     &runtime.mapiternext     0runtime.morestack_noctxt     "".autotmp_0037 _Btype.map.iter[string]*"".Identity  "".firstIdentity g"type.*"".Identity "".~r0 "type.*"".Identity "".e  type.*"".Entity &!  4C
 	  @ Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa Tgclocals·c00bf85eed6a8e40863dfe64526ae817   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go4"".(*Entity).encryptionKey  &  &e    $;A	  l  1ۉ$  $  $  $  D$1ۉ$  $   $$  $(  $p   ,	  KCk l$xD$$    D$tD$ L$pL$T\$$l$ 9  \$T   SC\$$\$L$dL$XT$hT$\D$lD$`            i$    \$ w  D$`$t  $L  $x  $P  $|  $T  $  $X     19  1    $  $   $$  $  $(  $  $   $    ?   6   -        \$`   {sk $   k$$   $  $   $$  $   $(  $   $   |$8$   $   T$@$   L$D;t$D2|
\$8;\$@w&9~  9v  $   $   9`        \$T\$T\$$C\$$\$$l$ 9\$t]$p  l$s9sDskNv1ۋ$p  $  $  $  $  Ƅ$  l      $p  $    \$\$P\$Pk       \$Pk       $p  +]$    \$    \$PC$t  $\  $x  $`  $|  $d  $  $h     19   1 uN1ۋ$p  $p  $p  K\$Pk$  $  $  $  Ƅ$  l  1҉$  $  $  $  Ƅ$   l  1ۉ$<  $@  $D  $H  h$   xh $   h$$      E 1Ҿ ʚ;1ۉ	  щ1ۉ$   $   $   $   $   D$8$   |$<T$($L$,L$D$ ʚ;D$        \$L$D$8T$<ʉ$   $   D$($D$,D$D$ ʚ;D$        $   D$T$ ʚ;1ۉ	  ÉыD$(T$,)ʉ$   ف ʚ;   $    $    ʚ;$   $   $<  $@  ϋ$\  $`  $d  $  $h  $<  $@  t$@l$DT$HL$L\$D;\$L|
\$@;\$Hw9u9u$  9~
   1 ^$    $    ʚ;?։Չ։Չ\$\$\$` t-k$  k$   k $$  k$$(  111ۉ$,  $0  $4  $8  h$   xh $   h$$      E 1Ҿ ʚ;1ۉ	1  щ1ۉ\$|$   $   $   $   D$H$   |$LT$0$L$4L$D$ ʚ;D$        \$L$D$HT$Lʉ$   $   D$0$D$4D$D$ ʚ;D$        $   D$T$ ʚ;1ۉ	[  ÉыD$0T$4)ʉ$   ف ʚ;
  $    $    ʚ;$   $   l$|$,  $   $0  $   ω$   $L  $P  $T  $   $X  $   $,  $0  $4  $   $8  $   $   t$8$   $   T$@$   L$D;l$D&|
\$8;\$@w9u 9u$   $   9~
   (1! $    $    ʚ;։Չ։Չ    R        golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt     $runtime.panicindex     8"".(*Entity).primaryIdentity     golang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanEncrypt      runtime.int64div      runtime.int64div      runtime.int64div      runtime.int64div   &  0runtime.morestack_noctxt   P  `"".autotmp_0068  type."".Key "".autotmp_0067  type."".Key "".autotmp_0066  type.bool "".autotmp_0065  type.bool "".autotmp_0064  $type.time.Duration "".autotmp_0061  type.bool "".autotmp_0058  $type.time.Duration "".autotmp_0057 type."".Subkey "".autotmp_0056 type.*"".Subkey "".autotmp_0055 type.int "".autotmp_0054 type.int "".autotmp_0053  type.int32 "".autotmp_0052  type.int64 "".autotmp_0051  type.int32 "".autotmp_0050  type.int64 "".autotmp_0049  type.int64 "".autotmp_0048  type.bool "".autotmp_0047  type.int32 "".autotmp_0046  type.int64 "".autotmp_0045  type.int32 "".autotmp_0044  type.int64 "".autotmp_0043 type.int64 "".autotmp_0041  type.[]"".Subkey time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 _type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time time.t·2 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 ?type.time.Time "".i "type.*"".Identity "".subkey type."".Subkey "".i type.int "".maxTime type.time.Time $"".candidateSubkey type.int "".~r2 Htype.bool "".~r1 (type."".Key "".now type.time.Time "".e  type.*"".Entity <,
  ;v
$	N	$	"4._N-	!1R	 $ \ Tgclocals·7cfe9a03a21b8328cb9dc32a81e0154a Tgclocals·c59090a4d81cba64f6379027f4c17576   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go."".(*Entity).signingKey    e    $T;A  ,  1ۉ$D  $H  $L  $P  D$$0     KCk l$xD$$    D$tD$ L$pL$T\$$l$ 9   \$T B  SC\$$\$L$dL$XT$hT$\D$lD$`    P      @  i$    \$ $  D$`$4  $  $8  $  $<  $  $@  $     19  1   \$\$\$t]$0  l$s9sDskNv1ۋ$0  $D  $H  $L  $P  Ƅ$T  ,      $0  $    \$\$P\$Pk    tm\$Pk       \$PC$4  $  $8  $   $<  $$  $@  $(     19   1 uN1ۋ$0  $0  $0  K\$Pk$D  $H  $L  $P  Ƅ$T  ,  1҉$D  $H  $L  $P  Ƅ$T   ,  1ۉ$   $   $  $  h$   xh $   h$$      E 1Ҿ ʚ;1ۉ	  щ1ۉ$   $   $   $   $   D$8$   |$<T$0$L$4L$D$ ʚ;D$        \$L$D$8T$<ʉ$   $   D$0$D$4D$D$ ʚ;D$        $   D$T$ ʚ;1ۉ	  ÉыD$0T$4)ʉ$   ف ʚ;   $    $    ʚ;$   $   $   $   ϋ$  $   $$  $   $(  $   $   t$@l$DT$HL$L\$D;\$L|
\$@;\$Hw9u9u$   9~
   1 ^$    $    ʚ;?։Չ։Չ\$T\$T\$$C\$$B1ۉ$   $   $   $   h$   xh $   h$$      E 1Ҿ ʚ;1ۉ	1  щ1ۉ\$|$   $   $   $   D$H$   |$LT$($L$,L$D$ ʚ;D$        \$L$D$HT$Lʉ$   $   D$($D$,D$D$ ʚ;D$        $   D$T$ ʚ;1ۉ	[  ÉыD$(T$,)ʉ$   ف ʚ;
  $    $    ʚ;$   $   l$|$   $   $   $   ω$   $  $  $  $   $  $   $   $   $   $   $   $   $   t$8$   $   T$@$   L$D;l$D&|
\$8;\$@w9u 9u$   $   9~
   1 $    $    ʚ;։Չ։Չn            zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign     $runtime.panicindex     8"".(*Entity).primaryIdentity      runtime.int64div      runtime.int64div      runtime.int64div      runtime.int64div     0runtime.morestack_noctxt   P  T"".autotmp_0154  type."".Key "".autotmp_0153  type."".Key "".autotmp_0152  type.bool "".autotmp_0151  type.bool "".autotmp_0150  $type.time.Duration "".autotmp_0146  $type.time.Duration "".autotmp_0145 type."".Subkey "".autotmp_0144 type.*"".Subkey "".autotmp_0143 type.int "".autotmp_0142 type.int "".autotmp_0141  type.int32 "".autotmp_0140  type.int64 "".autotmp_0139  type.int32 "".autotmp_0138  type.int64 "".autotmp_0137  type.int64 "".autotmp_0136  type.int32 "".autotmp_0135  type.int64 "".autotmp_0134  type.int32 "".autotmp_0133  type.int64 "".autotmp_0132 type.int64 "".autotmp_0130  type.[]"".Subkey time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 _type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 type.time.Time time.u·3 type.time.Time time.t·2 type.time.Time "".~r0 type.time.Time time.d·3 $type.time.Duration time.t·2 type.time.Time Xgolang.org/x/crypto/openpgp/packet.expiry·4 type.time.Time bgolang.org/x/crypto/openpgp/packet.currentTime·3 ?type.time.Time "".i "type.*"".Identity "".subkey type."".Subkey "".i type.int $"".candidateSubkey type.int "".~r2 Htype.bool "".~r1 (type."".Key "".now type.time.Time "".e  type.*"".Entity <,
  Z;v$`
	"4N-%    Tgclocals·4db28316a1e41bcee736a1197adee0e9 Tgclocals·b46620cb71e89e703cda8f39022e9a1c   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".EntityList.KeysById    e    D$;A     11ۉ$   $   $   $   $   $   \$lD$,    D$hD$(L$dL$<\$,l$(9  \$<+l$4\$4+U0E4;$   3  ;$   &  D$0    \$4k$   1    $    l$$   \$    T$4L$0$   19tN$   $      19  hl$0$   $    T$4L$0$   19u1ۉ$   $   $   $   $   *$   j$   $   $   $   $   C9  $   ˉk덬$   \$l$    ,$    \$4 v  sCk l$`1D$\D$ t$Xl$ 9   t$8 ;  Vn|$$L$LT$PT$Dl$Tl$HL$@i0A4;$      ;$   u{1ۉ\$p\$t\$x\$|\$4\$pL$t\$D\$x\$H\$|$   $   $   C9wl$   ˉkl$p\$l$    ,$    |$$t$8Gl$ 9(\$<\$<\$,C\$,\$,l$(9z   $    L$D$T$\$    L$\$T$C$   $   $   V$    L$D$T$\$    L$\$T$C$   $   $   h   19oh    ZHv:    &        runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     &runtime.mapiternext     type."".Key     (runtime.typedmemmove   
  type."".Key   
  (runtime.typedmemmove     type.[]"".Key     "runtime.growslice     type.[]"".Key     "runtime.growslice     0runtime.morestack_noctxt   @  $"".autotmp_0222 type."".Key "".autotmp_0221 type."".Subkey "".autotmp_0220 type.*"".Subkey "".autotmp_0219 type.int "".autotmp_0218 type.int "".autotmp_0217 type."".Key "".autotmp_0214  type.**"".Entity "".autotmp_0213 type.int "".autotmp_0212 type.int "".autotmp_0211  type.[]"".Subkey "".autotmp_0210 _Btype.map.iter[string]*"".Identity "".autotmp_0208 $type."".EntityList "".subKey type."".Subkey "".selfSig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".e type.*"".Entity "".keys (type.[]"".Key 
"".id type.uint64 
"".el  $type."".EntityList "  b3K&^
$a {$(EE	(	   _Su Tgclocals·75e979049760da58a03960363c73f8d8 Tgclocals·7f7e31e410d386547ddc0047dc2faa98   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go6"".EntityList.KeysByIdUsage    e    ;a  d11ۉ$   $   $   \$h$\$l\$\$p\$D$tD$D$xD$    L$|T$D$l$T$8D$<l$@l$41D$0D$ T$,l$ 9}\T$( {  *l$Tjl$Xzjt$$\$T\$D\$X\$H|$\|$Ll$`l$P\$Dk ~Fl$ 9|dË\$P   19ul$P    to tj1l$P    tÃ؋l$P    tÃ؋l$P    tÃ؋l$P    tÃ؉!8a$   $   $   C9w;$   ˉkl$D\$l$    ,$    t$$T$(L$|
$    L$D$T$\$    L$\$T$C$   $   $   늉~            ,"".EntityList.KeysById     type."".Key     (runtime.typedmemmove     type.[]"".Key     "runtime.growslice     0runtime.morestack_noctxt   H  "".autotmp_0251 type."".Key "".autotmp_0250 wtype.*"".Key "".autotmp_0249 type.int "".autotmp_0248 type.int "".autotmp_0247  type.uint8 "".autotmp_0246  type.uint8 "".autotmp_0245  type.uint8 "".autotmp_0242 otype.[]"".Key "".autotmp_0241 Wtype.[]"".Key "".key ?type."".Key "".keys 0type.[]"".Key  "".requiredUsage (type.uint8 
"".id type.uint64 
"".el  $type."".EntityList "  ^,<1
R78B7  S.D Tgclocals·182a0b7256216f75ea61640d3418698d Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go8"".EntityList.DecryptionKeys    e    ;a  |11ۉ$   $   $   $   $   $   \$hD$,    D$dD$(L$`L$8\$,l$(9   \$8+l$0\$0 y  sCk l$\1D$XD$ t$Tl$ 9}at$4 B  NF|$$T$HT$<L$LʉD$P19t$    tL    u@    u4Gl$ 9|\$8\$8\$,C\$,\$,l$(9A|1ۉ\$l\$p\$t\$x\$0\$l\$<\$pT$@T$tD$DD$x$   $   $   C9w6$   ˉkl$l\$l$    ,$    |$$t$4H$    L$D$T$\$    L$\$T$C$   $   $   돉            type."".Key     (runtime.typedmemmove     type.[]"".Key     "runtime.growslice     0runtime.morestack_noctxt   0  "".autotmp_0268 type."".Key "".autotmp_0267 gtype."".Subkey "".autotmp_0266 type.*"".Subkey "".autotmp_0265 type.int "".autotmp_0264 type.int "".autotmp_0262  type.**"".Entity "".autotmp_0261 type.int "".autotmp_0260 type.int "".autotmp_0259 O type.[]"".Subkey "".autotmp_0258 7$type."".EntityList "".subKey type."".Subkey "".e type.*"".Entity "".keys type.[]"".Key 
"".el  $type."".EntityList "  4,K[*$B  )E Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 Tgclocals·1bcec613e24368dd337b6dd546e388e5   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go*"".ReadArmoredKeyRing    e    ;a  81ۉ\$D\$H\$L1ۉ\$P\$T\$<$\$@\$    |$|$T$t$t$$    9   T$ $t$-    l$-    l$    |$t$$T$ \$ t_    \$0D$4   1ۉ\$D\$H\$L$    D$    D$    \$0\$D$        \$\$P\$\$T8ÉT$  t1ۉ\$D\$H\$LT$Pt$T8Ã   7W    9   t$(4$T$,T$-    l$-    l$    |$\$ tL tA$HL$    t$l$T$L$D$t$Dl$HT$LL$PD$T8É뻃    7t$(WT$,    9u24$T$-    l$-    l$    |$\$ b$        \$D$+    tt|$NO    \$\$0\$\$41ۉ\$D\$H\$L$    D$    D$    \$0\$D$        \$\$P\$\$T8É눉v    F6      v  Pgolang.org/x/crypto/openpgp/armor.Decode     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     Bgo.string."no armored data found"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     "".PublicKeyType      "".PublicKeyType     "".PublicKeyType      runtime.eqstring     "".ReadKeyRing    """.PrivateKeyType     """.PrivateKeyType    """.PrivateKeyType      runtime.eqstring     ngo.string."expected public or private key block, got: "     *runtime.concatstring2   	  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   	  type.error   	  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   
  runtime.convT2I   
  0runtime.morestack_noctxt   8p  "".autotmp_0282  type.string "".autotmp_0281 type.string "".autotmp_0278  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0277 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".err /type.error "".block 7Ztype.*golang.org/x/crypto/openpgp/armor.Block "".~r2 (type.error "".~r1 $type."".EntityList "".r  type.io.Reader 4pop"opopopo  6+(H_	RLR & :Fa{*pEJ; Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 Tgclocals·07c886799a88ac80d684b8bca7c92573   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".ReadKeyRing    e    ;a  `111ۉ\$x\$|1ۉ\$l\$p\$t\$d\$,\$h\$01D$HD$LD$PD$TD$XD$\D$HD$(1(hh$        D$ H  D$@   D$D   D$<l$,(l$0=       h\$(Cl$@kl$Dk\$(\$ 1ۉ\$4\$8\$ $    \$\$$D$L$L$|D$x 0  $    D$L$D$        T$xL$|\$    T$4L$8\$ $    D$t$t$|    9u`D$x$t$-    l$-    l$    D$x\$ t.1D$xD$|\$p u u\$4\$x\$8\$|`D$x 
1ۉ\$l\$p\$t$    T$L$D$        t$|D$x\$ GD$4t$8\$ $    D$t$t$|"L$lD$pT$tC9w2\$pˉkl$$=     u+o$l$    ^$    L$D$T$\$    L$D$T$C\$pT$tL$l뙍p4$l$    D$<     #*        "type.[1]io.Reader     "runtime.newobject     (runtime.writeBarrier     "".ReadEntity     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     $runtime.assertI2T2     ,"".readToNextPublicKey     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     $runtime.assertI2T2     ,"".readToNextPublicKey   	  (runtime.writeBarrier   	  .runtime.writebarrierptr   	  $type."".EntityList   
  "runtime.growslice   
  .runtime.writebarrierptr     0runtime.morestack_noctxt   8  "".autotmp_0297 G type.[]io.Reader "".autotmp_0296 /\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0295 o^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0294  ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 gtype.io.Reader "".e wtype.*"".Entity ."".lastUnsupportedError Wtype.error "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".err (type.error 
"".el $type."".EntityList "".r  type.io.Reader "  r/
 2<
#2/'('(91 ( rn=*:r," Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad Tgclocals·db08f305c468200e3cf791eda6a8ebaa   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".readToNextPublicKey    e    ;a  <11ۉ\$D\$H1ۉ\$4\$8\$@$    \$\$4|$|$8T$t$t$H    9u>T$D$t$-    l$-    l$    |$8t$HT$D\$ t<ÉT$D t9$    T$t$D$        \$ t1ۉ\$D\$HR<Ë\$419t[    9       $Y8 D$@\$4\$,|$0ÉD$$hHE9w7kӉkl$,+l$0=     uk<Ís4$l$    $    T$D$L$l$    T$D$L$\$$ t:ŉD$ EkKT$(=     uz$T$    T$(D$ a11           b  bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     $runtime.assertI2T2     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     (runtime.writeBarrier     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     0runtime.morestack_noctxt   x  
Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 /^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err type.error "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader ,xwxAwxwxw
  L
(D	&
	7Go	
  0J?B) Tgclocals·725f69b7ae8520ac59af51db7db265d1 Tgclocals·51562c45243a0c5ce48841e15ba48784   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".ReadEntity  F  Fe    D$;A{     1ۉ$   $   $        \$\$P$    D$    D$    D$    D$        D$\$P   =       C$   $    |$Pt$T$$   D$L$$   $    t Ǆ$       $   $      É$   19t[    9a  D$# J  =       |$#   19t[    9  D$#   =       G|$# 6  $   t$lT$p\$<CKE9   kӉkl$l+l$p=     uqk    $   Ǆ$   )   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      Ís4$l$    $    T$D$L$l$    T$D$L$\$< t:ŉD$(EkKT$X=     u$T$    T$XD$(o G  =     %  //]$    \$ un    $   Ǆ$   )   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      D$T    1ۉ$   $   $   $   $    \$$   \$$   T$t$$       9  $   $t$-    l$-    l$    $   $   \$ W  \$P[19t un    $   Ǆ$      Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      Ë$   $   $   $   1ɉ$   D$,$   Ћl$,9   D$\ L$0\$P+,$D$DD$    D$\$$   $       \$PSCKE9wckӉkl$D=     u<+D$\L$0Al$,9z\$P$   1ۉ$   $      É$l$    $    T$D$L$l$    T$D$L$\$P t>ŉD$$EkKT$X=     uSMs4$T$    T$XD$$1뾻    $   Ǆ$   ,   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      É$    t Ǆ$       $   $      Ë$   $   $   $$   D$    $   $   D$=7/  =8B  19t[    9  ѻ    Y  i81ە8ؕ   $   $   \$d$   \$hÉD$8hHE9w;kӉkl$d+l$h=     uks4$l$    $    T$D$L$l$    T$D$L$\$8 t:ŉD$(EkKT$X=     uv$T$    T$XD$(]\$P$$   \$L$|$ tHL$    D$L$$   $    OǄ$       $   $      É    =7v  19t[    9n  й    N  h81ە8ؕ   $   $   \$t$   \$xÉD$@hHE9w;kӉkl$t+l$x=     uks4$l$    $    T$D$L$l$    T$D$L$\$@ t:ŉD$$EkKT$X=     uv$T$    T$XD$$]\$P$$   \$D$D$        D$L$$   $    Ǆ$       $   $      Ét$|$   1111=Y  19t[    9  ׹      |$L/    $   $   $   C9w1$   ˉk=     u;$|$    $    L$D$T$\$    |$LL$D$T$C$   $   $   /\$T19un    $   Ǆ$   ,   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      Ë\$TSCKE9w-kӉk=     u;$|$    $    T$D$L$l$    |$LT$D$L$\$T t?ŉD$(EkKT$X=     uS낍s4$T$    |$LT$XD$(b=_I19t[    9  T$H    $        D$l$H y  D$T e  D$l$    ,$    D$H\$T 8  =       C\$T\$`$    \$Pkl$\$H\$|$   \$`\$    $   $    \$$   \$$   T$t$$       9uk$   $t$-    l$-    l$    $   $   \$ t,Ǆ$           $       $      É$    t Ǆ$       $   $      Ë$   19t[    9  $      L$4 un    $   Ǆ$   -   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      Ë\$4+   \$4+   \$TSCKE9w1kӉkl$4=     u+3$l$    "$    T$D$L$l$    T$D$L$\$T t;ŉD$(EkKT$X=     uS낍s4$T$    T$XD$(f\$4   197\$4   } u\$P+U0E499\$P+,$\$H|$KO\$P+l$\$4\$    D$L$$   $       $XӋL$D$$        \$D$    $   L$$   D$    \$$   \$$   Ǆ$       $    D$    D$    $   \$D$        \$$   \$$      ËD$4\$T t%=     uCs4$D$    11/    s4$D$     E D$H    1J11(<$l$    |$PE w4$D$    |$P$   $   >'1D$# <$D$    |$P$   $   1D$# s4$D$        g      Z  type."".Entity   d  "runtime.newobject     8type.map[string]*"".Identity     runtime.makemap     (runtime.writeBarrier     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     (runtime.writeBarrier     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     (runtime.writeBarrier     (runtime.writeBarrier     jgo.string."first packet was not a public/private key"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet   	  "runtime.growslice   	  (runtime.writeBarrier   
  .runtime.writebarrierptr   
  (runtime.writeBarrier     zgolang.org/x/crypto/openpgp/packet.PublicKeyAlgorithm.CanSign     jgo.string."primary key cannot be used for signatures"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     Rgo.string."entity without any identities"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyRevocationSignature     (runtime.writeBarrier     .runtime.writebarrierptr     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     pgo.string."revocation signature signed by alternate key"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     $runtime.ifacethash     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     (runtime.writeBarrier     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     "".addSubkey   !  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey   #  (runtime.writeBarrier   #  .runtime.writebarrierptr   #  `type.[]golang.org/x/crypto/openpgp/packet.Packet   $  "runtime.growslice   $  (runtime.writeBarrier   %  .runtime.writebarrierptr   &  "".addSubkey   '  dtype.*golang.org/x/crypto/openpgp/packet.Signature   )  (runtime.writeBarrier   )  .runtime.writebarrierptr   )  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   *  "runtime.growslice   +  pgo.string."signature packet found before user id packet"   +  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   ,  type.error   ,  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   ,  runtime.convT2I   -  (runtime.writeBarrier   -  .runtime.writebarrierptr   .  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   .  "runtime.growslice   /  (runtime.writeBarrier   /  .runtime.writebarrierptr   0  ^type.*golang.org/x/crypto/openpgp/packet.UserId   0   type."".Identity   0  "runtime.newobject   1  type.string   1  (runtime.typedmemmove   2  (runtime.writeBarrier   2  8type.map[string]*"".Identity   3  $runtime.mapassign1   3  bgolang.org/x/crypto/openpgp/packet.(*Reader).Next   4  io.EOF   4  io.EOF   4 io.EOF   4  runtime.ifaceeq   5  &io.ErrUnexpectedEOF   5 &io.ErrUnexpectedEOF   6  dtype.*golang.org/x/crypto/openpgp/packet.Signature   7  rgo.string."user ID packet not followed by self-signature"   7  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   8  type.error   8  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   8  runtime.convT2I   :  (runtime.writeBarrier   :  .runtime.writebarrierptr   :  htype.[]*golang.org/x/crypto/openpgp/packet.Signature   ;  "runtime.growslice   ;  (runtime.writeBarrier   <  .runtime.writebarrierptr   >  golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyUserIdSignature   >       ?  Xgo.string."user ID self-signature invalid: "   ?  *runtime.concatstring2   @  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   @  type.error   @  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   @  runtime.convT2I   A  (runtime.writeBarrier   B  .runtime.writebarrierptr   B  .runtime.writebarrierptr   C  .runtime.writebarrierptr   D  .runtime.writebarrierptr   E  .runtime.writebarrierptr   E  .runtime.writebarrierptr   F  0runtime.morestack_noctxt      N"".autotmp_0335  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0334 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0333 type.int "".autotmp_0332  type.int "".autotmp_0330  type.bool "".autotmp_0329 _\type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0328  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0327 htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0326  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0325 type.int "".autotmp_0324  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0323  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0322 Otype.string "".autotmp_0321  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0319 "type.*"".Identity "".autotmp_0318  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0316 ?ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".revocation dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt \type.golang.org/x/crypto/openpgp/packet.Packet "".pkt dtype.*golang.org/x/crypto/openpgp/packet.Signature "".sig dtype.*golang.org/x/crypto/openpgp/packet.Signature "".pkt ^type.*golang.org/x/crypto/openpgp/packet.UserId "".err type.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".revocations /htype.[]*golang.org/x/crypto/openpgp/packet.Signature "".current "type.*"".Identity 
"".ok type.bool "".err otype.error "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".e type.*"".Entity "".~r2 type.error "".~r1 type.*"".Entity "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader ++ # *M1 ICHnon4QnH%/"sn xTT*)*)o5 [3fTo2 E<7KLKLF
n+[\[\xM5/!:4I, -n$/%&%&p@R=>=>	%96  14,	B:[KZ{Fbq!B7
!B4Y!GV3[V# !C*/
J,?' o" Tgclocals·59a081aa56aea3db12c49708a232e907 Tgclocals·13f87cc0608ea5e3ee364165a76a979f   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".addSubkey    e    ;a  T1ۉ\$h\$l1ۉ\$H\$L\$P\$`\$H\$d\$L\$\$    \$\$(\$\$,T$t$t$4    9uNT$0$t$-    l$-    l$    t$4T$0\$ t    \$h    \$lTÉT$0    4$ZӋL$D$$        \$D$   L$@L$D$DD$    \$\$8\$\$<$    D$    D$    \$8\$D$        \$\$h\$\$lTË\$(19t[    9K  D$,   D$P uQ    \$8D$<'   $    D$    D$    \$8\$D$        \$\$h\$\$lTË\$P+t_\$P+(tQ    \$8D$<    $    D$    D$    \$8\$D$        \$\$h\$\$lTË\$X+,$\$H\$\$P\$    D$L$L$4D$0    $XӋL$D$$        \$D$   L$@L$D$DD$    \$\$8\$\$<$    D$    D$    \$8\$D$        \$\$h\$\$lTË\$XSCK E9w3kӉkl$H\$l$    ,$    1ۉ\$h\$lT$    T$D$L$l$    T$D$L$\$X t;ŉD$ EkK T$$=     uS뀍s4$T$    T$$D$ d11    3R        bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     &io.ErrUnexpectedEOF    &io.ErrUnexpectedEOF            Lgo.string."subkey signature invalid: "     *runtime.concatstring2     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     dtype.*golang.org/x/crypto/openpgp/packet.Signature     fgo.string."subkey packet not followed by signature"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     Xgo.string."subkey signature with wrong type"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I   	  golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifyKeySignature   	       
  Lgo.string."subkey signature invalid: "   
  *runtime.concatstring2     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     type."".Subkey     (runtime.typedmemmove      type.[]"".Subkey     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     0runtime.morestack_noctxt   0  "".autotmp_0384  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0383  type.string "".autotmp_0382  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0381  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0379 7ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0378 'type.string "".err Gtype.error "".p W\type.golang.org/x/crypto/openpgp/packet.Packet "".subKey type."".Subkey "".~r4  type.error "".priv ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".pub dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".e  type.*"".Entity `|lFy  `(@'QQ*9p	 0 BJBn$nM*C, Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·a3f332e265628a83ebf74125fa889474   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".NewEntity  &  &e    D$;A]	     1ۉ$   $   $   $    $   \$$   \$$   \$$   \$$   D$(   19ti  ti l$($   $$   \$$   \$$   \$$   \$$   \$    D$D$,19ue    \$tD$x*   Ǆ$       $    D$    D$    \$t\$D$        \$$   \$$   Ĥ   Ë$   119  (    @L$\$D$`D$\$(\$    \$\$0D$L$L$pD$l t Ǆ$       $   $   Ĥ   Ë$   119~  ( s  @L$d$D$hD$\$(\$    \$\$4D$L$L$pD$l t Ǆ$       $   $   Ĥ   Ë$   $$   \$$   \$$   \$\$0\$|$       \$\$T$   $$   \$$   \$$   \$\$0\$    \$\$P$    D$    D$    D$    D$        \$\$L$        L$σ )  1    D$TL$D=       D$P   =       AD$L   =       AL$8$        L$   L$X$   19A  h 5  hl$$$        D$1(hhhhhh\$,   kD$@D$l$    ,$    D$,\$@   =       C$        L$σ z  1    L$<$   i$   i$   i $   =     %  i$      AD$$AD$X=                            \$8   0=     x     \$@ ^  =     =  K\$@\$H$    \$8kl$\$,\$|$   \$H\$    $    D$   D$    D$   D$        T$L$D$\$8   $   K$   C $   =     m  S$   $$   \$$   \$$   \$\$4\$|$ !      \$\$T$   $$   \$$   \$$   \$\$4\$    T$$   19  h   hl$ 1ۉ\$|$   $   \$T\$|$   $        L$σ b  1    L$<$   i$   i$   i $   =       i$      AD$ A                  \$8    0=           $   \$8{ vtk\$|l$\$    $    L$8   y vBi] C8   y v'i]C8$   1ۉ$   $   Ĥ                  4$D$    L$<Y <q$4$l$    L$<D$    L    s4$T$    P    s4$L$       4$D$    L$<s V   4$D$    L$<q$4$l$    L$<s4$D$    P9D$$   q4$D$    L$DjSq4$D$    L$D.$D$    L$D    )                    ̆      j  `golang.org/x/crypto/openpgp/packet.(*Config).Now     Xgolang.org/x/crypto/openpgp/packet.NewUserId     lgo.string."user id field contained invalid characters"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     ,crypto/rsa.GenerateKey     ,crypto/rsa.GenerateKey   	  dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey   
  fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey     8type.map[string]*"".Identity     runtime.makemap     type."".Entity     "runtime.newobject     runtime.duffzero     (runtime.writeBarrier     (runtime.writeBarrier     (runtime.writeBarrier     type.bool     "runtime.newobject      type."".Identity     "runtime.newobject     type.string     (runtime.typedmemmove     (runtime.writeBarrier     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero     (runtime.writeBarrier     (runtime.writeBarrier     (runtime.writeBarrier     (runtime.writeBarrier     8type.map[string]*"".Identity     $runtime.mapassign1      type.[]"".Subkey     "runtime.makeslice     (runtime.writeBarrier     dgolang.org/x/crypto/openpgp/packet.NewRSAPublicKey     fgolang.org/x/crypto/openpgp/packet.NewRSAPrivateKey     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero     (runtime.writeBarrier     (runtime.writeBarrier     type."".Subkey     (runtime.typedmemmove     $runtime.panicindex     $runtime.panicindex     $runtime.panicindex     .runtime.writebarrierptr     .runtime.writebarrierptr      .runtime.writebarrierptr   !  .runtime.writebarrierptr   !  .runtime.writebarrierptr   "  .runtime.writebarrierptr   "  .runtime.writebarrierptr   #  .runtime.writebarrierptr   #  .runtime.writebarrierptr   $  .runtime.writebarrierptr   $  .runtime.writebarrierptr   %  $crypto/rand.Reader   % $crypto/rand.Reader   %  $crypto/rand.Reader   % $crypto/rand.Reader   %  0runtime.morestack_noctxt   P  >"".autotmp_0407  dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0406 Otype."".Subkey "".autotmp_0405 dtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0404 "type.*"".Identity "".autotmp_0403 type.*"".Entity "".autotmp_0402  ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0401  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0400 7 type.[]"".Subkey "".autotmp_0399 "type.*"".Identity "".autotmp_0398 8type.map[string]*"".Identity "".autotmp_0397 ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".autotmp_0396 dtype.*golang.org/x/crypto/openpgp/packet.PublicKey "".autotmp_0395 _xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".&isPrimaryId type.*bool "".~r0  type.crypto.Hash "".~r0  type.crypto.Hash "".~r0 type.io.Reader "".~r0 type.io.Reader "".e type.*"".Entity """.encryptingPriv 6type.*crypto/rsa.PrivateKey "".err otype.error "".signingPriv 6type.*crypto/rsa.PrivateKey "".uid ^type.*golang.org/x/crypto/openpgp/packet.UserId "".bits type.int "".currentTime type.time.Time "".~r5 @type.error "".~r4 8type.*"".Entity "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".email  type.string "".comment type.string "".name  type.string H{{
  *BJ
eS	 S	 K@
$&Jj	8B:pK<
$#j(,*A)B | 4V\|@4w?C,WO-",V&:/Q Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3 Tgclocals·abdb7871fad8719ab9d9b29665788f59   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go:"".(*Entity).SerializePrivate    e    D$;A>     11ۉ$   $   $   k,$$   \$$   \$    D$\$$   $    tĄ   Ë$   k|$T1    $    l$\$T\$    D$T19  \$X+\$T   l$(m,$$   \$$   \$    $   D$(L$\$$   $    tĄ   Ëh,$h|$M MO*l$jl$$   \$    D$\$$   $    tĄ   Ë\$(k,$$   \$$   \$    D$\$$   $    tĄ   Í\$T$    D$T19$    e  SCk l$P1ɉD$LD$ T$HЋl$ 9  ÉD$, &  0@kL$$t$<t$0D$@l$Dl$8D$4$$   \$$   \$    D$\$$   $    tĄ   Ë\$8$\$0\$$   kl$$   \$    D$\$$   $    tĄ   Ë\$8$$   \$$   \$    D$\$$   $    tĄ   ËD$,L$$Al$ 91ۉ$   $   Ą   É r            tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize     runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize     tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     &runtime.mapiternext   	  tgolang.org/x/crypto/openpgp/packet.(*PrivateKey).Serialize   
  ngolang.org/x/crypto/openpgp/packet.(*Signature).SignKey     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     0runtime.morestack_noctxt   0  "".autotmp_0444 type."".Subkey "".autotmp_0443 type.*"".Subkey "".autotmp_0442 type.int "".autotmp_0441 type.int "".autotmp_0439 w type.[]"".Subkey "".autotmp_0438 _Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err  type.error "".config ^type.*golang.org/x/crypto/openpgp/packet.Config "".w type.io.Writer "".e  type.*"".Entity v[WFNC.  ,7N?E4h1<1 $ OOFy Tgclocals·cc66687e142fc5da495a1664db6f640f Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go,"".(*Entity).Serialize    e    D$;AP     1ۉ$   $   $   +,$$   \$$   \$    D$L$L$,D$( t$   $   Đ   Ë$   k|$`1    $    l$\$`\$    D$`19c  \$d+\$`   l$m,$$   \$$   \$    D$L$L$,D$( t$   $   Đ   Ë\$k,$$   \$$   \$    D$L$L$,D$( t$   $   Đ   Ë\$   SCkl$\1ɉD$XD$T$TЋl$9}fD$$(L$,$$   \$$   \$    D$L$L$,D$( t$   $   Đ   ËD$$L$Al$9|\$`$    D$`19$    &  SCk l$P1ɉD$LD$T$HЋl$9   ÉD$      skL$D$<t$@t$4l$Dl$8D$0$$   \$$   \$    D$L$L$,D$( t$   $   Đ   Ë\$8$$   \$$   \$    D$L$L$,D$( t$   $   Đ   ËD$ L$Al$9!1ۉ$   $   Đ   É e            rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize     runtime.duffzero     8type.map[string]*"".Identity     &runtime.mapiterinit     lgolang.org/x/crypto/openpgp/packet.(*UserId).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     &runtime.mapiternext   
  rgolang.org/x/crypto/openpgp/packet.(*PublicKey).Serialize     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize     0runtime.morestack_noctxt   (   "".autotmp_0460 type."".Subkey "".autotmp_0459 type.*"".Subkey "".autotmp_0458  type.int "".autotmp_0457  type.int "".autotmp_0455 ftype.**golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0454 type.int "".autotmp_0453 type.int "".autotmp_0451  type.[]"".Subkey "".autotmp_0450 whtype.[]*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0449 _Btype.map.iter[string]*"".Identity "".subkey type."".Subkey "".ident "type.*"".Identity "".err type.error "".~r1 type.error "".w type.io.Writer "".e  type.*"".Entity l`NK.  *3	N1	1	<*	 h.	.	 ( LWFJL Tgclocals·b385d9a51ca4f468987863aa65654328 Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go2"".(*Entity).SignIdentity    e    ;a  `L$p1ۉ\$x\$|i19uQ    \$HD$L&   $    D$    D$    \$H\$D$        \$\$x\$\$|`Ëi    tQ    \$HD$L.   $    D$    D$    \$H\$D$        \$\$x\$\$|`ËL$hD$l$    \$dkl$L$@L$D$DD$    T$tL$\$)l$, uQ    \$HD$L)   $    D$    D$    \$H\$D$        \$\$x\$\$|`195  j )  jl$ $    \$\$P\$\$T\$\$X\$\$\$        |$   1       D$phEAD$ AL$4l$Pil$Til$Xi l$\=     s  i$\$pC Y  0 F  =          L$($\$h\$\$l\$\$d+l$\$pkl$\$t\$    D$L$L$<D$8 tD$xL$|`Ë\$,SkKE9w7kӉkl$(=     u+1ۉ\$x\$|`É$l$    $    T$D$L$l$    T$l$L$\$, t>l$$EkKT$0=     uSys4$T$    T$0D$$]뾍   4$D$    L$4 q$4$l$    L$4x!D$        7D      V  dgo.string."signing Entity must have a private key"   |  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     tgo.string."signing Entity's private key must be decrypted"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     8type.map[string]*"".Identity     4runtime.mapaccess2_faststr     jgo.string."given identity string not found in Entity"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     `golang.org/x/crypto/openpgp/packet.(*Config).Now     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero     (runtime.writeBarrier   	  (runtime.writeBarrier   
  tgolang.org/x/crypto/openpgp/packet.(*Signature).SignUserId     (runtime.writeBarrier     .runtime.writebarrierptr     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     0runtime.morestack_noctxt   8  "".autotmp_0468 Wdtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0466 type.time.Time "".autotmp_0465  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0464 ?type.string "".autotmp_0463  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0462 /xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".~r0  type.crypto.Hash "".err Otype.error "".sig odtype.*golang.org/x/crypto/openpgp/packet.Signature "".ident g"type.*"".Identity "".~r3 (type.error "".config  ^type.*golang.org/x/crypto/openpgp/packet.Config "".signer type.*"".Entity "".identity type.string "".e  type.*"".Entity Tg_<  x	!	QQBQ()4/N/s	 2 bU9,j	
F#Y Tgclocals·949580c181e84412df3073e61f463446 Tgclocals·ba2c509b55e4bcd7dfa9cabca2e05dcc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/keys.go"".readArmored    e    ;ak  @111ۉ\$\\$`1ۉ\$T\$X\$D$\$H\$    |$Pt$D$\$\$`D$\ t@Ét$,   .l$0VT$49uSl$0,$T$l$Ll$|$    |$Pt$,\$ t% tnl$Tnl$X1ۉ\$\\$`@É$        \$D$
   \$L\$|$    \$D$   |$NO    \$$\$8\$(\$<$    D$    D$    \$8\$D$        L$D$1ۉ\$T\$XL$\D$`@É    {      v  Pgolang.org/x/crypto/openpgp/armor.Decode      runtime.eqstring     ,go.string."expected '"     (go.string."', got: "     *runtime.concatstring4     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     0runtime.morestack_noctxt   @  "".autotmp_0479 type.string "".autotmp_0478 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".block 'Ztype.*golang.org/x/crypto/openpgp/armor.Block "".err 0type.error "".body  type.io.Reader "".expectedType type.string "".r  type.io.Reader 0Ll  (2+(	L%  :[<? Tgclocals·537385343e646e25b1b6fced99dbb969 Tgclocals·79d0667feac83fcec4421590bfc5b188   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go"".ReadMessage  K  Ke    $,;A  T  11ۉ$t  $x  1ۉ$   $   1ۉ$  $  $  1ۉ$  $  $  $X  \$|$\  $   $        D$D$x1(hh$        D$   Ǆ$P     Ǆ$T     $L  l$|($   =       h\$x$P  k$T  k=     q  C\$x\$X$        L$   $p  \$X$    L$D$T$\$$x  $t   tǄ$p      T  É$   $   $   $$   D$    $p  $   $   D$=sR  =jq%  19t[    9        $   $   $   3  $   #  \$X$   $   \$TkKE9   kӉk달$   +$   =     uUk\$X$D$    $`  \$$d  \$    D$T$L$$p  $t  $x  T  Ís4$l$    $    T$D$L$l$    T$l$L$\$T t:l$0EkKT$h=     u&$T$    T$hD$0»    $   Ǆ$   .   $    D$    D$    $   \$D$        L$D$Ǆ$p      $t  $x  T  =:>   19t[    9
  L$\          F$  $  $  C9w5$  ˉkl$\=     u+$l$    $    L$D$T$\$    L$\$T$C$  $  $  =sR19t[    9	
      L$L1ۉ$@  $H  1ۉ$   $   $H  Ǆ$D      1ۉ$  $  $  $  $  $  $  $  $   1    $    D$    D$    $  \$$   \$    \$\$d$  $  $  $x  D$8    $t  D$<$p  L$p\$8l$<9   \$p   ;sSKk$  $  $  $  $  $  $  $  $  $  $  19U  \$p\$p\$8C\$8\$8l$<9j$D   u8$   u,        Ǆ$p      $t  $x  T  Ë$h  19u,        Ǆ$p      $t  $x  T  Ë$  $@  $$D  \$$H  \$ z  D$ $h  Ӌ$  \$$  \$$   \$$$  D$T$ $   $    t Ǆ$p      $t  $x  T  Ã c$   S$  ȋ$  $`  1ɉ$\  D$4$X  Ћl$49D$l(L$@,$$  \$$   \$$$  \$    t$$4  l$$8  T$$<  \$؋L$ \$$$   $    
  \$L$D$t$l$T$    \$$   \$$   D$t$ $   $    tJ    9  $t$-    l$-    l$    $   $   \$   $    c  $p  $   kL$   =     *  kP\$X\$P$    $   \$$   \$    T$PL$D$$   $   $   $   1ۉ$   $   j        $   Ǆ$      $    D$    D$    $   \$D$        D$L$$   $   $   $   $   $    t Ǆ$p      $t  $x  T  Ë\$X$$p  \$$`  \$$d  \$    D$T$L$$p  $t  $x  T  ÉӋRkKE9wBkӉk달$   +$   =     uk1ɉ's4$l$    $    T$D$L$l$    T$l$L$\$P t>l$,EkKT$h=     uSns4$T$    T$hD$,R뾍sP4$l$    D$lL$@A_Ǆ$p      $t  $x  T  D$$      O  $  k u%$  $$  \$$l  \$    $  k M\$L$$  k	D$$      |$HOHO    \$$   \$$   D$t$ $x  $t   t4    9uo$t$-    l$-    l$    \$ tE$    $  $p   tut$\$    $    E Ǆ$p      T  É  $              $    $d  D$$h  T$$l  L$    L$D$$   $   $    \$d\$$   L$$   D$    \$+ $  $  $  $  $  $  $  $  $@  $D  $H  C9wy$D  ˉk덬$  \$l$    ,$    $   $   $   $   D$+$    \$d\$$   \$\$+\$    $    L$D$T$\$    L$\$T$C$D  $H  $@  I ^ K11D$\    11= ^u&19t[    9      = 	}2  19t[    9P  ϻ    
  |$`D$DGD$HVnNE9g  nӉkD$DD$HCo$  1ۉ$(  $,  $0  G      $d  $$`  [ӋT$L$D$$(  Չ$,  ʉ$0  $  1ɉ$  T$8$|  l$89)D$t J  ($  h$  h$  h$  L$<$  $  $  $  1ۉ$  $  $  $  $  $  $  $  $  $  $  $  $  \$`$  $  $  $  C9w=$  ˉk덬$  \$l$    ,$    D$tL$<A$    L$D$T$\$    L$\$T$C$  $  $  눉 D$GD$$d  $$`  [ӋT$L$D$,|$    T$D$L$l$    |$`T$l$L$$p   tBl$0EkKT$h=     uSBs4$T$    |$`T$hD$0"=֤19t[    9u    1111ts4$D$    ~p4$l$    $L  ;     3̺        \type.golang.org/x/crypto/openpgp/packet.Reader     "runtime.newobject     "type.[1]io.Reader     "runtime.newobject     (runtime.writeBarrier     (runtime.writeBarrier     ,type."".MessageDetails     "runtime.newobject     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.LiteralData   	  (runtime.writeBarrier   
  ("".readSignedMessage     .runtime.writebarrierptr     `type.[]golang.org/x/crypto/openpgp/packet.Packet     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     tgo.string."key material not followed by encrypted message"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted     (runtime.writeBarrier     .runtime.writebarrierptr     type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted     "runtime.growslice     ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted     runtime.duffzero     (type.map[string]bool     runtime.makemap     dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect    dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect     dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect    dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect            golang.org/x/crypto/openpgp/packet.(*SymmetricKeyEncrypted).Decrypt   !  golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt   "  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   "  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   " dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   "  runtime.ifaceeq   $  (runtime.writeBarrier   $  type.io.Reader   $  runtime.convI2I   &  Lgo.string."too many layers of packets"   &  ntype.golang.org/x/crypto/openpgp/errors.StructuralError   &  type.error   &  go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error   '  runtime.convT2I   )  ("".readSignedMessage   *  (runtime.writeBarrier   +  .runtime.writebarrierptr   +   type.[]io.Reader   +  "runtime.growslice   ,  (runtime.writeBarrier   ,  .runtime.writebarrierptr   -  .runtime.writebarrierptr   /  tgolang.org/x/crypto/openpgp/packet.(*EncryptedKey).Decrypt   0  golang.org/x/crypto/openpgp/packet.(*SymmetricallyEncrypted).Decrypt   1  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   1  dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   1 dgolang.org/x/crypto/openpgp/errors.ErrKeyIncorrect   2  runtime.ifaceeq   3  type."".Key   3  (runtime.typedmemmove   5  2runtime.slicebytetostring   5  (type.map[string]bool   6  4runtime.mapaccess1_faststr   8  type."".Key   8  (runtime.typedmemmove   8  (type.map[string]bool   9  $runtime.mapassign1   9  type.[]"".Key   9  "runtime.growslice   ;  ftype.*golang.org/x/crypto/openpgp/packet.Compressed   <  jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   ?       D  .type."".keyEnvelopePair   D  (runtime.typedmemmove   D  2type.[]"".keyEnvelopePair   E  "runtime.growslice   F       G  type.[]uint64   G  "runtime.growslice   H  (runtime.writeBarrier   H  .runtime.writebarrierptr   I  rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature   J  .runtime.writebarrierptr   J  .runtime.writebarrierptr   K  0runtime.morestack_noctxt   H	  "".autotmp_0537  type.error "".autotmp_0536 type.io.Reader "".autotmp_0534 ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0533 type.int "".autotmp_0532  type.int "".autotmp_0531  type.error "".autotmp_0530  type.error "".autotmp_0529  type."".Key "".autotmp_0528 .type."".keyEnvelopePair "".autotmp_0527 0type.*"".keyEnvelopePair "".autotmp_0526  type.int "".autotmp_0525  type.int "".autotmp_0524 6type.map.bucket[string]bool "".autotmp_0523 0type.map.hdr[string]bool "".autotmp_0522 type.error "".autotmp_0521 .type."".keyEnvelopePair "".autotmp_0520 type."".Key "".autotmp_0519 type.*"".Key "".autotmp_0518 type.int "".autotmp_0517 type.int "".autotmp_0515 type.uint64 "".autotmp_0513  type.bool "".autotmp_0512 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0510  type.[]io.Reader "".autotmp_0509 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0508  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0507  type.error "".autotmp_0506  .type.*"".MessageDetails "".autotmp_0505  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0504  type.int "".autotmp_0503 type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".autotmp_0502  type.int "".autotmp_0501  type.int "".autotmp_0500  type.int "".autotmp_0499  type.int "".autotmp_0498 type.bool "".autotmp_0497 type.string "".autotmp_0496  type.bool "".autotmp_0495 type.string "".autotmp_0494 type.[]uint8 "".autotmp_0493  type.int "".autotmp_0492 type.int "".autotmp_0491 2type.[]"".keyEnvelopePair "".autotmp_0490  type.error "".autotmp_0488 ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0487  type.int "".autotmp_0486  type.int "".autotmp_0485 type.[]"".Key Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.p·2 \type.golang.org/x/crypto/openpgp/packet.Packet Ngolang.org/x/crypto/openpgp/packet.r·1 ^type.*golang.org/x/crypto/openpgp/packet.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".err type.error "".err type.error "".key type.[]uint8 "".err type.error "".passphrase type.[]uint8 "".fpr type.string 
"".pk .type."".keyEnvelopePair 0"".candidateFingerprints (type.map[string]bool "".decrypted $type.io.ReadCloser "".candidates type.[]"".Key "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".k type."".Key "".keys type.[]"".Key "".p jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey "".p |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader 
"".se ~type.*golang.org/x/crypto/openpgp/packet.SymmetricallyEncrypted "".pubKeys 2type.[]"".keyEnvelopePair "".symKeys type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err 8type.error 
"".md 0.type.*"".MessageDetails "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".prompt  ,type."".PromptFunction "".keyring type."".KeyRing "".r  type.io.Reader 									8						T							 % /#}4 QRon95;B10$:,,w C`AV( U!
 
A%j@+XW[JH10E'_>
"B/~-6  ]7>BW3!~zF Ev@H!-Sj+% Tgclocals·073d2fd56d13eddb795b325d75824174 Tgclocals·485d794db92652a7a97ff7d4940f0d93   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go("".readSignedMessage    e    D$;A7     $   11ۉ$   $   19u$        D$$   $   1ۉ\$H\$L1ۉ\$P\$T1ۉ\$8\$<$   $    L$D$T$\$$   $    tǄ$       Ĝ   ÉL$HD$LL$x$D$|D$    |$xt$|D$=jq%  19t[    9>        $      =     c  S4$   k019y  $        L$$   L$0 N  =     ,  l$Pil$T=        il$8il$<=        i$       =        AL$0    19tSL$0$    t?D$hC8L$l=     uK<1ۉ$   $   Ĝ   Ís<4$L$    ؉$    D$    D$        D$닍q4$D$    L$0cLq4$l$    L$0$q4$l$    L$0$D$    L$0$   kL t1ۋ$   \$4    19tDL$4$    t0D$hC8L$l=     uK<s<4$L$    $    D$    D$        D$뚋$   k4 t1]$    tu8t$\$    $    ~E މE ʍs44$T$    u= ^  19t[    9g        $    t  )l$@il$D1ۉ\$X\$\j        $   Ǆ$      $    D$    D$    $   \$D$        L$D$L$pD$tL$XD$\D$dL$` Ǆ$       $   $   Ĝ   ÉӉT$$RCKE9w9kӉkl$@+l$D=     u	k1ɉ뉍s4$l$    $    T$D$L$l$    T$D$L$\$$ t>ŉD$ EkKT$,=     uSws4$T$    T$,D$ [뾉=֤19t[    9      X un    $   Ǆ$      $    D$    D$    $   \$D$        L$D$Ǆ$       $   $   Ĝ   Ëh,$D$((D$    $   t$(\$\$P\$\$T\$\$8\$\$<D$\$$   $    tǄ$       Ĝ   ø   G$VNW(O,FD$FD$D$$   $$   [ӋT$$   D$\$$   $    ~A v5$    t%=     uS0is04$T$    U    E11^1111    t      x  ,type."".MessageDetails     "runtime.newobject     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.LiteralData     (runtime.writeBarrier     8type."".signatureCheckReader     "runtime.newobject     (runtime.writeBarrier     (runtime.writeBarrier     (runtime.writeBarrier     (runtime.writeBarrier     Tgo.itab.*"".signatureCheckReader.io.Reader     (runtime.writeBarrier     .runtime.writebarrierptr     :type.*"".signatureCheckReader     type.io.Reader   	  Tgo.itab.*"".signatureCheckReader.io.Reader   	   runtime.typ2Itab   	  .runtime.writebarrierptr   
  .runtime.writebarrierptr   
  .runtime.writebarrierptr   
  .runtime.writebarrierptr     @go.itab."".checkReader.io.Reader     (runtime.writeBarrier     .runtime.writebarrierptr     &type."".checkReader     type.io.Reader     @go.itab."".checkReader.io.Reader      runtime.typ2Itab     type.io.Reader     (runtime.typedmemmove     .runtime.writebarrierptr     ftype.*golang.org/x/crypto/openpgp/packet.Compressed     Lgo.string."too many layers of packets"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     (runtime.writeBarrier     .runtime.writebarrierptr      type.[]io.Reader     "runtime.growslice     (runtime.writeBarrier     .runtime.writebarrierptr     rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature     :go.string."nested signatures"     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     runtime.convT2I     &"".hashForSignature            (runtime.writeBarrier     .runtime.writebarrierptr     $runtime.panicindex     0runtime.morestack_noctxt   8  0"".autotmp_0581  type.*uint8 "".autotmp_0579 :type.*"".signatureCheckReader "".autotmp_0578  type.error "".autotmp_0577 Wtype.error "".autotmp_0574 G\type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0573 &type."".checkReader "".autotmp_0572  :type.*"".signatureCheckReader "".autotmp_0571  type.int "".autotmp_0570 7ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0569 'ntype.golang.org/x/crypto/openpgp/errors.StructuralError Rgolang.org/x/crypto/openpgp/packet.err·1 type.error Xgolang.org/x/crypto/openpgp/packet.reader·3 type.io.Reader Ngolang.org/x/crypto/openpgp/packet.r·2 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".keys type.[]"".Key "".p rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature "".err wtype.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".err (type.error 
"".md  .type.*"".MessageDetails "".keyring type."".KeyRing "".mdin .type.*"".MessageDetails "".packets  ^type.*golang.org/x/crypto/openpgp/packet.Reader Xo  3


&[. 
@
	
	&6

	-3 3	nRC/0/0/ ` @?Q
"Ls%<	F@b< Tgclocals·32b59a2f714914dd65254a6ea209e9bc Tgclocals·5532e819bd29530b183fefa3baac8db4   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go&"".hashForSignature    e    ;a  HL$L1ۉ\$T\$X1ۉ\$\\$`1ۉ\$d\$h|  ˋ-    9s  -    ݋E 19T         $    L$D$$        \$D$   L$@L$D$DD$    \$\$8\$\$<1ۉ\$T\$X1ۉ\$\\$`$    D$    D$    \$8\$D$        \$\$d\$\$hHÉ$    l$PT$T$0L$L$4 uT$TL$XT$\L$`1ۉ\$d\$hHÕ   T$(L$,1ۉ\$ \$$$        L$L$l$()l$,=     udi1AL$    19t*L$\$0\$T\$4\$XD$\L$`1ۉ\$d\$hH$    D$    D$        D$봍q4$l$    L$늕ؕ$    L$D$$        \$D$   L$@L$D$DD$    \$\$8\$\$<1ۉ\$T\$X1ۉ\$\\$`$    D$    D$    \$8\$D$        \$\$d\$\$hH1        .:       crypto.hashes     crypto.hashes     strconv.Itoa     @go.string."hash not available: "     *runtime.concatstring2     ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     runtime.convT2I     crypto.Hash.New     2type."".canonicalTextHash     "runtime.newobject     (runtime.writeBarrier     Ngo.itab.*"".canonicalTextHash.hash.Hash     4type.*"".canonicalTextHash     type.hash.Hash     Ngo.itab.*"".canonicalTextHash.hash.Hash      runtime.typ2Itab     .runtime.writebarrierptr     strconv.Itoa     Pgo.string."unsupported signature type: "   	  *runtime.concatstring2   	  ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError   
  type.error   
  go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error   
  runtime.convT2I     $runtime.panicindex     0runtime.morestack_noctxt   @  "".autotmp_0604 W4type.*"".canonicalTextHash "".autotmp_0601  ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0600  type.string "".autotmp_0599  4type.*"".canonicalTextHash "".autotmp_0598 ptype.golang.org/x/crypto/openpgp/errors.UnsupportedError "".autotmp_0597 type.string "".~r1 Otype.hash.Hash "".h ?type.hash.Hash "".h /type.hash.Hash "".~r4 0type.error "".~r3  type.hash.Hash "".~r2 type.hash.Hash "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashId   type.crypto.Hash HA  65? * wcy(  Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea Tgclocals·f7e368e6f5e8a5337ac2afee456feb5e   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go&"".checkReader.Read    e    ;a   ,11ۉ\$D\$H\$0k4    ME\$4\$\$8\$\$<\$D$($L$$YӋ\$\$@T$t$t$HT$D    9u^$t$-    l$-    l$    \$ t4\$0 t/KLkPl$ ,$L$YӋD$L$ tD$DL$H,É͉E B    	               io.EOF     io.EOF    io.EOF     runtime.ifaceeq            0runtime.morestack_noctxt   8X  "".err (type.error "".n  type.int "".buf type.[]uint8 
"".cr  &type."".checkReader XWXW  ,R8'	  [?f Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec Tgclocals·64ca935d1a2110a30e2d604686188539   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go>"".(*signatureCheckReader).Read    e    ;aK  \11ۉ\$t\$x\$`k]4 "  Kk\$d\$\$h\$\$l\$l$<,$L$8YӋL$\$\$t\$\$xL$pD$l9  T$dϋ\$`   KkT$PT$|$T|$D$XD$l$4,$L$0Y$ӋT$t    9   $l$xl$-    l$-    l$    \$   1ۉ\$ \$$\$`+,$    T$`\$\$ \$\$$L$D$j   L$@M@D$D=       EDj]@ t\Ë\$ 19t[    9  D$$D$j p  =     K  EH|$        \$HD$L%   $    D$    D$    \$H\$D$        L$D$\$`k t,L$@M@D$D=     uED\ÍuD4$D$    E ϋj]0k,$Ѓ|$HOj]H\$    T$`L$D$j tsL$@M@D$D=     uJEDj]L t3j t/MLEPD$,$L$(YӋD$L$ tD$tL$x\ÉE ̍uD4$D$    T$`뤉E 눍uH4$D$    T$`E 1D$ puD4$D$    T$`&E J        4                      io.EOF     io.EOF    io.EOF     runtime.ifaceeq     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     (runtime.writeBarrier     dtype.*golang.org/x/crypto/openpgp/packet.Signature     (runtime.writeBarrier     bgo.string."LiteralData not followed by Signature"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     (runtime.writeBarrier     .runtime.writebarrierptr   	  ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature   
  (runtime.writeBarrier            .runtime.writebarrierptr     .runtime.writebarrierptr     .runtime.writebarrierptr     $runtime.panicslice     0runtime.morestack_noctxt   8  "".autotmp_0620 7type.error "".autotmp_0619  type.error "".autotmp_0618 'ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0616 type.[]uint8 
"".ok ytype.bool "".p w\type.golang.org/x/crypto/openpgp/packet.Packet "".err (type.error "".n  type.int "".buf type.[]uint8 "".scr  :type.*"".signatureCheckReader >  UU@
QJhZ
&
		, " ^et# Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go2"".CheckDetachedSignature    e    D$;A     11ۉ$  $  1ۉ$   $   $   1ۉ\$\\$`$   \$T$   \$X1$   $   $   $   $   $   $   D$81(hh$        D$   Ǆ$      Ǆ$      $   l$T(l$X=       h\$8C$   k$   k\$8\$0\$0$    \$\$\\$\$`t$T$$      9ud$  4$T$-    l$-    l$    $  \$ t,        Ǆ$      $  $     É$   tǄ$         ËL$\D$`L$t$D$xD$    |$tt$xT$:  19t[    9p        qQi l$$)D$#t$T$D$$   $$   [Ӌ\$$   L$\$$   $     uH    \$|Ǆ$      $    \$|\$D$        \$$KL$    \$$$\$#\$    \$\$d\$\$hL$D$T$\$$  $   tǄ$         $    L$<L$D$@D$    \$$KL$$   \$$   \$    D$t$t$pD$l tD    9}  $t$-    l$-    l$    t$pD$l\$ G  $   $   $   $   1ɉ$   D$($   Ћl$(9+  D$4   8pPhL$,$   $   $   $   $   $   $   $   L$\D$`L$t$D$xD$    |$tt$xT$   19t[    9Y         $   $\$d\$\$h\$D$    D$\$$  $   u%$   $  1ۉ$  $     ËD$4L$,Al$(9Ǆ$         ÁYu[19t[    9       t7$   $\$d\$\$h\$D$    D$\$$  B|$Dt$H    \$|Ǆ$      $    \$|\$D$        \$$KL$    11k11 Ǆ$      $  $     ÁY   19t[    9!            19un    $   Ǆ$       $    D$    D$    $   \$D$        L$D$Ǆ$      $  $     Ë   u Uil$$)D$#5|$Lt$P    $   Ǆ$      $    D$    D$    $   \$D$        L$D$Ǆ$      $  $     1111p4$l$    $   F     A`        "type.[1]io.Reader     "runtime.newobject     (runtime.writeBarrier     bgolang.org/x/crypto/openpgp/packet.(*Reader).Next     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer    fgolang.org/x/crypto/openpgp/errors.ErrUnknownIssuer     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.SignatureV3   	       
  .go.string."unreachable"   
  type.string   
  runtime.convT2E     runtime.gopanic     &"".hashForSignature     type.io.Writer     runtime.convI2I     io.Copy     io.EOF     io.EOF    io.EOF     runtime.ifaceeq     $runtime.ifacethash     htype.*golang.org/x/crypto/openpgp/packet.SignatureV3     golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignatureV3     dtype.*golang.org/x/crypto/openpgp/packet.Signature     ~golang.org/x/crypto/openpgp/packet.(*PublicKey).VerifySignature     .go.string."unreachable"     type.string     runtime.convT2E     runtime.gopanic     dtype.*golang.org/x/crypto/openpgp/packet.Signature     Xgo.string."signature doesn't have an issuer"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     Lgo.string."non signature packet found"     ntype.golang.org/x/crypto/openpgp/errors.StructuralError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     runtime.convT2I     .runtime.writebarrierptr     0runtime.morestack_noctxt   H  L"".autotmp_0657  type.uint32 "".autotmp_0656  type.bool "".autotmp_0655  \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0654 Otype."".Key "".autotmp_0653 type.*"".Key "".autotmp_0652 type.int "".autotmp_0651  type.int "".autotmp_0650  type.error "".autotmp_0649  type.error "".autotmp_0646 \type.golang.org/x/crypto/openpgp/packet.Packet "".autotmp_0643  type.[]io.Reader "".autotmp_0642 /\type.golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0641 ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0640  ^type.*golang.org/x/crypto/openpgp/packet.Reader "".autotmp_0639  type.string "".autotmp_0638 type.[]"".Key "".autotmp_0637 type.string "".autotmp_0636  type.int "".autotmp_0635 type.int "".autotmp_0634  ntype.golang.org/x/crypto/openpgp/errors.StructuralError "".autotmp_0633 ntype.golang.org/x/crypto/openpgp/errors.StructuralError Ngolang.org/x/crypto/openpgp/packet.r·2 type.io.Reader "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".key otype."".Key "".err type.error "".wrappedHash type.hash.Hash "".h type.hash.Hash "".sig \type.golang.org/x/crypto/openpgp/packet.Packet "".packets ^type.*golang.org/x/crypto/openpgp/packet.Reader "".p \type.golang.org/x/crypto/openpgp/packet.Packet "".keys type.[]"".Key "".sigType jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".hashFunc  type.crypto.Hash "".err 8type.error "".signer 0type.*"".Entity "".signature  type.io.Reader "".signed type.io.Reader "".keyring  type."".KeyRing ~)4  ,
+B,\	
=
H<\2
%,2H ?4n	n" H sPw|\-aoc	# Tgclocals·33353b89c8d716aa30f1cbcff483ff29 Tgclocals·510abbe02d5ba0858c7154a80d9fec44   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go@"".CheckArmoredDetachedSignature    e    ;a   ,11ۉ\$L\$PD$H    \$@$\$D\$    \$    \$    L$D$T$\$\$PT$L t,Ë\$0$\$4\$\$8\$\$<\$L$$L$D$(D$    T$L$D$ T$HL$LD$P,    6      p   "".SignatureType     "".SignatureType     "".readArmored     2"".CheckDetachedSignature     0runtime.morestack_noctxt   HX  "".body type.io.Reader "".err 8type.error "".signer 0type.*"".Entity "".signature  type.io.Reader "".signed type.io.Reader "".keyring  type."".KeyRing X\WXOW  '<	P  JU1 Tgclocals·3a5692de2bcadad506bd8b6dd1491c00 Tgclocals·c55cf99de9cdd8c8202a466952fa1a45   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/read.go"".DetachSign    e    ;avZ$1ۉ\$@\$D\$($\$,\$\$0\$\$4\$\$8\$D$ \$<\$    L$D$ L$@D$D$            "".detachSign     0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer HVG p 0M
 
 M# Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go("".ArmoredDetachSign    e    ;av\$11ۉ\$@\$D\$($\$,\$\$0\$\$4\$\$8\$D$ \$<\$    L$D$ L$@D$D$            ("".armoredDetachSign     0runtime.morestack_noctxt   @H  
"".err 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer HXG	 p >M 
 O! Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go""".DetachSignText    e    ;avZ$1ۉ\$@\$D\$($\$,\$\$0\$\$4\$\$8\$D$\$<\$    L$D$ L$@D$D$            "".detachSign     0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer HVG p NM
 
 M# Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".ArmoredDetachSignText    e    ;avZ$1ۉ\$@\$D\$($\$,\$\$0\$\$4\$\$8\$D$\$<\$    L$D$ L$@D$D$            ("".armoredDetachSign     0runtime.morestack_noctxt   @H  
"".~r4 0type.error "".config (^type.*golang.org/x/crypto/openpgp/packet.Config "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer HVG p ^M
 
 M# Tgclocals·cde59c54593d9a88e8be0b1914f1516e Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go("".armoredDetachSign    e    ;a   ,11ۉ\$L\$P\$0$\$4\$    \$    \$D$        L$D$T$\$ \$PT$L t,$    L$$L$D$(D$    \$$KL$\$8\$\$<\$\$@\$\$D\$\$H\$    D$\$ \$PD$L t,Ë\$($\$$[ӋL$D$L$LD$P,          `   "".SignatureType   t  "".SignatureType     Pgolang.org/x/crypto/openpgp/armor.Encode     type.io.Writer     runtime.convI2I     "".detachSign            0runtime.morestack_noctxt   HX  "".out &type.io.WriteCloser "".err 8type.error "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType (jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer X\WXsWX#W  &fD	g	$  J=k. Tgclocals·236601f43b36f8c15cf70bb83f74cf9b Tgclocals·21a8f585a14d020f181242c5256583dc   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".detachSign    e    ;a  LL$X11ۉ\$l\$pi19uQ    \$4D$8&   $    D$    D$    \$4\$D$        \$\$l\$\$pLËi    tQ    \$4D$8   $    D$    D$    \$4\$D$        \$\$l\$\$pL$        t$hL$\$dD$XhEA19  n   FL$ A4$    |$ t$T$L$D$   t$<wT$@WL$DO D$H=     Z  G$\$XC @  0 -  =          o,$/D$    \$\$,\$\$0L$D$T$\$\$pT$l tL$    L$$L$D$(D$    \$$KL$\$\\$\$`\$    \$ $\$,\$\$0\$\$Xkl$\$h\$    D$\$\$pD$l tLË\$ $\$P\$\$T\$    L$D$L$lD$pLÍ   4$D$    |$  w$4$D$    |$ a   +    2      Z  dgo.string."signing key doesn't have a private key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     Hgo.string."signing key is encrypted"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     `golang.org/x/crypto/openpgp/packet.(*Config).Now     (runtime.writeBarrier     (runtime.writeBarrier     &"".hashForSignature     type.io.Writer     runtime.convI2I     io.Copy   	  hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign   
  rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize   
  .runtime.writebarrierptr     .runtime.writebarrierptr     0runtime.morestack_noctxt   H  "".autotmp_0680 type.time.Time "".autotmp_0679  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0678 /xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".wrappedHash Otype.hash.Hash "".h ?type.hash.Hash "".sig Wdtype.*golang.org/x/crypto/openpgp/packet.Signature "".err 8type.error "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".sigType (jtype.golang.org/x/crypto/openpgp/packet.SignatureType "".message type.io.Reader "".signer type.*"".Entity "".w  type.io.Writer Ri_/R  n~#	QQ N/8	B;	0
 & dEU5&Q Tgclocals·69607a593e43f6fa2bc465446e592f44 Tgclocals·ce5958795429f4e02af1bac306c025c7   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go."".SymmetricallyEncrypt    e    D$;A7     1|$h    111ۉ$   $   1ۉ$   $   $   19uF1D$hD$lD$pD$tD$xD$|$   D$h1݈݉hhhhhh$   $   $$   \$$   \$$   \$$   \$$   \$    |$t$T$ D$$\$($   $    tĄ   Ë$   19   h   h苜$   $$   \$D$|$<|$t$@t$T$DT$$   \$    $   t$T$ D$$\$($   $    tĄ   Ét$,t$4T$0T$819t  1 tQ119tG4$T$L$D$    \$\$4\$\$8D$\$$   $    tĄ   1ҋ$      {Kst$Pkl$T|$HL$L                u5$       SKkl$`kl$dT$XL$\ 	n\$4$\$8\$$   +D$$    tN|$HOT$    l$T$L$ D$$$   $   $   $   Ą   É 뮉W1;o             B  runtime.duffzero     golang.org/x/crypto/openpgp/packet.SerializeSymmetricKeyEncrypted     golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted     lgolang.org/x/crypto/openpgp/packet.SerializeCompressed     fgolang.org/x/crypto/openpgp/packet.SerializeLiteral     0runtime.morestack_noctxt   X  "".autotmp_0695  type.int64 "".autotmp_0693 7"type."".FileHints time.t·2 Wtype.time.Time time.t·2 wtype.time.Time "".literaldata &type.io.WriteCloser "".w &type.io.WriteCloser "".key type.[]uint8 "".err Htype.error "".plaintext 8&type.io.WriteCloser "".config 0^type.*golang.org/x/crypto/openpgp/packet.Config "".hints ($type.*"".FileHints "".passphrase type.[]uint8 "".ciphertext  type.io.Writer Hs.  nIFa3Q5}
  { Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f Tgclocals·d02e8ebf325cdf993e86e63fb430cf55   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go."".intersectPreferences    e    ;a   111L$D$\$D$    D$L$\$l$9}\\$+l$ D$$\$(1ɉ$,$9}(8uZl$9sKl$U G\$C\$\$C\$\$l$9|D$9wT$T$,|$0D$4        @A    +        $runtime.panicslice     $runtime.panicindex     0runtime.morestack_noctxt   H   "".autotmp_0715  type.uint8 "".autotmp_0713 type.int "".autotmp_0710 type.*uint8 "".autotmp_0709 type.int "".autotmp_0708 type.int "".autotmp_0707  type.[]uint8 "".autotmp_0706  type.int "".intersection 0type.[]uint8 "".b type.[]uint8 "".a  type.[]uint8     41#  ' Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa Tgclocals·5184031d3a32a42d85027f073f873668   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".hashToHashId    e    ;avm\$ $    \$\$ uE    \$D$   $    \$\$D$        \$$KL$    L$$          .  Xgolang.org/x/crypto/openpgp/s2k.HashToHashId   Z  Rgo.string."tried to convert unknown hash"     type.string     runtime.convT2E     runtime.gopanic     0runtime.morestack_noctxt   8  "".autotmp_0721 type.string "".~r1 type.uint8 "".h   type.crypto.Hash 8i7  E	  >, Tgclocals·c55cf99de9cdd8c8202a466952fa1a45 Tgclocals·d8fdd2a55187867c76648dc792366181   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".Encrypt  P  Pe    $H;A  8  1$      111ۉ$d  $h  1ۉ$\  $`  Ǆ$       $P  19  $X  $    l$T$L$D$$P  $$  l$$  T$$  L$$  D$    \$$  \$$  L$$  \$ $  \$$ us    $  Ǆ$     $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8  19us    $  Ǆ$     $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8  É$       ts    $  Ǆ$     $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8  Í\$5-    -    C-    CǄ$h     Ǆ$l     $d  $       \$\$4$       \$\$3$       \$\$2$	       $h  \$1ɈL$DL$EL$FL$GL$D      Ǆ$`     \$4\$3؉C\$2؉˃˃H$l  9  ))ŋ$d   t$P  $T  $L  H$\  $`  9S  )ŉ)$X   t$D  $H  $@  $H  $    D$T$șD$T$    \$$4  \$$8  \$$<  1$H  \$Hl$H9  D$LD$8$X  $    |$t$T$L$\$8$H  9  $D  ݋] $$  |$$  t$$  T$$  L$    \$$  \$$  \$$  \$ $  \$$\$/\$8$8  9  $4  ݍ$  l$\$    $    $H  D$8$D  |$/    9   ݋] +E0$E4D$D$       L$D$$        \$D$#   $   L$$  D$    \$D$"       \$$  \$ $  $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8      9  ݋] $    \$K ~            ^  $L  $P  $T  ˃ 7     $(        $0  $,     $@  $(  $D  $,  $H  $0  $d  $$h  \$$l  \$$  |$$   D$$$  t$    \$$d  \$$h  \$ $l  $X  $$\  \$$`  \$$(  \$$,  \$$0  \$    \$$X  \$$\  \$ $`  D$L@l$H9a$h   v  $\   f  $h   Q  $d  +D$1$X  19&  h   hƋ$d  $h  $l  19}(8؇ޕ
  D$1D$<    $X  $\  $`  $  1ɉ$  D$L$|  Ћl$L9}m$   (L$H$    L$\$ J
  S
  ˋ-    9J
  -    ݋E 19+
      
  L$<$X  19	  h 	  @D$@	  Ë-    9	  -    ݋E 19	      tt$X  $\  $`  $  1ɉ$  D$H$|  Ћl$H9}:$   (L$L$    D$\$ 	  l$@9	  D$<\$< U  $\   @  $X  +D$0$    T$$   L$$   \$ uP\$0$    L$D$\$p$    \$D$   $   L$$  D$    T$L$$        \$D$L   $   T$$   L$    \$D$       \$$  \$ $  $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8      \$1$    D$$    D$T$șD$T$    |$t$T$$X  119E  ( :  @$   $$   D$$  |$$  t$$  T$    D$L$$   $    t%1ۉ$\  $`  $d  $h  8  Ë$4  $8  $<  $x  1ɉ$t  D$L$p  Ћl$L9  É$    c  8@skL$H$  $  $  $  $  $  $  $<  $$@  \$$  D$\$1\$$  \$$  \$$  \$$X  \$    D$ L$$$   $    t%1ۉ$\  $`  $d  $h  8  Ë$   L$HAl$L9$<  $$@  \$\$1\$$  \$$  \$$  \$$X  \$    $   $T  |$t$ D$$\$($h  $d   t8  19   1ɈL$XL$\L$`L$dL$hL$lL$X1D$<AjAj0R4iQ   A$   $    $   |$$   t$    \$|$KO$   $    $   $   $   $T  D$l$$   $    t%1ۉ$\  $`  $d  $h  8  19uY1Ɉ$  $  $   $  $  $  $  $  1핈iiiiii$T  $   $   $   $   19   1ۉ$   $   $    |$t$    t$$   NK$    D$    D$    $   \$D$        $T  \$$   \$$   1҃   i$  yq$  i$  $  $               ug h  i$  i$  i$  i$  D$P    D$T    $  $   	nD$PT$TT$PD$T$   $$   \$)D$ȃ|$HOT$    \$$   \$$   D$ \$$$h  $d   t1ۉ$\  $`  8  Ë$   19C  \$<$    \$$   \$$       $      $   $  $   $  $   $  $   $   \$<$$  $   $(  $   $,  $   $   $   $0  $X  $   $   $4  $    D$    D$    $  \$D$        \$$   \$$   $   $\  $   $`  1ۉ$d  $h  8  Ë$   $\  $   $`  1ۉ$d  $h  8  É1|&         $   @L$LA1d       $   @L$HAr1    @A           $  Ǆ$  @   $    D$    D$    $  \$D$        L$D$1ۉ$\  $`  $d  $h  8  #{                              N  runtime.duffzero     `golang.org/x/crypto/openpgp/packet.(*Config).Now     ."".(*Entity).signingKey     Bgo.string."no valid signing keys"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     Rgo.string."no private key in signing key"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     Rgo.string."signing key must be decrypted"     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I   	  """.statictmp_0759   	 """.statictmp_0759   
 """.statictmp_0759   
  "".hashToHashId     "".hashToHashId     "".hashToHashId     "".hashToHashId     type.[]"".Key     "runtime.makeslice     `golang.org/x/crypto/openpgp/packet.(*Config).Now     4"".(*Entity).encryptionKey     type."".Key     (runtime.typedmemmove     $strconv.FormatUint     ^go.string."cannot encrypt a message to key id "     \go.string." because it has no encryption keys"     *runtime.concatstring3     xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError     type.error     go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     runtime.convT2I     $runtime.panicindex     8"".(*Entity).primaryIdentity     ."".intersectPreferences     ."".intersectPreferences   #  Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   # crypto.hashes   #  crypto.hashes   % crypto.hashes   %  crypto.hashes   '  Xgolang.org/x/crypto/openpgp/s2k.HashIdToHash   (  \golang.org/x/crypto/openpgp/s2k.HashIdToString   )  strconv.Itoa   )  go.string."#"   *  *runtime.concatstring2   *  go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   +  6go.string." in this case.)"   +  *runtime.concatstring3   +  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   ,  type.error   ,  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   ,  runtime.convT2I   -  $runtime.panicindex   -  rgolang.org/x/crypto/openpgp/packet.CipherFunction.KeySize   -  type.[]uint8   .  "runtime.makeslice   /  io.ReadFull   4  pgolang.org/x/crypto/openpgp/packet.SerializeEncryptedKey   7  golang.org/x/crypto/openpgp/packet.SerializeSymmetricallyEncrypted   9  type.io.Writer   9  runtime.convI2I   :  golang.org/x/crypto/openpgp/packet.(*OnePassSignature).Serialize   >  type.io.Writer   >  runtime.convI2I   >  $type."".noOpCloser   ?  &type.io.WriteCloser   ?  Hgo.itab."".noOpCloser.io.WriteCloser   ?  runtime.convT2I   D  fgolang.org/x/crypto/openpgp/packet.SerializeLiteral   E  crypto.Hash.New   F  """.statictmp_0796   F  runtime.duffcopy   H  .type."".signatureWriter   H  &type.io.WriteCloser   H  Rgo.itab."".signatureWriter.io.WriteCloser   I  runtime.convT2I   K  $crypto/rand.Reader   K $crypto/rand.Reader   L  $runtime.panicindex   M  $runtime.panicindex   M  $runtime.panicindex   M  go.string."cannot encrypt because recipient set shares no common algorithms"   N  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError   N  type.error   N  go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error   N  runtime.convT2I   O  $runtime.panicindex   O  $runtime.panicindex   P  $runtime.panicindex   P  $runtime.panicslice   P  $runtime.panicslice   P  0runtime.morestack_noctxt   `  "".autotmp_0797 &type.io.WriteCloser "".autotmp_0795  type.int64 "".autotmp_0794  type.bool "".autotmp_0793 "type."".FileHints "".autotmp_0791 ptype.golang.org/x/crypto/openpgp/packet.OnePassSignature "".autotmp_0789 type."".Key "".autotmp_0788 type.*"".Key "".autotmp_0787  type.int "".autotmp_0786  type.int "".autotmp_0785  type.error "".autotmp_0784 type.[32]uint8 "".autotmp_0783  type.uint8 "".autotmp_0782  type.*uint8 "".autotmp_0781  type.int "".autotmp_0780  type.int "".autotmp_0779  type.bool "".autotmp_0777  type.uint8 "".autotmp_0776  type.*uint8 "".autotmp_0775  type.int "".autotmp_0774  type.int "".autotmp_0773  type.uint8 "".autotmp_0772  type.*uint8 "".autotmp_0771  type.int "".autotmp_0770  type.int "".autotmp_0769  type.error "".autotmp_0768  type.error "".autotmp_0767 type."".Key "".autotmp_0766  type.int "".autotmp_0765  type.int "".autotmp_0764 type.[4]uint8 "".autotmp_0761 type.[3]uint8 "".autotmp_0758  type.error "".autotmp_0757  type.error "".autotmp_0755 G.type."".signatureWriter "".autotmp_0754 type.hash.Hash "".autotmp_0753 $type."".noOpCloser "".autotmp_0752 type.[]"".Key "".autotmp_0751  type.int "".autotmp_0750  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0749  type.string "".autotmp_0748  type.[]uint8 "".autotmp_0747  type.[]uint8 "".autotmp_0746 type.[]uint8 "".autotmp_0745  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0744  type.int "".autotmp_0743  type.int "".autotmp_0742  type.int "".autotmp_0739  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0738 type.string "".autotmp_0737  type.time.Time "".autotmp_0736  type.int "".autotmp_0735  type.int "".autotmp_0734  type.int "".autotmp_0733 type.int "".autotmp_0732 type.int "".autotmp_0730 type.uint8 "".autotmp_0729 type.uint8 "".autotmp_0728 type.uint8 "".autotmp_0727  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0726  xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0725 xtype.golang.org/x/crypto/openpgp/errors.InvalidArgumentError "".autotmp_0724 type.time.Time "".~r0 type.int64 time.t·2 type.time.Time time.t·2 type.time.Time "".~r0 type.io.Reader "".literalData &type.io.WriteCloser "".w &type.io.WriteCloser "".err type.error "".ops rtype.*golang.org/x/crypto/openpgp/packet.OnePassSignature  "".encryptedData &type.io.WriteCloser "".err type.error "".key type."".Key "".err type.error "".symKey type.[]uint8 "".name type.string "".hashId type.uint8 """.configuredHash  type.crypto.Hash "".hash  type.crypto.Hash "".cipher ltype.golang.org/x/crypto/openpgp/packet.CipherFunction $"".preferredHashes type.[]uint8 *"".preferredSymmetric type.[]uint8 
"".ok type.bool "".i type.int "".encryptKeys type.[]"".Key  "".defaultHashes type.[]uint8 """.defaultCiphers type.[]uint8 $"".candidateHashes type.[]uint8 &"".candidateCiphers type.[]uint8 "".signKey type."".Key "".signer ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey "".err Ptype.error "".plaintext @&type.io.WriteCloser "".config 8^type.*golang.org/x/crypto/openpgp/packet.Config "".hints 0$type.*"".FileHints "".signed (type.*"".Entity 
"".to "type.[]*"".Entity "".ciphertext  type.io.Writer x
2B ( OsssDW9DJ!#	+*gg#* (
H[_H(+P	?y%u%t
)	{%Y
]g`3I#
s			-  uQ2g2"eJ? Tgclocals·79278f1b3c02451b235b26e0d050a9f3 Tgclocals·241abc28307bdadf2e10ff62edd177de   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Write    e    ;a   ,1ۉ\$d\$hL$DD$H\$T\$\$X\$\$\\$D$($L$$Y$ӋL$8D$<\$T\$\$X\$\$\\$D$ $L$YӋT$L$D$T$`L$dD$h,    ]                      0runtime.morestack_noctxt   xX  "".~r2 htype.error "".~r1 `type.int "".data Htype.[]uint8 "".s  .type."".signatureWriter XW  0L 
 Ke Tgclocals·d9f9402b3f7d1c398b577a45048cc887 Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go0"".signatureWriter.Close  	  	e    ;a<  T1ۉ\$|$   \$x$    \$\$D\$\$H\$\$L\$\$P$        L$σ   1    1\$tkAD$hAL$ l$Dil$Hil$Li l$P=     }  i$D$t f  0 S  =     +     L$$\$X؃|$HO\$t\$\$x\$    D$L$L$(D$$ tD$|$   TËL$`D$dD$@$L$<YӋD$L$L$8D$4 tD$|$   T$    \$X|$KO    \$|$KO\$$    D$L$L$0D$, tD$|$   TËL$XD$\D$@$L$<YӋL$D$L$|$   TÍ   4$D$    L$  q$4$l$    L$ n           P  `golang.org/x/crypto/openpgp/packet.(*Config).Now     btype.golang.org/x/crypto/openpgp/packet.Signature     "runtime.newobject     runtime.duffzero     (runtime.writeBarrier     (runtime.writeBarrier     hgolang.org/x/crypto/openpgp/packet.(*Signature).Sign            type.io.Writer     runtime.convI2I     rgolang.org/x/crypto/openpgp/packet.(*Signature).Serialize            .runtime.writebarrierptr     .runtime.writebarrierptr   	  0runtime.morestack_noctxt   X  "".autotmp_0852 gdtype.*golang.org/x/crypto/openpgp/packet.Signature "".autotmp_0850 type.time.Time "".err Otype.error "".err ?type.error "".err _type.error "".sig odtype.*golang.org/x/crypto/openpgp/packet.Signature "".~r0 Htype.error "".s  .type."".signatureWriter D;a.H  P 
,&4,I-S/  ',eO Tgclocals·5705c76a0bc7db77dc7faa07cb35699a Tgclocals·47e81b9b582fcfba016f557768a0f4be   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Write    e    ;av[$11ۉ\$@\$DL$(D$,\$0\$\$4\$\$8\$D$ $L$YӋT$L$D$T$<L$@D$D$                   0runtime.morestack_noctxt   @H  "".err 0type.error "".n (type.int "".data type.[]uint8 "".c  $type."".noOpCloser HWG
 p L	 
 I' Tgclocals·dacebcad73eed5073009fd67170948d0 Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go&"".noOpCloser.Close  @  @e    ;av11ۉ\$\$          4  0runtime.morestack_noctxt       "".~r0 type.error "".c  $type."".noOpCloser       Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go"".init    e    ;avf     t    u                                                            $        "".initdone·   6  "".initdone·   L  "runtime.throwinit   \  "".initdone·   h  hash.init   r  crypto/rsa.init   |  io.init     time.init     Lgolang.org/x/crypto/openpgp/armor.init     Ngolang.org/x/crypto/openpgp/errors.init     Ngolang.org/x/crypto/openpgp/packet.init     crypto.init     $crypto/sha256.init     strconv.init     Hgolang.org/x/crypto/openpgp/s2k.init     "".initdone·     0runtime.morestack_noctxt          
 
 %[ Tgclocals·33cdeccccebe80329f1fdbee7f5874cb Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/write.go>type..hash."".canonicalTextHash   e    ;avc\$$<$ tK\$\$    D$\$$<$ t%$D$D$D$       \$\$É    Ӊ              J  "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  4type.*"".canonicalTextHash  O    
 $\ Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go:type..eq."".canonicalTextHash   e    ;a   $\$, tz3kl$ \$( td{9uRT$$|$|$t$t$l$ l$    \$ t$\$(K\$,k9t	D$0 $D$0$D$0 $É똉    \        runtime.ifaceeq     0runtime.morestack_noctxt   H  
"".autotmp_0870 type.hash.Hash "".autotmp_0869 type.hash.Hash "".~r2 type.bool "".q 4type.*"".canonicalTextHash "".p  4type.*"".canonicalTextHash &HlGHGHGHG   
 VZ Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go(type..hash.[8]string   e    ;avZL$1D$   l$9}5D$t$ t04$L$L$    L$D$@l$9|ˉL$ É            runtime.strhash     0runtime.morestack_noctxt   (  
"".autotmp_0876 type.int "".autotmp_0875 type.int "".~r2 type.uintptr "".h type.uintptr "".p  type.*[8]string (R'('
 p p 
 D, Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go$type..eq.[8]string   e    ;a   ,1D$   l$9}uD$t$0 t~\$$~t$4 ta\$V9uDl$$,$|$(|$l$l$T$ T$    \$ tD$@l$9|D$8,D$8 ,É뛉{    ?         runtime.eqstring     0runtime.morestack_noctxt   X  "".autotmp_0881 type.string "".autotmp_0880 type.string "".autotmp_0879 /type.int "".autotmp_0878 'type.int "".~r2 type.bool "".q type.*[8]string "".p  type.*[8]string  XWXWXW   
 ~R Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go2"".(*EntityList).KeysById    e    ;a    Yt
|$$9;u#11ۉ\$0\$4\$8\$$19u9    $D$       \$D$
       \$D$       \$$$KL$KL$D$(D$D$,D$    T$L$D$T$0L$4D$8     6      ~  &go.string."openpgp"     ,go.string."EntityList"     (go.string."KeysById"     "runtime.panicwrap     ,"".EntityList.KeysById     0runtime.morestack_noctxt   0@  "".keys type.[]"".Key 
"".id type.uint64 ""..this  &type.*"".EntityList @?   
 p` Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated><"".(*EntityList).KeysByIdUsage    e    ;a   $Yt
|$(9;u#11ۉ\$8\$<\$@\$(19u9    $D$       \$D$
       \$D$       \$($KL$KL$D$,D$D$0D$\$4\$    T$L$D$ T$8L$<D$@$    -      ~  &go.string."openpgp"     ,go.string."EntityList"     2go.string."KeysByIdUsage"     "runtime.panicwrap     6"".EntityList.KeysByIdUsage     0runtime.morestack_noctxt   8H  "".keys  type.[]"".Key  "".requiredUsage type.uint8 
"".id type.uint64 ""..this  &type.*"".EntityList HG   
 pp Tgclocals·a041240a37ce609efec56707c330d1a4 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>"".(*EntityList).DecryptionKeys    e    ;a   Yt
|$9;u#11ۉ\$ \$$\$(\$19u9    $D$       \$D$
       \$D$       \$$KL$KL$    T$L$D$T$ L$$D$(    F      ~  &go.string."openpgp"     ,go.string."EntityList"     4go.string."DecryptionKeys"     "runtime.panicwrap     8"".EntityList.DecryptionKeys     0runtime.morestack_noctxt    0  "".keys type.[]"".Key ""..this  &type.*"".EntityList 0/   
 pP Tgclocals·2fccd208efe70893f9ac8d682812ae72 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash.[1]io.Reader   e    ;avZL$1D$   l$9}5D$t$ t04$L$L$    L$D$@l$9|ˉL$ É            "runtime.interhash     0runtime.morestack_noctxt   (  
"".autotmp_0896 type.int "".autotmp_0895 type.int "".~r2 type.uintptr "".h type.uintptr "".p  $type.*[1]io.Reader (R'('
 p p 
 D, Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq.[1]io.Reader   e    ;a   ,1D$   l$9}qD$t$4 tz>^\$(t$0 t]v9uDT$$t$ t$|$$|$l$(l$    \$ tD$@l$9|D$8,D$8 ,É량    F        runtime.ifaceeq     0runtime.morestack_noctxt   X  "".autotmp_0901 type.io.Reader "".autotmp_0900 type.io.Reader "".autotmp_0899 /type.int "".autotmp_0898 'type.int "".~r2 type.bool "".q $type.*[1]io.Reader "".p  $type.*[1]io.Reader  XWXWXW   
 zF Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go2"".KeyRing.DecryptionKeys   e    ;avNYt
|$9;u#1ۉ\$\$ \$$\$$\$[ӋT$L$D$T$L$ D$$          x         0runtime.morestack_noctxt   (   "".~r0 type.[]"".Key ""..this  type."".KeyRing  J p 
p 
 <4 Tgclocals·1347047f6245a35b91e9a4f213167d52 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>&"".KeyRing.KeysById   e    ;av^Yt
|$9;u#1ۉ\$,\$0\$4D$$D$D$(D$\$ $\$[ӋT$L$D$T$,L$0D$4                   0runtime.morestack_noctxt   80  "".~r1  type.[]"".Key 
"".id type.uint64 ""..this  type."".KeyRing 0Z/   
 L4 Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>0"".KeyRing.KeysByIdUsage   e    ;avgYt
|$ 9;u#1ۉ\$4\$8\$<D$(D$D$,D$\$0\$\$$$\$ [ӋT$L$D$T$4L$8D$<                   0runtime.morestack_noctxt   @8  "".~r2 (type.[]"".Key  "".requiredUsage  type.uint8 
"".id type.uint64 ""..this  type."".KeyRing 8c7   
 U+ Tgclocals·6d46c0650eba7dbebc0db316e0e0cf3b Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>Dtype..hash."".signatureCheckReader   e    ;a   \$$<$    \$\$D$       D$\$$<$ ty$D$D$    D$\$$<$ tO$D$D$    D$\$$<$ t%$D$D$D$       \$\$É    Ӊ    멉    |    K          j  runtime.memhash     "runtime.interhash     "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  :type.*"".signatureCheckReader   &    4 Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go@type..eq."".signatureCheckReader   e    ;a   $|$(T$,*9t	D$0 $Ërjl$ W9   T$$|$|$t$t$l$ l$    \$    \$, t|skl$ \$( teS{9uRT$$|$|$t$t$l$ l$    \$ t$\$(K\$,k9t	D$0 $D$0$D$0 $É뗉D$0 $            runtime.ifaceeq     runtime.ifaceeq     0runtime.morestack_noctxt   H  "".autotmp_0912  type.hash.Hash "".autotmp_0911  type.hash.Hash "".autotmp_0910 type.hash.Hash "".autotmp_0909 type.hash.Hash "".~r2 type.bool "".q :type.*"".signatureCheckReader "".p  :type.*"".signatureCheckReader 0HGHGHGHGHG    c Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*checkReader).Read   e    ;a   Yt
|$ 9;u#11ۉ\$4\$8\$ 19u9    $D$       \$D$       \$D$       \$ $\$$\$\$(\$\$,\$    T$L$D$T$0L$4D$8    @      v  &go.string."openpgp"     .go.string."checkReader"      go.string."Read"     "runtime.panicwrap     &"".checkReader.Read     0runtime.morestack_noctxt   88  "".err (type.error "".n  type.int "".buf type.[]uint8 ""..this  (type.*"".checkReader 87   
 lT Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>.type..hash."".FileHints   e    ;a   \$$<$ t}\$\$D$       D$\$$<$ tO$D$D$    D$\$$<$ t%$D$D$D$       \$\$É    Ӊ    멉    x    N
      b  runtime.memhash     runtime.strhash     runtime.memhash     0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  $type.*"".FileHints  y     0 Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go*type..eq."".FileHints   e    ;a   ,t$0T$4.*8t	D$8 ,Ënl$$vzR9   l$$,$t$(t$|$|$T$ T$    \$ t`T$0 tSL$4 tCD$z1A9u%\$9uri9uRi9u	D$8,D$8 ,É빉D$8 ,             runtime.eqstring     0runtime.morestack_noctxt   X  
"".autotmp_0926 type.string "".autotmp_0925 type.string "".~r2 type.bool "".q $type.*"".FileHints "".p  $type.*"".FileHints (XWXWXWXW    i Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go,"".(*noOpCloser).Write   e    ;a    Yt
|$$9;u#11ۉ\$8\$<\$$19u9    $D$       \$D$
       \$D$       \$$$KL$\$(\$\$,\$\$0\$    T$L$D$T$4L$8D$<     9      v  &go.string."openpgp"     ,go.string."noOpCloser"     "go.string."Write"     "runtime.panicwrap     &"".noOpCloser.Write     0runtime.morestack_noctxt   8@  "".err (type.error "".n  type.int "".data type.[]uint8 ""..this  &type.*"".noOpCloser @?   
 ld Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>,"".(*noOpCloser).Close   e    ;av{Yt
|$9;u#1ۋ\$19u9    $D$       \$D$
       \$D$       \$ t+k11D$ D$$É    o      Z  &go.string."openpgp"   z  ,go.string."noOpCloser"     "go.string."Close"     "runtime.panicwrap     0runtime.morestack_noctxt   0  "".~r0 type.error ""..this  &type.*"".noOpCloser 0s/0/   
 ^B Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>:type..hash."".signatureWriter   e    ;a   \$$<$    \$\$    D$\$$<$    $D$D$    D$\$$<$    $D$D$D$       D$\$$<$ tO$D$D$    D$\$$<$ t%$D$D$D$       \$\$É    Ӊ    멉    t    C              Z  "runtime.interhash     "runtime.interhash     runtime.memhash     "runtime.interhash     runtime.memhash     0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  0type.*"".signatureWriter   1    , Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6type..eq."".signatureWriter   e    ;a  4\$< y  3kl$0\$8 \  {9F  T$$$|$(|$t$,t$l$0l$    \$   \$<    skl$0\$8    S{9   T$$$|$(|$t$,t$l$0l$    t$<T$8\$    Jn9t	D$@ 4ËN~Br9ueD$$t$t$L$L$|$ |$    t$<T$8\$ t/Jn9t	D$@ 4ËJ n 9t	D$@ 4D$@4D$@ 4D$@ 4ÉD$@ 4É    V
        runtime.ifaceeq     runtime.ifaceeq     runtime.ifaceeq     0runtime.morestack_noctxt   h  "".autotmp_0948 ?type.hash.Hash "".autotmp_0947 /type.hash.Hash "".autotmp_0946  &type.io.WriteCloser "".autotmp_0945  &type.io.WriteCloser "".autotmp_0944 &type.io.WriteCloser "".autotmp_0943 &type.io.WriteCloser "".~r2 type.bool "".q 0type.*"".signatureWriter "".p  0type.*"".signatureWriter HhghXghghghghghghg    b Tgclocals·3bb21ca8fe1d99a3e492463bd711418a Tgclocals·895d0569a38a56443b84805daa09d838   /usr/src/github.com/nexocrew/3nigm4/_vendor/src/golang.org/x/crypto/openpgp/canonical_text.go6"".(*signatureWriter).Write   e    ;a   <Yt
|$@9;u#1ۉ\$T\$X\$@19u9    $D$       \$D$       \$D$       t$@ tA    \$D\$$\$H\$(\$L\$,    T$0L$4D$8T$PL$TD$X<É    7      r  &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Write"     "runtime.panicwrap     runtime.duffcopy     0"".signatureWriter.Write     0runtime.morestack_noctxt   8x  "".~r2 (type.error "".~r1  type.int "".data type.[]uint8 ""..this  0type.*"".signatureWriter xwxw   
 jf Tgclocals·b60dc0a6046c556b02baa766a3fd5a27 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>6"".(*signatureWriter).Close   e    ;a   ,Yt
|$09;u#1ۉ\$4\$8\$019u9    $D$       \$D$       \$D$       t$0 t!        L$$D$(L$4D$8,É    W      r  &go.string."openpgp"     6go.string."signatureWriter"     "go.string."Close"     "runtime.panicwrap     runtime.duffcopy     0"".signatureWriter.Close     0runtime.morestack_noctxt   X  "".~r0 type.error ""..this  0type.*"".signatureWriter XWXW   
 jF Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2 Tgclocals·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>>Ngo.itab.*"".canonicalTextHash.hash.Hash     Tgclocals·0c8aa8e80191a30eac23f1a218103f16                   Tgclocals·aefd16b155593f6f07980a05b297ad1f                  Tgclocals·fdec177485cbfa40ac91f85390ec1fea        	           Tgclocals·5cbd57cf8f9b35eac9551b20a42afe1f                  Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·87d20ce1b58390b294df80b886db78bf             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·3f5c1f818fa7055d0400cecd34057162             Tgclocals·c00bf85eed6a8e40863dfe64526ae817                  Tgclocals·32bd5c6dc84e3e86dd35593b3922d3aa                  Tgclocals·c59090a4d81cba64f6379027f4c17576      G                    @        @ @                     @    Tgclocals·7cfe9a03a21b8328cb9dc32a81e0154a 8  8   
                   Tgclocals·b46620cb71e89e703cda8f39022e9a1c P  P   7                    @       @  Tgclocals·4db28316a1e41bcee736a1197adee0e9 0  0   
                Tgclocals·7f7e31e410d386547ddc0047dc2faa98 p  p   $                 
      
                     Tgclocals·75e979049760da58a03960363c73f8d8 @  @         !      !      !    Tgclocals·f3cd884107c94d2b58adda1e0ef3f9dc 0  0                    Tgclocals·182a0b7256216f75ea61640d3418698d 0  0   	      A      A    Tgclocals·1bcec613e24368dd337b6dd546e388e5 (  (               Tgclocals·6a5390a59b8d22a13b923714ec7f5cb9 (  (            	    >go.itab.golang.org/x/crypto/openpgp/errors.InvalidArgumentError.error     Jgo.string.hdr."no armored data found"             Bgo.string."no armored data found"   Bgo.string."no armored data found" 0  ,no armored data found  vgo.string.hdr."expected public or private key block, got: "       +      ngo.string."expected public or private key block, got: "   ngo.string."expected public or private key block, got: " X  Xexpected public or private key block, got:   Tgclocals·07c886799a88ac80d684b8bca7c92573 0  0                     Tgclocals·4c546aaa12bca0a07eec0d3ecf7c37e3 0  0                   Tgclocals·db08f305c468200e3cf791eda6a8ebaa @  @          $  $  a$  a$  c$   Tgclocals·1f1dd8e7d89cf8bf3d8c95fe792f66ad @  @                  g       6go.string.hdr."unreachable"             .go.string."unreachable"   .go.string."unreachable"   unreachable  Tgclocals·51562c45243a0c5ce48841e15ba48784 8  8          0              Tgclocals·725f69b7ae8520ac59af51db7db265d1 8  8                      >go.itab.golang.org/x/crypto/openpgp/errors.StructuralError.error     rgo.string.hdr."first packet was not a public/private key"       )      jgo.string."first packet was not a public/private key"   jgo.string."first packet was not a public/private key" X  Tfirst packet was not a public/private key  rgo.string.hdr."primary key cannot be used for signatures"       )      jgo.string."primary key cannot be used for signatures"   jgo.string."primary key cannot be used for signatures" X  Tprimary key cannot be used for signatures  zgo.string.hdr."user ID packet not followed by self-signature"       -      rgo.string."user ID packet not followed by self-signature"   rgo.string."user ID packet not followed by self-signature" `  \user ID packet not followed by self-signature  `go.string.hdr."user ID self-signature invalid: "              Xgo.string."user ID self-signature invalid: "   Xgo.string."user ID self-signature invalid: " H  Buser ID self-signature invalid:   xgo.string.hdr."signature packet found before user id packet"       ,      pgo.string."signature packet found before user id packet"   pgo.string."signature packet found before user id packet" `  Zsignature packet found before user id packet  Zgo.string.hdr."entity without any identities"             Rgo.string."entity without any identities"   Rgo.string."entity without any identities" @  <entity without any identities  xgo.string.hdr."revocation signature signed by alternate key"       ,      pgo.string."revocation signature signed by alternate key"   pgo.string."revocation signature signed by alternate key" `  Zrevocation signature signed by alternate key  Tgclocals·13f87cc0608ea5e3ee364165a76a979f      (                                                 0   00   0     2                                                                 	     0                   Tgclocals·59a081aa56aea3db12c49708a232e907                                                                                           Tgo.string.hdr."subkey signature invalid: "             Lgo.string."subkey signature invalid: "   Lgo.string."subkey signature invalid: " 8  6subkey signature invalid:   ngo.string.hdr."subkey packet not followed by signature"       '      fgo.string."subkey packet not followed by signature"   fgo.string."subkey packet not followed by signature" P  Psubkey packet not followed by signature  `go.string.hdr."subkey signature with wrong type"              Xgo.string."subkey signature with wrong type"   Xgo.string."subkey signature with wrong type" H  Bsubkey signature with wrong type  Tgclocals·a3f332e265628a83ebf74125fa889474 8  8                      Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      tgo.string.hdr."user id field contained invalid characters"       *      lgo.string."user id field contained invalid characters"   lgo.string."user id field contained invalid characters" X  Vuser id field contained invalid characters  Tgclocals·abdb7871fad8719ab9d9b29665788f59                                   E  E  E        -  =  =   -            p  p     Tgclocals·092fba05dc9a1d750fd3f830d20d2ea3      
   U   U      U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U   U    Tgclocals·3ad51b90552f8e39bfd16e2811d6b9a2 8  8                    Tgclocals·cc66687e142fc5da495a1664db6f640f 8  8                      Tgclocals·bdba11b0e20d0b4a0d5c7fb1c5481022 @  @                     Tgclocals·b385d9a51ca4f468987863aa65654328 @  @                         lgo.string.hdr."signing Entity must have a private key"       &      dgo.string."signing Entity must have a private key"   dgo.string."signing Entity must have a private key" P  Nsigning Entity must have a private key  |go.string.hdr."signing Entity's private key must be decrypted"       .      tgo.string."signing Entity's private key must be decrypted"   tgo.string."signing Entity's private key must be decrypted" `  ^signing Entity's private key must be decrypted  rgo.string.hdr."given identity string not found in Entity"       )      jgo.string."given identity string not found in Entity"   jgo.string."given identity string not found in Entity" X  Tgiven identity string not found in Entity  Tgclocals·ba2c509b55e4bcd7dfa9cabca2e05dcc H  H                   
          Tgclocals·949580c181e84412df3073e61f463446 H  H                            4go.string.hdr."expected '"       
      ,go.string."expected '"   ,go.string."expected '"   expected '  0go.string.hdr."', got: "             (go.string."', got: "   (go.string."', got: "   ', got:   Tgclocals·79d0667feac83fcec4421590bfc5b188 0  0                     Tgclocals·537385343e646e25b1b6fced99dbb969 0  0         7          |go.string.hdr."key material not followed by encrypted message"       .      tgo.string."key material not followed by encrypted message"   tgo.string."key material not followed by encrypted message" `  ^key material not followed by encrypted message  Tgo.string.hdr."too many layers of packets"             Lgo.string."too many layers of packets"   Lgo.string."too many layers of packets" 8  6too many layers of packets  Tgclocals·485d794db92652a7a97ff7d4940f0d93 
  
!                           0   @              8   @                 @                @                 @                 @                @                               	    @      *   I   @    *   I  @    *              *   I@  @    *   I@  @   x  *   I@  @      *   I   A      *   	   @      *   	 @      *   
            *              *   
           *              *               *                *   (    @                 @             (   @      >       (   @                                                                                        Tgclocals·073d2fd56d13eddb795b325d75824174   !   	   ?   ?   ?   ?   ?   ?                                                        ?               ?   ?   ?   ?    >go.itab.golang.org/x/crypto/openpgp/errors.UnsupportedError.error     >Tgo.itab.*"".signatureCheckReader.io.Reader     >@go.itab."".checkReader.io.Reader     Bgo.string.hdr."nested signatures"             :go.string."nested signatures"   :go.string."nested signatures" (  $nested signatures  Tgclocals·5532e819bd29530b183fefa3baac8db4 x  x          `  `` h  h             `            Tgclocals·32b59a2f714914dd65254a6ea209e9bc x  x                                              Hgo.string.hdr."hash not available: "             @go.string."hash not available: "   @go.string."hash not available: " 0  *hash not available:   Xgo.string.hdr."unsupported signature type: "             Pgo.string."unsupported signature type: "   Pgo.string."unsupported signature type: " @  :unsupported signature type:   Tgclocals·f7e368e6f5e8a5337ac2afee456feb5e 0  0             x   a    Tgclocals·4c20d8bae4de54c24b0d8e9d5a7507ea 0  0          <            Tgclocals·64ca935d1a2110a30e2d604686188539                    Tgclocals·8cf14f50ac1bf7ae2848fda35f0590ec              c    jgo.string.hdr."LiteralData not followed by Signature"       %      bgo.string."LiteralData not followed by Signature"   bgo.string."LiteralData not followed by Signature" P  LLiteralData not followed by Signature  Tgclocals·28f56ac6bf6aee59936dfc37dc2ed818 0  0                     Tgclocals·92f44d26a99b4c9d566f716ef2d7d481 0  0         c   c   c    `go.string.hdr."signature doesn't have an issuer"              Xgo.string."signature doesn't have an issuer"   Xgo.string."signature doesn't have an issuer" H  Bsignature doesn't have an issuer  Tgo.string.hdr."non signature packet found"             Lgo.string."non signature packet found"   Lgo.string."non signature packet found" 8  6non signature packet found  Tgclocals·510abbe02d5ba0858c7154a80d9fec44      .              	     	      	     	    	       	     	      	     	   x  	     	  x 	  x  	   Tgclocals·33353b89c8d716aa30f1cbcff483ff29      	   ?   ?   ?   ?     ?   ?   ?   ?   ?       ?   ?    Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    Tgclocals·3a5692de2bcadad506bd8b6dd1491c00        	   ?       Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·cde59c54593d9a88e8be0b1914f1516e         ?    Tgclocals·21a8f585a14d020f181242c5256583dc                   Tgclocals·236601f43b36f8c15cf70bb83f74cf9b        	   _   _    lgo.string.hdr."signing key doesn't have a private key"       &      dgo.string."signing key doesn't have a private key"   dgo.string."signing key doesn't have a private key" P  Nsigning key doesn't have a private key  Pgo.string.hdr."signing key is encrypted"             Hgo.string."signing key is encrypted"   Hgo.string."signing key is encrypted" 8  2signing key is encrypted  Tgclocals·ce5958795429f4e02af1bac306c025c7 0  0                     Tgclocals·69607a593e43f6fa2bc465446e592f44 0  0   	   _   _   _   _    Tgclocals·d02e8ebf325cdf993e86e63fb430cf55 (  (            !   !  Tgclocals·3bf9bfd9a4b2d2bcf5866321b663428f (  (      g     g    Tgclocals·5184031d3a32a42d85027f073f873668              Tgclocals·a4452ddb8e4fb493d3c69dade262a1fa      	   	    Zgo.string.hdr."tried to convert unknown hash"             Rgo.string."tried to convert unknown hash"   Rgo.string."tried to convert unknown hash" @  <tried to convert unknown hash  Tgclocals·d8fdd2a55187867c76648dc792366181                   Tgclocals·c55cf99de9cdd8c8202a466952fa1a45                    >Hgo.itab."".noOpCloser.io.WriteCloser     >Rgo.itab."".signatureWriter.io.WriteCloser     Jgo.string.hdr."no valid signing keys"             Bgo.string."no valid signing keys"   Bgo.string."no valid signing keys" 0  ,no valid signing keys  Zgo.string.hdr."no private key in signing key"             Rgo.string."no private key in signing key"   Rgo.string."no private key in signing key" @  <no private key in signing key  Zgo.string.hdr."signing key must be decrypted"             Rgo.string."signing key must be decrypted"   Rgo.string."signing key must be decrypted" @  <signing key must be decrypted  fgo.string.hdr."cannot encrypt a message to key id "       #      ^go.string."cannot encrypt a message to key id "   ^go.string."cannot encrypt a message to key id " H  Hcannot encrypt a message to key id   dgo.string.hdr." because it has no encryption keys"       "      \go.string." because it has no encryption keys"   \go.string." because it has no encryption keys" H  F because it has no encryption keys  go.string.hdr."cannot encrypt because recipient set shares no common algorithms"       @      go.string."cannot encrypt because recipient set shares no common algorithms"   go.string."cannot encrypt because recipient set shares no common algorithms"   cannot encrypt because recipient set shares no common algorithms  "go.string.hdr."#"             go.string."#"   go.string."#"   #  go.string.hdr."cannot encrypt because no candidate hash functions are compiled in. (Wanted "       L      go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   go.string."cannot encrypt because no candidate hash functions are compiled in. (Wanted "   cannot encrypt because no candidate hash functions are compiled in. (Wanted   >go.string.hdr." in this case.)"             6go.string." in this case.)"   6go.string." in this case.)"      in this case.)  Tgclocals·241abc28307bdadf2e10ff62edd177de      j                                    @                           $           $                        @                                                     !                          0            0            0          00                         Tgclocals·79278f1b3c02451b235b26e0d050a9f3                                                        Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·d9f9402b3f7d1c398b577a45048cc887            Tgclocals·47e81b9b582fcfba016f557768a0f4be 0  0                     Tgclocals·5705c76a0bc7db77dc7faa07cb35699a 0  0               Tgclocals·23e8278e2b69a3a75fa59b23c49ed6ad              Tgclocals·dacebcad73eed5073009fd67170948d0             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0ebb2d1da58c1b4224bf5a7b370d7578             Hgo.string.hdr."PGP PUBLIC KEY BLOCK"             @go.string."PGP PUBLIC KEY BLOCK"   @go.string."PGP PUBLIC KEY BLOCK" 0  *PGP PUBLIC KEY BLOCK  Jgo.string.hdr."PGP PRIVATE KEY BLOCK"             Bgo.string."PGP PRIVATE KEY BLOCK"   Bgo.string."PGP PRIVATE KEY BLOCK" 0  ,PGP PRIVATE KEY BLOCK  :go.string.hdr."PGP SIGNATURE"             2go.string."PGP SIGNATURE"   2go.string."PGP SIGNATURE"    PGP SIGNATURE  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           <"".newline  type.[]uint8              """.statictmp_0868   < "".PublicKeyType  type.string           @go.string."PGP PUBLIC KEY BLOCK"   <""".PrivateKeyType  type.string           Bgo.string."PGP PRIVATE KEY BLOCK"   < "".SignatureType  type.string           2go.string."PGP SIGNATURE"   """.statictmp_0759  type.[3]uint8 	 """.statictmp_0796  H.type."".signatureWriter   >""".statictmp_0868  type.[2]uint8 
 >"".initdone·  type.uint8   4"".NewCanonicalTextHash·f          ."".NewCanonicalTextHash   @"".(*canonicalTextHash).Write·f          :"".(*canonicalTextHash).Write   <"".(*canonicalTextHash).Sum·f          6"".(*canonicalTextHash).Sum   @"".(*canonicalTextHash).Reset·f          :"".(*canonicalTextHash).Reset   >"".(*canonicalTextHash).Size·f          8"".(*canonicalTextHash).Size   H"".(*canonicalTextHash).BlockSize·f          B"".(*canonicalTextHash).BlockSize   >"".(*Entity).primaryIdentity·f          8"".(*Entity).primaryIdentity   :"".(*Entity).encryptionKey·f          4"".(*Entity).encryptionKey   4"".(*Entity).signingKey·f          ."".(*Entity).signingKey   2"".EntityList.KeysById·f          ,"".EntityList.KeysById   <"".EntityList.KeysByIdUsage·f          6"".EntityList.KeysByIdUsage   >"".EntityList.DecryptionKeys·f          8"".EntityList.DecryptionKeys   0"".ReadArmoredKeyRing·f          *"".ReadArmoredKeyRing   """.ReadKeyRing·f          "".ReadKeyRing   2"".readToNextPublicKey·f          ,"".readToNextPublicKey    "".ReadEntity·f          "".ReadEntity   "".addSubkey·f          "".addSubkey   "".NewEntity·f          "".NewEntity   @"".(*Entity).SerializePrivate·f          :"".(*Entity).SerializePrivate   2"".(*Entity).Serialize·f          ,"".(*Entity).Serialize   8"".(*Entity).SignIdentity·f          2"".(*Entity).SignIdentity   """.readArmored·f          "".readArmored   """.ReadMessage·f          "".ReadMessage   ."".readSignedMessage·f          ("".readSignedMessage   ,"".hashForSignature·f          &"".hashForSignature   ,"".checkReader.Read·f          &"".checkReader.Read   D"".(*signatureCheckReader).Read·f          >"".(*signatureCheckReader).Read   8"".CheckDetachedSignature·f          2"".CheckDetachedSignature   F"".CheckArmoredDetachedSignature·f          @"".CheckArmoredDetachedSignature    "".DetachSign·f          "".DetachSign   ."".ArmoredDetachSign·f          ("".ArmoredDetachSign   ("".DetachSignText·f          """.DetachSignText   6"".ArmoredDetachSignText·f          0"".ArmoredDetachSignText   ."".armoredDetachSign·f          ("".armoredDetachSign    "".detachSign·f          "".detachSign   4"".SymmetricallyEncrypt·f          ."".SymmetricallyEncrypt   4"".intersectPreferences·f          ."".intersectPreferences   $"".hashToHashId·f          "".hashToHashId   "".Encrypt·f          "".Encrypt   6"".signatureWriter.Write·f          0"".signatureWriter.Write   6"".signatureWriter.Close·f          0"".signatureWriter.Close   ,"".noOpCloser.Write·f          &"".noOpCloser.Write   ,"".noOpCloser.Close·f          &"".noOpCloser.Close   "".init·f          "".init   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ftype..hashfunc."".canonicalTextHash          >type..hash."".canonicalTextHash   Btype..eqfunc."".canonicalTextHash          :type..eq."".canonicalTextHash   <type..alg."".canonicalTextHash              Ftype..hashfunc."".canonicalTextHash     Btype..eqfunc."".canonicalTextHash   "runtime.gcbits.01    Tgo.string.hdr."*openpgp.canonicalTextHash"             Lgo.string."*openpgp.canonicalTextHash"   Lgo.string."*openpgp.canonicalTextHash" 8  6*openpgp.canonicalTextHash  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"       $      `go.string."func(*openpgp.canonicalTextHash) int"   `go.string."func(*openpgp.canonicalTextHash) int" P  Jfunc(*openpgp.canonicalTextHash) int  Htype.func(*"".canonicalTextHash) int         $D[ 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."func(*openpgp.canonicalTextHash) int"   @  Zgo.weak.type.*func(*"".canonicalTextHash) int   P Htype.func(*"".canonicalTextHash) int   h Htype.func(*"".canonicalTextHash) int     4type.*"".canonicalTextHash     type.int   go.typelink.func(*openpgp.canonicalTextHash) int	func(*"".canonicalTextHash) int          Htype.func(*"".canonicalTextHash) int   `go.string.hdr."func(*openpgp.canonicalTextHash)"              Xgo.string."func(*openpgp.canonicalTextHash)"   Xgo.string."func(*openpgp.canonicalTextHash)" H  Bfunc(*openpgp.canonicalTextHash)  @type.func(*"".canonicalTextHash)         % 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  `go.string.hdr."func(*openpgp.canonicalTextHash)"   @  Rgo.weak.type.*func(*"".canonicalTextHash)   P @type.func(*"".canonicalTextHash)   h @type.func(*"".canonicalTextHash)     4type.*"".canonicalTextHash   go.typelink.func(*openpgp.canonicalTextHash)	func(*"".canonicalTextHash)          @type.func(*"".canonicalTextHash)   .go.string.hdr."[]uint8"             &go.string."[]uint8"   &go.string."[]uint8"   []uint8  type.[]uint8 P  P      ~.8                         
   runtime.algarray   (  "runtime.gcbits.01   0  .go.string.hdr."[]uint8"   @  *go.weak.type.*[]uint8   H  type.uint8   6go.typelink.[]uint8	[]uint8          type.[]uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"       1      zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8"   zgo.string."func(*openpgp.canonicalTextHash, []uint8) []uint8" h  dfunc(*openpgp.canonicalTextHash, []uint8) []uint8  btype.func(*"".canonicalTextHash, []uint8) []uint8         |# 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) []uint8"   @  tgo.weak.type.*func(*"".canonicalTextHash, []uint8) []uint8   P btype.func(*"".canonicalTextHash, []uint8) []uint8   h btype.func(*"".canonicalTextHash, []uint8) []uint8     4type.*"".canonicalTextHash     type.[]uint8     type.[]uint8   go.typelink.func(*openpgp.canonicalTextHash, []uint8) []uint8	func(*"".canonicalTextHash, []uint8) []uint8          btype.func(*"".canonicalTextHash, []uint8) []uint8   go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"       6      go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   go.string."func(*openpgp.canonicalTextHash, []uint8) (int, error)" p  nfunc(*openpgp.canonicalTextHash, []uint8) (int, error)  ltype.func(*"".canonicalTextHash, []uint8) (int, error)         ^- 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.canonicalTextHash, []uint8) (int, error)"   @  ~go.weak.type.*func(*"".canonicalTextHash, []uint8) (int, error)   P ltype.func(*"".canonicalTextHash, []uint8) (int, error)   h ltype.func(*"".canonicalTextHash, []uint8) (int, error)     4type.*"".canonicalTextHash     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.canonicalTextHash, []uint8) (int, error)	func(*"".canonicalTextHash, []uint8) (int, error)          ltype.func(*"".canonicalTextHash, []uint8) (int, error)   2go.string.hdr."BlockSize"       	      *go.string."BlockSize"   *go.string."BlockSize"   BlockSize  4go.string.hdr."func() int"       
      ,go.string."func() int"   ,go.string."func() int"   func() int  type.func() int         9 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  4go.string.hdr."func() int"   @  0go.weak.type.*func() int   P type.func() int   h type.func() int     type.int   Bgo.typelink.func() int	func() int          type.func() int   *go.string.hdr."Reset"             "go.string."Reset"   "go.string."Reset"   Reset  ,go.string.hdr."func()"             $go.string."func()"   $go.string."func()"   func()  type.func()          3                                                   runtime.algarray   (  "runtime.gcbits.01   0  ,go.string.hdr."func()"   @  (go.weak.type.*func()   P type.func()   h type.func()   2go.typelink.func()	func()          type.func()   (go.string.hdr."Size"              go.string."Size"    go.string."Size"   
Size  &go.string.hdr."Sum"             go.string."Sum"   go.string."Sum"   Sum  Jgo.string.hdr."func([]uint8) []uint8"             Bgo.string."func([]uint8) []uint8"   Bgo.string."func([]uint8) []uint8" 0  ,func([]uint8) []uint8  4type.func([]uint8) []uint8         & 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Jgo.string.hdr."func([]uint8) []uint8"   @  Fgo.weak.type.*func([]uint8) []uint8   P 4type.func([]uint8) []uint8   h 4type.func([]uint8) []uint8     type.[]uint8     type.[]uint8   ngo.typelink.func([]uint8) []uint8	func([]uint8) []uint8          4type.func([]uint8) []uint8   *go.string.hdr."Write"             "go.string."Write"   "go.string."Write"   Write  Tgo.string.hdr."func([]uint8) (int, error)"             Lgo.string."func([]uint8) (int, error)"   Lgo.string."func([]uint8) (int, error)" 8  6func([]uint8) (int, error)  >type.func([]uint8) (int, error)         N4P 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."func([]uint8) (int, error)"   @  Pgo.weak.type.*func([]uint8) (int, error)   P >type.func([]uint8) (int, error)   h >type.func([]uint8) (int, error)     type.[]uint8     type.int     type.error   go.typelink.func([]uint8) (int, error)	func([]uint8) (int, error)          >type.func([]uint8) (int, error)   4type.*"".canonicalTextHash          -	} 6                                                                                                                                                                  @ @  runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."*openpgp.canonicalTextHash"   @  Fgo.weak.type.**"".canonicalTextHash   H  2type."".canonicalTextHash   8P 4type.*"".canonicalTextHash   `x 4type.*"".canonicalTextHash   x  2go.string.hdr."BlockSize"     type.func() int     Htype.func(*"".canonicalTextHash) int     B"".(*canonicalTextHash).BlockSize     B"".(*canonicalTextHash).BlockSize     *go.string.hdr."Reset"     type.func()     @type.func(*"".canonicalTextHash)     :"".(*canonicalTextHash).Reset     :"".(*canonicalTextHash).Reset     (go.string.hdr."Size"     type.func() int     Htype.func(*"".canonicalTextHash) int     8"".(*canonicalTextHash).Size     8"".(*canonicalTextHash).Size     &go.string.hdr."Sum"     4type.func([]uint8) []uint8     btype.func(*"".canonicalTextHash, []uint8) []uint8     6"".(*canonicalTextHash).Sum     6"".(*canonicalTextHash).Sum     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ltype.func(*"".canonicalTextHash, []uint8) (int, error)     :"".(*canonicalTextHash).Write     :"".(*canonicalTextHash).Write   "runtime.gcbits.03    Rgo.string.hdr."openpgp.canonicalTextHash"             Jgo.string."openpgp.canonicalTextHash"   Jgo.string."openpgp.canonicalTextHash" 8  4openpgp.canonicalTextHash  "go.string.hdr."h"             go.string."h"   go.string."h"   h  Vgo.string.hdr."golang.org/x/crypto/openpgp"             Ngo.string."golang.org/x/crypto/openpgp"   Ngo.string."golang.org/x/crypto/openpgp" 8  8golang.org/x/crypto/openpgp  "go.importpath."".             Ngo.string."golang.org/x/crypto/openpgp"   "go.string.hdr."s"             go.string."s"   go.string."s"   s  Bgo.string.hdr."canonicalTextHash"             :go.string."canonicalTextHash"   :go.string."canonicalTextHash" (  $canonicalTextHash  2type."".canonicalTextHash          Xݏ                                                                                             <type..alg."".canonicalTextHash   (  "runtime.gcbits.03   0  Rgo.string.hdr."openpgp.canonicalTextHash"   @  4type.*"".canonicalTextHash   H` 2type."".canonicalTextHash   `  "go.string.hdr."h"   h  "go.importpath."".   p  type.hash.Hash     "go.string.hdr."s"     "go.importpath."".     type.int   8 2type."".canonicalTextHash     Bgo.string.hdr."canonicalTextHash"     "go.importpath."".    2type."".canonicalTextHash   Fgo.string.hdr."[]*packet.Signature"             >go.string."[]*packet.Signature"   >go.string."[]*packet.Signature" (  ([]*packet.Signature  htype.[]*golang.org/x/crypto/openpgp/packet.Signature P  P      ,Ž                         
   runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."[]*packet.Signature"   @  zgo.weak.type.*[]*golang.org/x/crypto/openpgp/packet.Signature   H  dtype.*golang.org/x/crypto/openpgp/packet.Signature   go.typelink.[]*packet.Signature	[]*golang.org/x/crypto/openpgp/packet.Signature          htype.[]*golang.org/x/crypto/openpgp/packet.Signature   "runtime.gcbits.1d    @go.string.hdr."openpgp.Identity"             8go.string."openpgp.Identity"   8go.string."openpgp.Identity" (  "openpgp.Identity  (go.string.hdr."Name"              go.string."Name"    go.string."Name"   
Name  ,go.string.hdr."UserId"             $go.string."UserId"   $go.string."UserId"   UserId  :go.string.hdr."SelfSignature"             2go.string."SelfSignature"   2go.string."SelfSignature"    SelfSignature  4go.string.hdr."Signatures"       
      ,go.string."Signatures"   ,go.string."Signatures"   Signatures  0go.string.hdr."Identity"             (go.string."Identity"   (go.string."Identity"   Identity   type."".Identity          r                                                                                                                                " p  runtime.algarray   (  "runtime.gcbits.1d   0  @go.string.hdr."openpgp.Identity"   @  "type.*"".Identity   H`  type."".Identity   `  (go.string.hdr."Name"   p  type.string     ,go.string.hdr."UserId"     ^type.*golang.org/x/crypto/openpgp/packet.UserId     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     4go.string.hdr."Signatures"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature   8  type."".Identity     0go.string.hdr."Identity"     "go.importpath."".     type."".Identity   Bgo.string.hdr."*openpgp.Identity"             :go.string."*openpgp.Identity"   :go.string."*openpgp.Identity" (  $*openpgp.Identity  "type.*"".Identity  P  P      w* 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."*openpgp.Identity"   @  4go.weak.type.**"".Identity   H   type."".Identity   runtime.gcbits.      0go.string.hdr."[8]uint8"             (go.string."[8]uint8"   (go.string."[8]uint8"   [8]uint8  type.[8]uint8 `  `       >0                                 P  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[8]uint8"   @  ,go.weak.type.*[8]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[8]uint8	[8]uint8          type.[8]uint8   0go.string.hdr."[]string"             (go.string."[]string"   (go.string."[]string"   []string  type.[]string P  P      Ө
                         
   runtime.algarray   (  "runtime.gcbits.01   0  0go.string.hdr."[]string"   @  ,go.weak.type.*[]string   H  type.string   :go.typelink.[]string	[]string          type.[]string   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             0type..hashfunc.[8]string          (type..hash.[8]string   ,type..eqfunc.[8]string          $type..eq.[8]string   &type..alg.[8]string              0type..hashfunc.[8]string     ,type..eqfunc.[8]string   &runtime.gcbits.5555   UU 2go.string.hdr."[8]string"       	      *go.string."[8]string"   *go.string."[8]string"   [8]string  type.[8]string `  `@   <   US>                                   &type..alg.[8]string   (  &runtime.gcbits.5555   0  2go.string.hdr."[8]string"   @  .go.weak.type.*[8]string   H  type.string   P  type.[]string   >go.typelink.[8]string	[8]string          type.[8]string   Fgo.string.hdr."[]*openpgp.Identity"             >go.string."[]*openpgp.Identity"   >go.string."[]*openpgp.Identity" (  ([]*openpgp.Identity  &type.[]*"".Identity P  P      ԁ                         
   runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."[]*openpgp.Identity"   @  8go.weak.type.*[]*"".Identity   H  "type.*"".Identity   \go.typelink.[]*openpgp.Identity	[]*"".Identity          &type.[]*"".Identity    type..hashfunc32              ,runtime.memhash_varlen   type..eqfunc32              .runtime.memequal_varlen   type..alg32               type..hashfunc32     type..eqfunc32   "runtime.gcbits.ff    Hgo.string.hdr."[8]*openpgp.Identity"             @go.string."[8]*openpgp.Identity"   @go.string."[8]*openpgp.Identity" 0  *[8]*openpgp.Identity  (type.[8]*"".Identity `  `        j0                                   type..alg32   (  "runtime.gcbits.ff   0  Hgo.string.hdr."[8]*openpgp.Identity"   @  :go.weak.type.*[8]*"".Identity   H  "type.*"".Identity   P  &type.[]*"".Identity   `go.typelink.[8]*openpgp.Identity	[8]*"".Identity          (type.[8]*"".Identity   hgo.string.hdr."*map.bucket[string]*openpgp.Identity"       $      `go.string."*map.bucket[string]*openpgp.Identity"   `go.string."*map.bucket[string]*openpgp.Identity" P  J*map.bucket[string]*openpgp.Identity  Htype.*map.bucket[string]*"".Identity P  P      崞 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."*map.bucket[string]*openpgp.Identity"   @  Zgo.weak.type.**map.bucket[string]*"".Identity   H  Ftype.map.bucket[string]*"".Identity   .runtime.gcbits.5455fd07   TU fgo.string.hdr."map.bucket[string]*openpgp.Identity"       #      ^go.string."map.bucket[string]*openpgp.Identity"   ^go.string."map.bucket[string]*openpgp.Identity" H  Hmap.bucket[string]*openpgp.Identity  .go.string.hdr."topbits"             &go.string."topbits"   &go.string."topbits"   topbits  (go.string.hdr."keys"              go.string."keys"    go.string."keys"   
keys  ,go.string.hdr."values"             $go.string."values"   $go.string."values"   values  0go.string.hdr."overflow"             (go.string."overflow"   (go.string."overflow"   overflow  Ftype.map.bucket[string]*"".Identity   l   l   x|                                                                                      H                   h    p  runtime.algarray   (  .runtime.gcbits.5455fd07   0  fgo.string.hdr."map.bucket[string]*openpgp.Identity"   @  Xgo.weak.type.*map.bucket[string]*"".Identity   H` Ftype.map.bucket[string]*"".Identity   `  .go.string.hdr."topbits"   p  type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     (type.[8]*"".Identity     0go.string.hdr."overflow"     Htype.*map.bucket[string]*"".Identity   "runtime.gcbits.58   X `go.string.hdr."map.hdr[string]*openpgp.Identity"              Xgo.string."map.hdr[string]*openpgp.Identity"   Xgo.string."map.hdr[string]*openpgp.Identity" H  Bmap.hdr[string]*openpgp.Identity  *go.string.hdr."count"             "go.string."count"   "go.string."count"   count  *go.string.hdr."flags"             "go.string."flags"   "go.string."flags"   flags  "go.string.hdr."B"             go.string."B"   go.string."B"   B  *go.string.hdr."hash0"             "go.string."hash0"   "go.string."hash0"   hash0  .go.string.hdr."buckets"             &go.string."buckets"   &go.string."buckets"   buckets  4go.string.hdr."oldbuckets"       
      ,go.string."oldbuckets"   ,go.string."oldbuckets"   oldbuckets  2go.string.hdr."nevacuate"       	      *go.string."nevacuate"   *go.string."nevacuate"   nevacuate  @type.map.hdr[string]*"".Identity         P                                                                                                                                                                                        * p  runtime.algarray   (  "runtime.gcbits.58   0  `go.string.hdr."map.hdr[string]*openpgp.Identity"   @  Rgo.weak.type.*map.hdr[string]*"".Identity   H` @type.map.hdr[string]*"".Identity   `  *go.string.hdr."count"   p  type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     4go.string.hdr."oldbuckets"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   Xgo.string.hdr."map[string]*openpgp.Identity"             Pgo.string."map[string]*openpgp.Identity"   Pgo.string."map[string]*openpgp.Identity" @  :map[string]*openpgp.Identity  8type.map[string]*"".Identity x  x      % 5                                      l    runtime.algarray   (  "runtime.gcbits.01   0  Xgo.string.hdr."map[string]*openpgp.Identity"   @  Jgo.weak.type.*map[string]*"".Identity   H  type.string   P  "type.*"".Identity   X  Ftype.map.bucket[string]*"".Identity   `  @type.map.hdr[string]*"".Identity   go.typelink.map[string]*openpgp.Identity	map[string]*"".Identity          8type.map[string]*"".Identity    type..hashfunc12             ,runtime.memhash_varlen   type..eqfunc12             .runtime.memequal_varlen   type..alg12               type..hashfunc12     type..eqfunc12   >go.string.hdr."*openpgp.Subkey"             6go.string."*openpgp.Subkey"   6go.string."*openpgp.Subkey"     *openpgp.Subkey  type.*"".Subkey  P  P      	 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."*openpgp.Subkey"   @  0go.weak.type.**"".Subkey   H  type."".Subkey   "runtime.gcbits.07    <go.string.hdr."openpgp.Subkey"             4go.string."openpgp.Subkey"   4go.string."openpgp.Subkey"    openpgp.Subkey  2go.string.hdr."PublicKey"       	      *go.string."PublicKey"   *go.string."PublicKey"   PublicKey  4go.string.hdr."PrivateKey"       
      ,go.string."PrivateKey"   ,go.string."PrivateKey"   PrivateKey  &go.string.hdr."Sig"             go.string."Sig"   go.string."Sig"   Sig  ,go.string.hdr."Subkey"             $go.string."Subkey"   $go.string."Subkey"   Subkey  type."".Subkey          Y                                                                                                                type..alg12   (  "runtime.gcbits.07   0  <go.string.hdr."openpgp.Subkey"   @  type.*"".Subkey   H` type."".Subkey   `  2go.string.hdr."PublicKey"   p  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     &go.string.hdr."Sig"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   8 type."".Subkey     ,go.string.hdr."Subkey"     "go.importpath."".    type."".Subkey   @go.string.hdr."[]openpgp.Subkey"             8go.string."[]openpgp.Subkey"   8go.string."[]openpgp.Subkey" (  "[]openpgp.Subkey   type.[]"".Subkey P  P      Fp                         
   runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."[]openpgp.Subkey"   @  2go.weak.type.*[]"".Subkey   H  type."".Subkey   Pgo.typelink.[]openpgp.Subkey	[]"".Subkey           type.[]"".Subkey   "runtime.gcbits.4f   O <go.string.hdr."openpgp.Entity"             4go.string."openpgp.Entity"   4go.string."openpgp.Entity"    openpgp.Entity  4go.string.hdr."PrimaryKey"       
      ,go.string."PrimaryKey"   ,go.string."PrimaryKey"   PrimaryKey  4go.string.hdr."Identities"       
      ,go.string."Identities"   ,go.string."Identities"   Identities  6go.string.hdr."Revocations"             .go.string."Revocations"   .go.string."Revocations"   Revocations  .go.string.hdr."Subkeys"             &go.string."Subkeys"   &go.string."Subkeys"   Subkeys  ,go.string.hdr."Entity"             $go.string."Entity"   $go.string."Entity"   Entity  type."".Entity    $                                                                                                                                                         & p  runtime.algarray   (  "runtime.gcbits.4f   0  <go.string.hdr."openpgp.Entity"   @  type.*"".Entity   H` type."".Entity   `  4go.string.hdr."PrimaryKey"   p  dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     4go.string.hdr."Identities"     8type.map[string]*"".Identity     6go.string.hdr."Revocations"     htype.[]*golang.org/x/crypto/openpgp/packet.Signature     .go.string.hdr."Subkeys"      type.[]"".Subkey   8 type."".Entity     ,go.string.hdr."Entity"     "go.importpath."".    type."".Entity   >go.string.hdr."*openpgp.Entity"             6go.string."*openpgp.Entity"   6go.string."*openpgp.Entity"     *openpgp.Entity  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"       &      dgo.string."func(*openpgp.Entity, io.Writer) error"   dgo.string."func(*openpgp.Entity, io.Writer) error" P  Nfunc(*openpgp.Entity, io.Writer) error  Ltype.func(*"".Entity, io.Writer) error         Wf 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  lgo.string.hdr."func(*openpgp.Entity, io.Writer) error"   @  ^go.weak.type.*func(*"".Entity, io.Writer) error   P Ltype.func(*"".Entity, io.Writer) error   h Ltype.func(*"".Entity, io.Writer) error     type.*"".Entity     type.io.Writer     type.error   go.typelink.func(*openpgp.Entity, io.Writer) error	func(*"".Entity, io.Writer) error          Ltype.func(*"".Entity, io.Writer) error   go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"       6      go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error"   go.string."func(*openpgp.Entity, io.Writer, *packet.Config) error" p  nfunc(*openpgp.Entity, io.Writer, *packet.Config) error  type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error         = 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, io.Writer, *packet.Config) error"   @  go.weak.type.*func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, io.Writer, *packet.Config) error	func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"       D      go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   go.string."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error  type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error         P 3                                                                   runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error"   @  go.weak.type.*func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.*"".Entity     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(*openpgp.Entity, string, *openpgp.Entity, *packet.Config) error	func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   8go.string.hdr."*openpgp.Key"             0go.string."*openpgp.Key"   0go.string."*openpgp.Key"    *openpgp.Key  type.*"".Key  P  P      ?n 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  8go.string.hdr."*openpgp.Key"   @  *go.weak.type.**"".Key   H  type."".Key   "runtime.gcbits.0f    6go.string.hdr."openpgp.Key"             .go.string."openpgp.Key"   .go.string."openpgp.Key"   openpgp.Key  &go.string.hdr."Key"             go.string."Key"   go.string."Key"   Key  type."".Key          M,                                                                                                                                " `  runtime.algarray   (  "runtime.gcbits.0f   0  6go.string.hdr."openpgp.Key"   @  type.*"".Key   H` type."".Key   `  ,go.string.hdr."Entity"   p  type.*"".Entity     2go.string.hdr."PublicKey"     dtype.*golang.org/x/crypto/openpgp/packet.PublicKey     4go.string.hdr."PrivateKey"     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     :go.string.hdr."SelfSignature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature   8 type."".Key     &go.string.hdr."Key"     "go.importpath."".    type."".Key   go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"       4      go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   go.string."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)" p  jfunc(*openpgp.Entity, time.Time) (openpgp.Key, bool)  ^type.func(*"".Entity, time.Time) ("".Key, bool)         k 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.Entity, time.Time) (openpgp.Key, bool)"   @  pgo.weak.type.*func(*"".Entity, time.Time) ("".Key, bool)   P ^type.func(*"".Entity, time.Time) ("".Key, bool)   h ^type.func(*"".Entity, time.Time) ("".Key, bool)     type.*"".Entity     type.time.Time     type."".Key     type.bool   go.typelink.func(*openpgp.Entity, time.Time) (openpgp.Key, bool)	func(*"".Entity, time.Time) ("".Key, bool)          ^type.func(*"".Entity, time.Time) ("".Key, bool)   ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"       '      fgo.string."func(*openpgp.Entity) *openpgp.Identity"   fgo.string."func(*openpgp.Entity) *openpgp.Identity" P  Pfunc(*openpgp.Entity) *openpgp.Identity  Dtype.func(*"".Entity) *"".Identity         ! 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ngo.string.hdr."func(*openpgp.Entity) *openpgp.Identity"   @  Vgo.weak.type.*func(*"".Entity) *"".Identity   P Dtype.func(*"".Entity) *"".Identity   h Dtype.func(*"".Entity) *"".Identity     type.*"".Entity     "type.*"".Identity   go.typelink.func(*openpgp.Entity) *openpgp.Identity	func(*"".Entity) *"".Identity          Dtype.func(*"".Entity) *"".Identity   2go.string.hdr."Serialize"       	      *go.string."Serialize"   *go.string."Serialize"   Serialize  Jgo.string.hdr."func(io.Writer) error"             Bgo.string."func(io.Writer) error"   Bgo.string."func(io.Writer) error" 0  ,func(io.Writer) error  4type.func(io.Writer) error         _9 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Jgo.string.hdr."func(io.Writer) error"   @  Fgo.weak.type.*func(io.Writer) error   P 4type.func(io.Writer) error   h 4type.func(io.Writer) error     type.io.Writer     type.error   ngo.typelink.func(io.Writer) error	func(io.Writer) error          4type.func(io.Writer) error   @go.string.hdr."SerializePrivate"             8go.string."SerializePrivate"   8go.string."SerializePrivate" (  "SerializePrivate  jgo.string.hdr."func(io.Writer, *packet.Config) error"       %      bgo.string."func(io.Writer, *packet.Config) error"   bgo.string."func(io.Writer, *packet.Config) error" P  Lfunc(io.Writer, *packet.Config) error  type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error         o` 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  jgo.string.hdr."func(io.Writer, *packet.Config) error"   @  go.weak.type.*func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.io.Writer     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(io.Writer, *packet.Config) error	func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error   8go.string.hdr."SignIdentity"             0go.string."SignIdentity"   0go.string."SignIdentity"    SignIdentity  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"       3      ~go.string."func(string, *openpgp.Entity, *packet.Config) error"   ~go.string."func(string, *openpgp.Entity, *packet.Config) error" h  hfunc(string, *openpgp.Entity, *packet.Config) error  type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error         0= 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(string, *openpgp.Entity, *packet.Config) error"   @  go.weak.type.*func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   P type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   h type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.string     type.*"".Entity     ^type.*golang.org/x/crypto/openpgp/packet.Config     type.error   go.typelink.func(string, *openpgp.Entity, *packet.Config) error	func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error          type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error   :go.string.hdr."encryptionKey"             2go.string."encryptionKey"   2go.string."encryptionKey"    encryptionKey  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"       #      ^go.string."func(time.Time) (openpgp.Key, bool)"   ^go.string."func(time.Time) (openpgp.Key, bool)" H  Hfunc(time.Time) (openpgp.Key, bool)  Ftype.func(time.Time) ("".Key, bool)         3I 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  fgo.string.hdr."func(time.Time) (openpgp.Key, bool)"   @  Xgo.weak.type.*func(time.Time) ("".Key, bool)   P Ftype.func(time.Time) ("".Key, bool)   h Ftype.func(time.Time) ("".Key, bool)     type.time.Time     type."".Key     type.bool   go.typelink.func(time.Time) (openpgp.Key, bool)	func(time.Time) ("".Key, bool)          Ftype.func(time.Time) ("".Key, bool)   >go.string.hdr."primaryIdentity"             6go.string."primaryIdentity"   6go.string."primaryIdentity"     primaryIdentity  Pgo.string.hdr."func() *openpgp.Identity"             Hgo.string."func() *openpgp.Identity"   Hgo.string."func() *openpgp.Identity" 8  2func() *openpgp.Identity  0type.func() *"".Identity         $ 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."func() *openpgp.Identity"   @  Bgo.weak.type.*func() *"".Identity   P 0type.func() *"".Identity   h 0type.func() *"".Identity     "type.*"".Identity   pgo.typelink.func() *openpgp.Identity	func() *"".Identity          0type.func() *"".Identity   4go.string.hdr."signingKey"       
      ,go.string."signingKey"   ,go.string."signingKey"   signingKey  type.*"".Entity          U㈡ 6                                                                                                                                                                                          P @  runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."*openpgp.Entity"   @  0go.weak.type.**"".Entity   H  type."".Entity   8P type.*"".Entity   `x type.*"".Entity   x  2go.string.hdr."Serialize"     4type.func(io.Writer) error     Ltype.func(*"".Entity, io.Writer) error     ,"".(*Entity).Serialize     ,"".(*Entity).Serialize     @go.string.hdr."SerializePrivate"     type.func(io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, io.Writer, *golang.org/x/crypto/openpgp/packet.Config) error     :"".(*Entity).SerializePrivate     :"".(*Entity).SerializePrivate     8go.string.hdr."SignIdentity"     type.func(string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     type.func(*"".Entity, string, *"".Entity, *golang.org/x/crypto/openpgp/packet.Config) error     2"".(*Entity).SignIdentity     2"".(*Entity).SignIdentity     :go.string.hdr."encryptionKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     4"".(*Entity).encryptionKey     4"".(*Entity).encryptionKey     >go.string.hdr."primaryIdentity"     "go.importpath."".     0type.func() *"".Identity     Dtype.func(*"".Entity) *"".Identity     8"".(*Entity).primaryIdentity     8"".(*Entity).primaryIdentity     4go.string.hdr."signingKey"     "go.importpath."".     Ftype.func(time.Time) ("".Key, bool)     ^type.func(*"".Entity, time.Time) ("".Key, bool)     ."".(*Entity).signingKey     ."".(*Entity).signingKey   Dgo.string.hdr."**openpgp.Identity"             <go.string."**openpgp.Identity"   <go.string."**openpgp.Identity" (  &**openpgp.Identity  $type.**"".Identity P  P      yqZ 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."**openpgp.Identity"   @  6go.weak.type.***"".Identity   H  "type.*"".Identity   bgo.string.hdr."*map.hdr[string]*openpgp.Identity"       !      Zgo.string."*map.hdr[string]*openpgp.Identity"   Zgo.string."*map.hdr[string]*openpgp.Identity" H  D*map.hdr[string]*openpgp.Identity  Btype.*map.hdr[string]*"".Identity P  P      nu 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  bgo.string.hdr."*map.hdr[string]*openpgp.Identity"   @  Tgo.weak.type.**map.hdr[string]*"".Identity   H  @type.map.hdr[string]*"".Identity   bgo.string.hdr."map.iter[string]*openpgp.Identity"       !      Zgo.string."map.iter[string]*openpgp.Identity"   Zgo.string."map.iter[string]*openpgp.Identity" H  Dmap.iter[string]*openpgp.Identity  &go.string.hdr."key"             go.string."key"   go.string."key"   key  &go.string.hdr."val"             go.string."val"   go.string."val"   val  "go.string.hdr."t"             go.string."t"   go.string."t"   t  (go.string.hdr."bptr"              go.string."bptr"    go.string."bptr"   
bptr  2go.string.hdr."overflow0"       	      *go.string."overflow0"   *go.string."overflow0"   overflow0  2go.string.hdr."overflow1"       	      *go.string."overflow1"   *go.string."overflow1"   overflow1  6go.string.hdr."startBucket"             .go.string."startBucket"   .go.string."startBucket"   startBucket  *go.string.hdr."stuff"             "go.string."stuff"   "go.string."stuff"   stuff  ,go.string.hdr."bucket"             $go.string."bucket"   $go.string."bucket"   bucket  6go.string.hdr."checkBucket"             .go.string."checkBucket"   .go.string."checkBucket"   checkBucket  Btype.map.iter[string]*"".Identity   0       λ%                                                                                                                                                                                                                            $                   (                   ,   : p  runtime.algarray   (  "runtime.gcbits.ff   0  bgo.string.hdr."map.iter[string]*openpgp.Identity"   @  Tgo.weak.type.*map.iter[string]*"".Identity   H` Btype.map.iter[string]*"".Identity   `  &go.string.hdr."key"   p  type.*string     &go.string.hdr."val"     $type.**"".Identity     "go.string.hdr."t"     type.*uint8     "go.string.hdr."h"     Btype.*map.hdr[string]*"".Identity     .go.string.hdr."buckets"     Htype.*map.bucket[string]*"".Identity     (go.string.hdr."bptr"     Htype.*map.bucket[string]*"".Identity     2go.string.hdr."overflow0"     &type.unsafe.Pointer     2go.string.hdr."overflow1"     &type.unsafe.Pointer     6go.string.hdr."startBucket"     type.uintptr     *go.string.hdr."stuff"     type.uintptr     ,go.string.hdr."bucket"     type.uintptr     6go.string.hdr."checkBucket"     type.uintptr   Fgo.string.hdr."*openpgp.EntityList"             >go.string."*openpgp.EntityList"   >go.string."*openpgp.EntityList" (  (*openpgp.EntityList  .go.string.hdr."openpgp"             &go.string."openpgp"   &go.string."openpgp"   openpgp  4go.string.hdr."EntityList"       
      ,go.string."EntityList"   ,go.string."EntityList"   EntityList  0go.string.hdr."KeysById"             (go.string."KeysById"   (go.string."KeysById"   KeysById  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·6432f8c6a0d23fa7bee6c5d96f21a92a             :go.string.hdr."KeysByIdUsage"             2go.string."KeysByIdUsage"   2go.string."KeysByIdUsage"    KeysByIdUsage  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·a041240a37ce609efec56707c330d1a4             <go.string.hdr."DecryptionKeys"             4go.string."DecryptionKeys"   4go.string."DecryptionKeys"    DecryptionKeys  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·2fccd208efe70893f9ac8d682812ae72             :go.string.hdr."[]openpgp.Key"             2go.string."[]openpgp.Key"   2go.string."[]openpgp.Key"    []openpgp.Key  type.[]"".Key P  P      F                         
   runtime.algarray   (  "runtime.gcbits.01   0  :go.string.hdr."[]openpgp.Key"   @  ,go.weak.type.*[]"".Key   H  type."".Key   Dgo.typelink.[]openpgp.Key	[]"".Key          type.[]"".Key   ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"       '      fgo.string."func(*openpgp.EntityList) []openpgp.Key"   fgo.string."func(*openpgp.EntityList) []openpgp.Key" P  Pfunc(*openpgp.EntityList) []openpgp.Key  Dtype.func(*"".EntityList) []"".Key         5X 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ngo.string.hdr."func(*openpgp.EntityList) []openpgp.Key"   @  Vgo.weak.type.*func(*"".EntityList) []"".Key   P Dtype.func(*"".EntityList) []"".Key   h Dtype.func(*"".EntityList) []"".Key     &type.*"".EntityList     type.[]"".Key   go.typelink.func(*openpgp.EntityList) []openpgp.Key	func(*"".EntityList) []"".Key          Dtype.func(*"".EntityList) []"".Key   ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"       /      vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key"   vgo.string."func(*openpgp.EntityList, uint64) []openpgp.Key" `  `func(*openpgp.EntityList, uint64) []openpgp.Key  Ttype.func(*"".EntityList, uint64) []"".Key         Űȟ 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(*openpgp.EntityList, uint64) []openpgp.Key"   @  fgo.weak.type.*func(*"".EntityList, uint64) []"".Key   P Ttype.func(*"".EntityList, uint64) []"".Key   h Ttype.func(*"".EntityList, uint64) []"".Key     &type.*"".EntityList     type.uint64     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64) []openpgp.Key	func(*"".EntityList, uint64) []"".Key          Ttype.func(*"".EntityList, uint64) []"".Key   go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"       6      go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key" p  nfunc(*openpgp.EntityList, uint64, uint8) []openpgp.Key  btype.func(*"".EntityList, uint64, uint8) []"".Key         uJ? 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.EntityList, uint64, uint8) []openpgp.Key"   @  tgo.weak.type.*func(*"".EntityList, uint64, uint8) []"".Key   P btype.func(*"".EntityList, uint64, uint8) []"".Key   h btype.func(*"".EntityList, uint64, uint8) []"".Key     &type.*"".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(*openpgp.EntityList, uint64, uint8) []openpgp.Key	func(*"".EntityList, uint64, uint8) []"".Key          btype.func(*"".EntityList, uint64, uint8) []"".Key   Hgo.string.hdr."func() []openpgp.Key"             @go.string."func() []openpgp.Key"   @go.string."func() []openpgp.Key" 0  *func() []openpgp.Key  (type.func() []"".Key         · 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  Hgo.string.hdr."func() []openpgp.Key"   @  :go.weak.type.*func() []"".Key   P (type.func() []"".Key   h (type.func() []"".Key     type.[]"".Key   `go.typelink.func() []openpgp.Key	func() []"".Key          (type.func() []"".Key   Tgo.string.hdr."func(uint64) []openpgp.Key"             Lgo.string."func(uint64) []openpgp.Key"   Lgo.string."func(uint64) []openpgp.Key" 8  6func(uint64) []openpgp.Key  4type.func(uint64) []"".Key         m 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."func(uint64) []openpgp.Key"   @  Fgo.weak.type.*func(uint64) []"".Key   P 4type.func(uint64) []"".Key   h 4type.func(uint64) []"".Key     type.uint64     type.[]"".Key   xgo.typelink.func(uint64) []openpgp.Key	func(uint64) []"".Key          4type.func(uint64) []"".Key   bgo.string.hdr."func(uint64, uint8) []openpgp.Key"       !      Zgo.string."func(uint64, uint8) []openpgp.Key"   Zgo.string."func(uint64, uint8) []openpgp.Key" H  Dfunc(uint64, uint8) []openpgp.Key  Btype.func(uint64, uint8) []"".Key         "GV 3                                                           runtime.algarray   (  "runtime.gcbits.01   0  bgo.string.hdr."func(uint64, uint8) []openpgp.Key"   @  Tgo.weak.type.*func(uint64, uint8) []"".Key   P Btype.func(uint64, uint8) []"".Key   h Btype.func(uint64, uint8) []"".Key     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(uint64, uint8) []openpgp.Key	func(uint64, uint8) []"".Key          Btype.func(uint64, uint8) []"".Key   &type.*"".EntityList           6                                                                                                                  , @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."*openpgp.EntityList"   @  8go.weak.type.**"".EntityList   H  $type."".EntityList   8P &type.*"".EntityList   `x &type.*"".EntityList   x  <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Dtype.func(*"".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     >"".(*EntityList).DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Ttype.func(*"".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     2"".(*EntityList).KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     btype.func(*"".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     <"".(*EntityList).KeysByIdUsage   Dgo.string.hdr."openpgp.EntityList"             <go.string."openpgp.EntityList"   <go.string."openpgp.EntityList" (  &openpgp.EntityList  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"       &      dgo.string."func(openpgp.EntityList) []openpgp.Key"   dgo.string."func(openpgp.EntityList) []openpgp.Key" P  Nfunc(openpgp.EntityList) []openpgp.Key  Btype.func("".EntityList) []"".Key         "} 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  lgo.string.hdr."func(openpgp.EntityList) []openpgp.Key"   @  Tgo.weak.type.*func("".EntityList) []"".Key   P Btype.func("".EntityList) []"".Key   h Btype.func("".EntityList) []"".Key     $type."".EntityList     type.[]"".Key   go.typelink.func(openpgp.EntityList) []openpgp.Key	func("".EntityList) []"".Key          Btype.func("".EntityList) []"".Key   |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"       .      tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key"   tgo.string."func(openpgp.EntityList, uint64) []openpgp.Key" `  ^func(openpgp.EntityList, uint64) []openpgp.Key  Rtype.func("".EntityList, uint64) []"".Key          3                                                           runtime.algarray   (  "runtime.gcbits.01   0  |go.string.hdr."func(openpgp.EntityList, uint64) []openpgp.Key"   @  dgo.weak.type.*func("".EntityList, uint64) []"".Key   P Rtype.func("".EntityList, uint64) []"".Key   h Rtype.func("".EntityList, uint64) []"".Key     $type."".EntityList     type.uint64     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64) []openpgp.Key	func("".EntityList, uint64) []"".Key          Rtype.func("".EntityList, uint64) []"".Key   go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"       5      go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   go.string."func(openpgp.EntityList, uint64, uint8) []openpgp.Key" p  lfunc(openpgp.EntityList, uint64, uint8) []openpgp.Key  `type.func("".EntityList, uint64, uint8) []"".Key         eᒑ 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(openpgp.EntityList, uint64, uint8) []openpgp.Key"   @  rgo.weak.type.*func("".EntityList, uint64, uint8) []"".Key   P `type.func("".EntityList, uint64, uint8) []"".Key   h `type.func("".EntityList, uint64, uint8) []"".Key     $type."".EntityList     type.uint64     type.uint8     type.[]"".Key   go.typelink.func(openpgp.EntityList, uint64, uint8) []openpgp.Key	func("".EntityList, uint64, uint8) []"".Key          `type.func("".EntityList, uint64, uint8) []"".Key   $type."".EntityList          G                                                                                                                   0   runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."openpgp.EntityList"   @  &type.*"".EntityList   H  type.*"".Entity   8P $type."".EntityList   P  4go.string.hdr."EntityList"   X  "go.importpath."".   `x $type."".EntityList   x  <go.string.hdr."DecryptionKeys"     (type.func() []"".Key     Btype.func("".EntityList) []"".Key     >"".(*EntityList).DecryptionKeys     8"".EntityList.DecryptionKeys     0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     Rtype.func("".EntityList, uint64) []"".Key     2"".(*EntityList).KeysById     ,"".EntityList.KeysById     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key     `type.func("".EntityList, uint64, uint8) []"".Key     <"".(*EntityList).KeysByIdUsage     6"".EntityList.KeysByIdUsage   @go.string.hdr."**openpgp.Entity"             8go.string."**openpgp.Entity"   8go.string."**openpgp.Entity" (  "**openpgp.Entity   type.**"".Entity P  P      \f 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."**openpgp.Entity"   @  2go.weak.type.***"".Entity   H  type.*"".Entity   6go.string.hdr."[]io.Reader"             .go.string."[]io.Reader"   .go.string."[]io.Reader"   []io.Reader   type.[]io.Reader P  P      ~z|                         
   runtime.algarray   (  "runtime.gcbits.01   0  6go.string.hdr."[]io.Reader"   @  2go.weak.type.*[]io.Reader   H  type.io.Reader   Fgo.typelink.[]io.Reader	[]io.Reader           type.[]io.Reader   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc.[1]io.Reader          .type..hash.[1]io.Reader   2type..eqfunc.[1]io.Reader          *type..eq.[1]io.Reader   ,type..alg.[1]io.Reader              6type..hashfunc.[1]io.Reader     2type..eqfunc.[1]io.Reader   8go.string.hdr."[1]io.Reader"             0go.string."[1]io.Reader"   0go.string."[1]io.Reader"    [1]io.Reader  "type.[1]io.Reader `  `      Rx                                   ,type..alg.[1]io.Reader   (  "runtime.gcbits.03   0  8go.string.hdr."[1]io.Reader"   @  4go.weak.type.*[1]io.Reader   H  type.io.Reader   P   type.[]io.Reader   Jgo.typelink.[1]io.Reader	[1]io.Reader          "type.[1]io.Reader   :go.string.hdr."*[1]io.Reader"             2go.string."*[1]io.Reader"   2go.string."*[1]io.Reader"    *[1]io.Reader  $type.*[1]io.Reader P  P      &2 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  :go.string.hdr."*[1]io.Reader"   @  6go.weak.type.**[1]io.Reader   H  "type.[1]io.Reader   >go.string.hdr."[]packet.Packet"             6go.string."[]packet.Packet"   6go.string."[]packet.Packet"     []packet.Packet  `type.[]golang.org/x/crypto/openpgp/packet.Packet P  P      qM                          
   runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."[]packet.Packet"   @  rgo.weak.type.*[]golang.org/x/crypto/openpgp/packet.Packet   H  \type.golang.org/x/crypto/openpgp/packet.Packet   go.typelink.[]packet.Packet	[]golang.org/x/crypto/openpgp/packet.Packet          `type.[]golang.org/x/crypto/openpgp/packet.Packet   Dgo.string.hdr."**packet.Signature"             <go.string."**packet.Signature"   <go.string."**packet.Signature" (  &**packet.Signature  ftype.**golang.org/x/crypto/openpgp/packet.Signature P  P      d:u 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."**packet.Signature"   @  xgo.weak.type.***golang.org/x/crypto/openpgp/packet.Signature   H  dtype.*golang.org/x/crypto/openpgp/packet.Signature   0go.string.hdr."[]uint64"             (go.string."[]uint64"   (go.string."[]uint64"   []uint64  type.[]uint64 P  P      ?i                          
   runtime.algarray   (  "runtime.gcbits.01   0  0go.string.hdr."[]uint64"   @  ,go.weak.type.*[]uint64   H  type.uint64   :go.typelink.[]uint64	[]uint64          type.[]uint64   Ngo.string.hdr."*openpgp.MessageDetails"             Fgo.string."*openpgp.MessageDetails"   Fgo.string."*openpgp.MessageDetails" 0  0*openpgp.MessageDetails  .type.*"".MessageDetails  P  P      N 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*openpgp.MessageDetails"   @  @go.weak.type.**"".MessageDetails   H  ,type."".MessageDetails   *runtime.gcbits.e2f11f    Lgo.string.hdr."openpgp.MessageDetails"             Dgo.string."openpgp.MessageDetails"   Dgo.string."openpgp.MessageDetails" 0  .openpgp.MessageDetails  6go.string.hdr."IsEncrypted"             .go.string."IsEncrypted"   .go.string."IsEncrypted"   IsEncrypted  Bgo.string.hdr."EncryptedToKeyIds"             :go.string."EncryptedToKeyIds"   :go.string."EncryptedToKeyIds" (  $EncryptedToKeyIds  Pgo.string.hdr."IsSymmetricallyEncrypted"             Hgo.string."IsSymmetricallyEncrypted"   Hgo.string."IsSymmetricallyEncrypted" 8  2IsSymmetricallyEncrypted  :go.string.hdr."DecryptedWith"             2go.string."DecryptedWith"   2go.string."DecryptedWith"    DecryptedWith  0go.string.hdr."IsSigned"             (go.string."IsSigned"   (go.string."IsSigned"   IsSigned  :go.string.hdr."SignedByKeyId"             2go.string."SignedByKeyId"   2go.string."SignedByKeyId"    SignedByKeyId  0go.string.hdr."SignedBy"             (go.string."SignedBy"   (go.string."SignedBy"   SignedBy  6go.string.hdr."LiteralData"             .go.string."LiteralData"   .go.string."LiteralData"   LiteralData  <go.string.hdr."UnverifiedBody"             4go.string."UnverifiedBody"   4go.string."UnverifiedBody"    UnverifiedBody  <go.string.hdr."SignatureError"             4go.string."SignatureError"   4go.string."SignatureError"    SignatureError  2go.string.hdr."Signature"       	      *go.string."Signature"   *go.string."Signature"   Signature  2go.string.hdr."decrypted"       	      *go.string."decrypted"   *go.string."decrypted"   decrypted  <go.string.hdr."MessageDetails"             4go.string."MessageDetails"   4go.string."MessageDetails"    MessageDetails  ,type."".MessageDetails    T   T   1                                                                                                                            $                   (                   0                   4                   8                   @                   H                   L                       D p  runtime.algarray   (  *runtime.gcbits.e2f11f   0  Lgo.string.hdr."openpgp.MessageDetails"   @  .type.*"".MessageDetails   H` ,type."".MessageDetails   `  6go.string.hdr."IsEncrypted"   p  type.bool     Bgo.string.hdr."EncryptedToKeyIds"     type.[]uint64     Pgo.string.hdr."IsSymmetricallyEncrypted"     type.bool     :go.string.hdr."DecryptedWith"     type."".Key     0go.string.hdr."IsSigned"     type.bool     :go.string.hdr."SignedByKeyId"     type.uint64     0go.string.hdr."SignedBy"     type.*"".Key     6go.string.hdr."LiteralData"     htype.*golang.org/x/crypto/openpgp/packet.LiteralData     <go.string.hdr."UnverifiedBody"     type.io.Reader     <go.string.hdr."SignatureError"     type.error     2go.string.hdr."Signature"     dtype.*golang.org/x/crypto/openpgp/packet.Signature     2go.string.hdr."decrypted"     "go.importpath."".     $type.io.ReadCloser   8 ,type."".MessageDetails     <go.string.hdr."MessageDetails"     "go.importpath."".    ,type."".MessageDetails   ,go.string.hdr."[]bool"             $go.string."[]bool"   $go.string."[]bool"   []bool  type.[]bool P  P                               
   runtime.algarray   (  "runtime.gcbits.01   0  ,go.string.hdr."[]bool"   @  (go.weak.type.*[]bool   H  type.bool   2go.typelink.[]bool	[]bool          type.[]bool   .go.string.hdr."[8]bool"             &go.string."[8]bool"   &go.string."[8]bool"   [8]bool  type.[8]bool `  `       s5                                 P  runtime.algarray   (  runtime.gcbits.   0  .go.string.hdr."[8]bool"   @  *go.weak.type.*[8]bool   H  type.bool   P  type.[]bool   6go.typelink.[8]bool	[8]bool          type.[8]bool   Ngo.string.hdr."*map.bucket[string]bool"             Fgo.string."*map.bucket[string]bool"   Fgo.string."*map.bucket[string]bool" 0  0*map.bucket[string]bool  8type.*map.bucket[string]bool P  P      [E 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*map.bucket[string]bool"   @  Jgo.weak.type.**map.bucket[string]bool   H  6type.map.bucket[string]bool   *runtime.gcbits.545511   TU Lgo.string.hdr."map.bucket[string]bool"             Dgo.string."map.bucket[string]bool"   Dgo.string."map.bucket[string]bool" 0  .map.bucket[string]bool  6type.map.bucket[string]bool   T   T   2aB                                                                                      H                   P    p  runtime.algarray   (  *runtime.gcbits.545511   0  Lgo.string.hdr."map.bucket[string]bool"   @  Hgo.weak.type.*map.bucket[string]bool   H` 6type.map.bucket[string]bool   `  .go.string.hdr."topbits"   p  type.[8]uint8     (go.string.hdr."keys"     type.[8]string     ,go.string.hdr."values"     type.[8]bool     0go.string.hdr."overflow"     8type.*map.bucket[string]bool   Fgo.string.hdr."map.hdr[string]bool"             >go.string."map.hdr[string]bool"   >go.string."map.hdr[string]bool" (  (map.hdr[string]bool  0type.map.hdr[string]bool         3(                                                                                                                                                                                        * p  runtime.algarray   (  "runtime.gcbits.58   0  Fgo.string.hdr."map.hdr[string]bool"   @  Bgo.weak.type.*map.hdr[string]bool   H` 0type.map.hdr[string]bool   `  *go.string.hdr."count"   p  type.int     *go.string.hdr."flags"     type.uint8     "go.string.hdr."B"     type.uint8     *go.string.hdr."hash0"     type.uint32     .go.string.hdr."buckets"     8type.*map.bucket[string]bool     4go.string.hdr."oldbuckets"     8type.*map.bucket[string]bool     2go.string.hdr."nevacuate"     type.uintptr     0go.string.hdr."overflow"     &type.unsafe.Pointer   >go.string.hdr."map[string]bool"             6go.string."map[string]bool"   6go.string."map[string]bool"     map[string]bool  (type.map[string]bool x  x       5                                      T    runtime.algarray   (  "runtime.gcbits.01   0  >go.string.hdr."map[string]bool"   @  :go.weak.type.*map[string]bool   H  type.string   P  type.bool   X  6type.map.bucket[string]bool   `  0type.map.hdr[string]bool   Vgo.typelink.map[string]bool	map[string]bool          (type.map[string]bool   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·1347047f6245a35b91e9a4f213167d52             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·6d46c0650eba7dbebc0db316e0e0cf3b             @go.string.hdr."*openpgp.KeyRing"             8go.string."*openpgp.KeyRing"   8go.string."*openpgp.KeyRing" (  "*openpgp.KeyRing   type.*"".KeyRing  P  P      $ 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."*openpgp.KeyRing"   @  2go.weak.type.**"".KeyRing   H  type."".KeyRing   >go.string.hdr."openpgp.KeyRing"             6go.string."openpgp.KeyRing"   6go.string."openpgp.KeyRing"     openpgp.KeyRing  .go.string.hdr."KeyRing"             &go.string."KeyRing"   &go.string."KeyRing"   KeyRing  type."".KeyRing          N                                                                                          runtime.algarray   (  "runtime.gcbits.03   0  >go.string.hdr."openpgp.KeyRing"   @   type.*"".KeyRing   H` type."".KeyRing   `  <go.string.hdr."DecryptionKeys"   p  (type.func() []"".Key   x  0go.string.hdr."KeysById"     4type.func(uint64) []"".Key     :go.string.hdr."KeysByIdUsage"     Btype.func(uint64, uint8) []"".Key   8 type."".KeyRing     .go.string.hdr."KeyRing"     "go.importpath."".    type."".KeyRing   Ngo.string.hdr."*openpgp.PromptFunction"             Fgo.string."*openpgp.PromptFunction"   Fgo.string."*openpgp.PromptFunction" 0  0*openpgp.PromptFunction  .type.*"".PromptFunction  P  P      !g 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."*openpgp.PromptFunction"   @  @go.weak.type.**"".PromptFunction   H  ,type."".PromptFunction   Lgo.string.hdr."openpgp.PromptFunction"             Dgo.string."openpgp.PromptFunction"   Dgo.string."openpgp.PromptFunction" 0  .openpgp.PromptFunction  <go.string.hdr."PromptFunction"             4go.string."PromptFunction"   4go.string."PromptFunction"    PromptFunction  ,type."".PromptFunction          4 3                                                                                   runtime.algarray   (  "runtime.gcbits.01   0  Lgo.string.hdr."openpgp.PromptFunction"   @  .type.*"".PromptFunction   P ,type."".PromptFunction   h ,type."".PromptFunction     type.[]"".Key     type.bool     type.[]uint8     type.error   8 ,type."".PromptFunction     <go.string.hdr."PromptFunction"     "go.importpath."".    ,type."".PromptFunction   ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"             Vgo.string."[]*packet.SymmetricKeyEncrypted"   Vgo.string."[]*packet.SymmetricKeyEncrypted" @  @[]*packet.SymmetricKeyEncrypted  type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted P  P      ް-                         
   runtime.algarray   (  "runtime.gcbits.01   0  ^go.string.hdr."[]*packet.SymmetricKeyEncrypted"   @  go.weak.type.*[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   H  |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   go.typelink.[]*packet.SymmetricKeyEncrypted	[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted          type.[]*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted    type..hashfunc20             ,runtime.memhash_varlen   type..eqfunc20             .runtime.memequal_varlen   type..alg20               type..hashfunc20     type..eqfunc20   Pgo.string.hdr."*openpgp.keyEnvelopePair"             Hgo.string."*openpgp.keyEnvelopePair"   Hgo.string."*openpgp.keyEnvelopePair" 8  2*openpgp.keyEnvelopePair  0type.*"".keyEnvelopePair  P  P      GR4 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."*openpgp.keyEnvelopePair"   @  Bgo.weak.type.**"".keyEnvelopePair   H  .type."".keyEnvelopePair   "runtime.gcbits.1f    Ngo.string.hdr."openpgp.keyEnvelopePair"             Fgo.string."openpgp.keyEnvelopePair"   Fgo.string."openpgp.keyEnvelopePair" 0  0openpgp.keyEnvelopePair  8go.string.hdr."encryptedKey"             0go.string."encryptedKey"   0go.string."encryptedKey"    encryptedKey  >go.string.hdr."keyEnvelopePair"             6go.string."keyEnvelopePair"   6go.string."keyEnvelopePair"     keyEnvelopePair  .type."".keyEnvelopePair                                                                                                       type..alg20   (  "runtime.gcbits.1f   0  Ngo.string.hdr."openpgp.keyEnvelopePair"   @  0type.*"".keyEnvelopePair   H` .type."".keyEnvelopePair   `  &go.string.hdr."key"   h  "go.importpath."".   p  type."".Key     8go.string.hdr."encryptedKey"     "go.importpath."".     jtype.*golang.org/x/crypto/openpgp/packet.EncryptedKey   8 .type."".keyEnvelopePair     >go.string.hdr."keyEnvelopePair"     "go.importpath."".    .type."".keyEnvelopePair   Rgo.string.hdr."[]openpgp.keyEnvelopePair"             Jgo.string."[]openpgp.keyEnvelopePair"   Jgo.string."[]openpgp.keyEnvelopePair" 8  4[]openpgp.keyEnvelopePair  2type.[]"".keyEnvelopePair P  P      r                         
   runtime.algarray   (  "runtime.gcbits.01   0  Rgo.string.hdr."[]openpgp.keyEnvelopePair"   @  Dgo.weak.type.*[]"".keyEnvelopePair   H  .type."".keyEnvelopePair   tgo.typelink.[]openpgp.keyEnvelopePair	[]"".keyEnvelopePair          2type.[]"".keyEnvelopePair   \go.string.hdr."**packet.SymmetricKeyEncrypted"             Tgo.string."**packet.SymmetricKeyEncrypted"   Tgo.string."**packet.SymmetricKeyEncrypted" @  >**packet.SymmetricKeyEncrypted  ~type.**golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted P  P      Z 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  \go.string.hdr."**packet.SymmetricKeyEncrypted"   @  go.weak.type.***golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   H  |type.*golang.org/x/crypto/openpgp/packet.SymmetricKeyEncrypted   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Ltype..hashfunc."".signatureCheckReader          Dtype..hash."".signatureCheckReader   Htype..eqfunc."".signatureCheckReader          @type..eq."".signatureCheckReader   Btype..alg."".signatureCheckReader              Ltype..hashfunc."".signatureCheckReader     Htype..eqfunc."".signatureCheckReader   Zgo.string.hdr."*openpgp.signatureCheckReader"             Rgo.string."*openpgp.signatureCheckReader"   Rgo.string."*openpgp.signatureCheckReader" @  <*openpgp.signatureCheckReader  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"       9      go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   go.string."func(*openpgp.signatureCheckReader, []uint8) (int, error)" x  tfunc(*openpgp.signatureCheckReader, []uint8) (int, error)  rtype.func(*"".signatureCheckReader, []uint8) (int, error)         @. 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.signatureCheckReader, []uint8) (int, error)"   @  go.weak.type.*func(*"".signatureCheckReader, []uint8) (int, error)   P rtype.func(*"".signatureCheckReader, []uint8) (int, error)   h rtype.func(*"".signatureCheckReader, []uint8) (int, error)     :type.*"".signatureCheckReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureCheckReader, []uint8) (int, error)	func(*"".signatureCheckReader, []uint8) (int, error)          rtype.func(*"".signatureCheckReader, []uint8) (int, error)   (go.string.hdr."Read"              go.string."Read"    go.string."Read"   
Read  :type.*"".signatureCheckReader          :a 6                                                                   @  runtime.algarray   (  "runtime.gcbits.01   0  Zgo.string.hdr."*openpgp.signatureCheckReader"   @  Lgo.weak.type.**"".signatureCheckReader   H  8type."".signatureCheckReader   8P :type.*"".signatureCheckReader   `x :type.*"".signatureCheckReader   x  (go.string.hdr."Read"     >type.func([]uint8) (int, error)     rtype.func(*"".signatureCheckReader, []uint8) (int, error)     >"".(*signatureCheckReader).Read     >"".(*signatureCheckReader).Read   "runtime.gcbits.3f   ? Xgo.string.hdr."openpgp.signatureCheckReader"             Pgo.string."openpgp.signatureCheckReader"   Pgo.string."openpgp.signatureCheckReader" @  :openpgp.signatureCheckReader  .go.string.hdr."packets"             &go.string."packets"   &go.string."packets"   packets  6go.string.hdr."wrappedHash"             .go.string."wrappedHash"   .go.string."wrappedHash"   wrappedHash  $go.string.hdr."md"             go.string."md"   go.string."md"   md  Hgo.string.hdr."signatureCheckReader"             @go.string."signatureCheckReader"   @go.string."signatureCheckReader" 0  *signatureCheckReader  8type."".signatureCheckReader          MA                                                                                                                                *   Btype..alg."".signatureCheckReader   (  "runtime.gcbits.3f   0  Xgo.string.hdr."openpgp.signatureCheckReader"   @  :type.*"".signatureCheckReader   H` 8type."".signatureCheckReader   `  .go.string.hdr."packets"   h  "go.importpath."".   p  ^type.*golang.org/x/crypto/openpgp/packet.Reader     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     6go.string.hdr."wrappedHash"     "go.importpath."".     type.hash.Hash     $go.string.hdr."md"     "go.importpath."".     .type.*"".MessageDetails   8 8type."".signatureCheckReader     Hgo.string.hdr."signatureCheckReader"     "go.importpath."".    8type."".signatureCheckReader   Hgo.string.hdr."*openpgp.checkReader"             @go.string."*openpgp.checkReader"   @go.string."*openpgp.checkReader" 0  **openpgp.checkReader  6go.string.hdr."checkReader"             .go.string."checkReader"   .go.string."checkReader"   checkReader  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"       0      xgo.string."func(*openpgp.checkReader, []uint8) (int, error)"   xgo.string."func(*openpgp.checkReader, []uint8) (int, error)" h  bfunc(*openpgp.checkReader, []uint8) (int, error)  `type.func(*"".checkReader, []uint8) (int, error)         V#. 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.checkReader, []uint8) (int, error)"   @  rgo.weak.type.*func(*"".checkReader, []uint8) (int, error)   P `type.func(*"".checkReader, []uint8) (int, error)   h `type.func(*"".checkReader, []uint8) (int, error)     (type.*"".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.checkReader, []uint8) (int, error)	func(*"".checkReader, []uint8) (int, error)          `type.func(*"".checkReader, []uint8) (int, error)   (type.*"".checkReader           6                                                                   @  runtime.algarray   (  "runtime.gcbits.01   0  Hgo.string.hdr."*openpgp.checkReader"   @  :go.weak.type.**"".checkReader   H  &type."".checkReader   8P (type.*"".checkReader   `x (type.*"".checkReader   x  (go.string.hdr."Read"     >type.func([]uint8) (int, error)     `type.func(*"".checkReader, []uint8) (int, error)     ,"".(*checkReader).Read     ,"".(*checkReader).Read   Fgo.string.hdr."openpgp.checkReader"             >go.string."openpgp.checkReader"   >go.string."openpgp.checkReader" (  (openpgp.checkReader  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"       /      vgo.string."func(openpgp.checkReader, []uint8) (int, error)"   vgo.string."func(openpgp.checkReader, []uint8) (int, error)" `  `func(openpgp.checkReader, []uint8) (int, error)  ^type.func("".checkReader, []uint8) (int, error)         1f 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(openpgp.checkReader, []uint8) (int, error)"   @  pgo.weak.type.*func("".checkReader, []uint8) (int, error)   P ^type.func("".checkReader, []uint8) (int, error)   h ^type.func("".checkReader, []uint8) (int, error)     &type."".checkReader     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.checkReader, []uint8) (int, error)	func("".checkReader, []uint8) (int, error)          ^type.func("".checkReader, []uint8) (int, error)   &type."".checkReader          $ 9                                                                                            " @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."openpgp.checkReader"   @  (type.*"".checkReader   H` &type."".checkReader   `  $go.string.hdr."md"   h  "go.importpath."".   p  .type.*"".MessageDetails   8 &type."".checkReader     6go.string.hdr."checkReader"     "go.importpath."".    &type."".checkReader     (go.string.hdr."Read"     >type.func([]uint8) (int, error)     ^type.func("".checkReader, []uint8) (int, error)     &"".checkReader.Read     &"".checkReader.Read   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·a8eabfc4a4514ed6b3b0c61e9680e440              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             6type..hashfunc."".FileHints          .type..hash."".FileHints   2type..eqfunc."".FileHints          *type..eq."".FileHints   ,type..alg."".FileHints              6type..hashfunc."".FileHints     2type..eqfunc."".FileHints   "runtime.gcbits.42   B Bgo.string.hdr."openpgp.FileHints"             :go.string."openpgp.FileHints"   :go.string."openpgp.FileHints" (  $openpgp.FileHints  0go.string.hdr."IsBinary"             (go.string."IsBinary"   (go.string."IsBinary"   IsBinary  0go.string.hdr."FileName"             (go.string."FileName"   (go.string."FileName"   FileName  .go.string.hdr."ModTime"             &go.string."ModTime"   &go.string."ModTime"   ModTime  2go.string.hdr."FileHints"       	      *go.string."FileHints"   *go.string."FileHints"   FileHints  "type."".FileHints          82                                                                                                                ,type..alg."".FileHints   (  "runtime.gcbits.42   0  Bgo.string.hdr."openpgp.FileHints"   @  $type.*"".FileHints   H` "type."".FileHints   `  0go.string.hdr."IsBinary"   p  type.bool     0go.string.hdr."FileName"     type.string     .go.string.hdr."ModTime"     type.time.Time   8 "type."".FileHints     2go.string.hdr."FileHints"     "go.importpath."".    "type."".FileHints   Dgo.string.hdr."*openpgp.FileHints"             <go.string."*openpgp.FileHints"   <go.string."*openpgp.FileHints" (  &*openpgp.FileHints  $type.*"".FileHints  P  P      j 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Dgo.string.hdr."*openpgp.FileHints"   @  6go.weak.type.**"".FileHints   H  "type."".FileHints   Fgo.string.hdr."*openpgp.noOpCloser"             >go.string."*openpgp.noOpCloser"   >go.string."*openpgp.noOpCloser" (  (*openpgp.noOpCloser  4go.string.hdr."noOpCloser"       
      ,go.string."noOpCloser"   ,go.string."noOpCloser"   noOpCloser  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             *go.string.hdr."Close"             "go.string."Close"   "go.string."Close"   Close  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             ^go.string.hdr."func(*openpgp.noOpCloser) error"             Vgo.string."func(*openpgp.noOpCloser) error"   Vgo.string."func(*openpgp.noOpCloser) error" @  @func(*openpgp.noOpCloser) error  >type.func(*"".noOpCloser) error         $_ 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  ^go.string.hdr."func(*openpgp.noOpCloser) error"   @  Pgo.weak.type.*func(*"".noOpCloser) error   P >type.func(*"".noOpCloser) error   h >type.func(*"".noOpCloser) error     &type.*"".noOpCloser     type.error   go.typelink.func(*openpgp.noOpCloser) error	func(*"".noOpCloser) error          >type.func(*"".noOpCloser) error   ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"       /      vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)"   vgo.string."func(*openpgp.noOpCloser, []uint8) (int, error)" `  `func(*openpgp.noOpCloser, []uint8) (int, error)  ^type.func(*"".noOpCloser, []uint8) (int, error)         6rA 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(*openpgp.noOpCloser, []uint8) (int, error)"   @  pgo.weak.type.*func(*"".noOpCloser, []uint8) (int, error)   P ^type.func(*"".noOpCloser, []uint8) (int, error)   h ^type.func(*"".noOpCloser, []uint8) (int, error)     &type.*"".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.noOpCloser, []uint8) (int, error)	func(*"".noOpCloser, []uint8) (int, error)          ^type.func(*"".noOpCloser, []uint8) (int, error)   8go.string.hdr."func() error"             0go.string."func() error"   0go.string."func() error"    func() error  "type.func() error         ֵ 3                                                     runtime.algarray   (  "runtime.gcbits.01   0  8go.string.hdr."func() error"   @  4go.weak.type.*func() error   P "type.func() error   h "type.func() error     type.error   Jgo.typelink.func() error	func() error          "type.func() error   &type.*"".noOpCloser          ML 6                                                                                          " @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."*openpgp.noOpCloser"   @  8go.weak.type.**"".noOpCloser   H  $type."".noOpCloser   8P &type.*"".noOpCloser   `x &type.*"".noOpCloser   x  *go.string.hdr."Close"     "type.func() error     >type.func(*"".noOpCloser) error     ,"".(*noOpCloser).Close     ,"".(*noOpCloser).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ^type.func(*"".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     ,"".(*noOpCloser).Write   Dgo.string.hdr."openpgp.noOpCloser"             <go.string."openpgp.noOpCloser"   <go.string."openpgp.noOpCloser" (  &openpgp.noOpCloser  "go.string.hdr."w"             go.string."w"   go.string."w"   w  \go.string.hdr."func(openpgp.noOpCloser) error"             Tgo.string."func(openpgp.noOpCloser) error"   Tgo.string."func(openpgp.noOpCloser) error" @  >func(openpgp.noOpCloser) error  <type.func("".noOpCloser) error         4Y9 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  \go.string.hdr."func(openpgp.noOpCloser) error"   @  Ngo.weak.type.*func("".noOpCloser) error   P <type.func("".noOpCloser) error   h <type.func("".noOpCloser) error     $type."".noOpCloser     type.error   go.typelink.func(openpgp.noOpCloser) error	func("".noOpCloser) error          <type.func("".noOpCloser) error   |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"       .      tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)"   tgo.string."func(openpgp.noOpCloser, []uint8) (int, error)" `  ^func(openpgp.noOpCloser, []uint8) (int, error)  \type.func("".noOpCloser, []uint8) (int, error)         ~9 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  |go.string.hdr."func(openpgp.noOpCloser, []uint8) (int, error)"   @  ngo.weak.type.*func("".noOpCloser, []uint8) (int, error)   P \type.func("".noOpCloser, []uint8) (int, error)   h \type.func("".noOpCloser, []uint8) (int, error)     $type."".noOpCloser     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.noOpCloser, []uint8) (int, error)	func("".noOpCloser, []uint8) (int, error)          \type.func("".noOpCloser, []uint8) (int, error)   $type."".noOpCloser          n                                                                                                                     ,   runtime.algarray   (  "runtime.gcbits.03   0  Dgo.string.hdr."openpgp.noOpCloser"   @  &type.*"".noOpCloser   H` $type."".noOpCloser   `  "go.string.hdr."w"   h  "go.importpath."".   p  type.io.Writer   8 $type."".noOpCloser     4go.string.hdr."noOpCloser"     "go.importpath."".    $type."".noOpCloser     *go.string.hdr."Close"     "type.func() error     <type.func("".noOpCloser) error     ,"".(*noOpCloser).Close     &"".noOpCloser.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     \type.func("".noOpCloser, []uint8) (int, error)     ,"".(*noOpCloser).Write     &"".noOpCloser.Write   Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             Tgclocals·895d0569a38a56443b84805daa09d838              Tgclocals·3bb21ca8fe1d99a3e492463bd711418a             Btype..hashfunc."".signatureWriter          :type..hash."".signatureWriter   >type..eqfunc."".signatureWriter          6type..eq."".signatureWriter   8type..alg."".signatureWriter              Btype..hashfunc."".signatureWriter     >type..eqfunc."".signatureWriter   Pgo.string.hdr."*openpgp.signatureWriter"             Hgo.string."*openpgp.signatureWriter"   Hgo.string."*openpgp.signatureWriter" 8  2*openpgp.signatureWriter  >go.string.hdr."signatureWriter"             6go.string."signatureWriter"   6go.string."signatureWriter"     signatureWriter  Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·b60dc0a6046c556b02baa766a3fd5a27             Tgclocals·33cdeccccebe80329f1fdbee7f5874cb           Tgclocals·0b86ef39f3fed835f14ba5f4d7c62fa2             hgo.string.hdr."func(*openpgp.signatureWriter) error"       $      `go.string."func(*openpgp.signatureWriter) error"   `go.string."func(*openpgp.signatureWriter) error" P  Jfunc(*openpgp.signatureWriter) error  Htype.func(*"".signatureWriter) error         / 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  hgo.string.hdr."func(*openpgp.signatureWriter) error"   @  Zgo.weak.type.*func(*"".signatureWriter) error   P Htype.func(*"".signatureWriter) error   h Htype.func(*"".signatureWriter) error     0type.*"".signatureWriter     type.error   go.typelink.func(*openpgp.signatureWriter) error	func(*"".signatureWriter) error          Htype.func(*"".signatureWriter) error   go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"       4      go.string."func(*openpgp.signatureWriter, []uint8) (int, error)"   go.string."func(*openpgp.signatureWriter, []uint8) (int, error)" p  jfunc(*openpgp.signatureWriter, []uint8) (int, error)  htype.func(*"".signatureWriter, []uint8) (int, error)         l 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*openpgp.signatureWriter, []uint8) (int, error)"   @  zgo.weak.type.*func(*"".signatureWriter, []uint8) (int, error)   P htype.func(*"".signatureWriter, []uint8) (int, error)   h htype.func(*"".signatureWriter, []uint8) (int, error)     0type.*"".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(*openpgp.signatureWriter, []uint8) (int, error)	func(*"".signatureWriter, []uint8) (int, error)          htype.func(*"".signatureWriter, []uint8) (int, error)   0type.*"".signatureWriter          + 6                                                                                          " @  runtime.algarray   (  "runtime.gcbits.01   0  Pgo.string.hdr."*openpgp.signatureWriter"   @  Bgo.weak.type.**"".signatureWriter   H  .type."".signatureWriter   8P 0type.*"".signatureWriter   `x 0type.*"".signatureWriter   x  *go.string.hdr."Close"     "type.func() error     Htype.func(*"".signatureWriter) error     6"".(*signatureWriter).Close     6"".(*signatureWriter).Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     htype.func(*"".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     6"".(*signatureWriter).Write   &runtime.gcbits.ef01    Ngo.string.hdr."openpgp.signatureWriter"             Fgo.string."openpgp.signatureWriter"   Fgo.string."openpgp.signatureWriter" 0  0openpgp.signatureWriter  :go.string.hdr."encryptedData"             2go.string."encryptedData"   2go.string."encryptedData"    encryptedData  6go.string.hdr."literalData"             .go.string."literalData"   .go.string."literalData"   literalData  0go.string.hdr."hashType"             (go.string."hashType"   (go.string."hashType"   hashType  ,go.string.hdr."signer"             $go.string."signer"   $go.string."signer"   signer  ,go.string.hdr."config"             $go.string."config"   $go.string."config"   config  fgo.string.hdr."func(openpgp.signatureWriter) error"       #      ^go.string."func(openpgp.signatureWriter) error"   ^go.string."func(openpgp.signatureWriter) error" H  Hfunc(openpgp.signatureWriter) error  Ftype.func("".signatureWriter) error         ! 3                                                       runtime.algarray   (  "runtime.gcbits.01   0  fgo.string.hdr."func(openpgp.signatureWriter) error"   @  Xgo.weak.type.*func("".signatureWriter) error   P Ftype.func("".signatureWriter) error   h Ftype.func("".signatureWriter) error     .type."".signatureWriter     type.error   go.typelink.func(openpgp.signatureWriter) error	func("".signatureWriter) error          Ftype.func("".signatureWriter) error   go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"       3      ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)"   ~go.string."func(openpgp.signatureWriter, []uint8) (int, error)" h  hfunc(openpgp.signatureWriter, []uint8) (int, error)  ftype.func("".signatureWriter, []uint8) (int, error)         E 3                                                               runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(openpgp.signatureWriter, []uint8) (int, error)"   @  xgo.weak.type.*func("".signatureWriter, []uint8) (int, error)   P ftype.func("".signatureWriter, []uint8) (int, error)   h ftype.func("".signatureWriter, []uint8) (int, error)     .type."".signatureWriter     type.[]uint8     type.int     type.error   go.typelink.func(openpgp.signatureWriter, []uint8) (int, error)	func("".signatureWriter, []uint8) (int, error)          ftype.func("".signatureWriter, []uint8) (int, error)   .type."".signatureWriter    $   $   դ                                                                                                                                                                                                                     J   8type..alg."".signatureWriter   (  &runtime.gcbits.ef01   0  Ngo.string.hdr."openpgp.signatureWriter"   @  0type.*"".signatureWriter   H` .type."".signatureWriter   `  :go.string.hdr."encryptedData"   h  "go.importpath."".   p  &type.io.WriteCloser     6go.string.hdr."literalData"     "go.importpath."".     &type.io.WriteCloser     0go.string.hdr."hashType"     "go.importpath."".      type.crypto.Hash     "go.string.hdr."h"     "go.importpath."".     type.hash.Hash     ,go.string.hdr."signer"     "go.importpath."".     ftype.*golang.org/x/crypto/openpgp/packet.PrivateKey     ,go.string.hdr."config"     "go.importpath."".     ^type.*golang.org/x/crypto/openpgp/packet.Config   8 .type."".signatureWriter     >go.string.hdr."signatureWriter"     "go.importpath."".    .type."".signatureWriter     *go.string.hdr."Close"     "type.func() error     Ftype.func("".signatureWriter) error     6"".(*signatureWriter).Close     0"".signatureWriter.Close     *go.string.hdr."Write"     >type.func([]uint8) (int, error)     ftype.func("".signatureWriter, []uint8) (int, error)     6"".(*signatureWriter).Write     0"".signatureWriter.Write   Bgo.string.hdr."[]*openpgp.Entity"             :go.string."[]*openpgp.Entity"   :go.string."[]*openpgp.Entity" (  $[]*openpgp.Entity  "type.[]*"".Entity P  P      5^                         
   runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."[]*openpgp.Entity"   @  4go.weak.type.*[]*"".Entity   H  type.*"".Entity   Tgo.typelink.[]*openpgp.Entity	[]*"".Entity          "type.[]*"".Entity   type..hashfunc3             ,runtime.memhash_varlen   type..eqfunc3             .runtime.memequal_varlen   type..alg3              type..hashfunc3     type..eqfunc3   0go.string.hdr."[3]uint8"             (go.string."[3]uint8"   (go.string."[3]uint8"   [3]uint8  type.[3]uint8 `  `       ¹R                                   type..alg3   (  runtime.gcbits.   0  0go.string.hdr."[3]uint8"   @  ,go.weak.type.*[3]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[3]uint8	[3]uint8          type.[3]uint8   2go.string.hdr."*[3]uint8"       	      *go.string."*[3]uint8"   *go.string."*[3]uint8"   *[3]uint8  type.*[3]uint8 P  P      ifl 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  2go.string.hdr."*[3]uint8"   @  .go.weak.type.**[3]uint8   H  type.[3]uint8   0go.string.hdr."[4]uint8"             (go.string."[4]uint8"   (go.string."[4]uint8"   [4]uint8  type.[4]uint8 `  `       B                                 @  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[4]uint8"   @  ,go.weak.type.*[4]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[4]uint8	[4]uint8          type.[4]uint8   2go.string.hdr."*[4]uint8"       	      *go.string."*[4]uint8"   *go.string."*[4]uint8"   *[4]uint8  type.*[4]uint8 P  P      G 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  2go.string.hdr."*[4]uint8"   @  .go.weak.type.**[4]uint8   H  type.[4]uint8   2go.string.hdr."[32]uint8"       	      *go.string."[32]uint8"   *go.string."[32]uint8"   [32]uint8  type.[32]uint8 `  `        Y                                    type..alg32   (  runtime.gcbits.   0  2go.string.hdr."[32]uint8"   @  .go.weak.type.*[32]uint8   H  type.uint8   P  type.[]uint8   >go.typelink.[32]uint8	[32]uint8          type.[32]uint8   0go.string.hdr."[2]uint8"             (go.string."[2]uint8"   (go.string."[2]uint8"   [2]uint8  type.[2]uint8 `  `       F                                 0  runtime.algarray   (  runtime.gcbits.   0  0go.string.hdr."[2]uint8"   @  ,go.weak.type.*[2]uint8   H  type.uint8   P  type.[]uint8   :go.typelink.[2]uint8	[2]uint8          type.[2]uint8   4go.string.hdr."*[8]string"       
      ,go.string."*[8]string"   ,go.string."*[8]string"   *[8]string  type.*[8]string P  P      o 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  4go.string.hdr."*[8]string"   @  0go.weak.type.**[8]string   H  type.[8]string   (go.string.hdr."hash"              go.string."hash"    go.string."hash"   
hash  &go.importpath.hash.              go.string."hash"   $go.string.hdr."io"             go.string."io"   go.string."io"   io  "go.importpath.io.             go.string."io"   4go.string.hdr."crypto/rsa"       
      ,go.string."crypto/rsa"   ,go.string."crypto/rsa"   crypto/rsa  2go.importpath.crypto/rsa.       
      ,go.string."crypto/rsa"   ,go.string.hdr."crypto"             $go.string."crypto"   $go.string."crypto"   crypto  *go.importpath.crypto.             $go.string."crypto"   (go.string.hdr."time"              go.string."time"    go.string."time"   
time  &go.importpath.time.              go.string."time"   bgo.string.hdr."golang.org/x/crypto/openpgp/armor"       !      Zgo.string."golang.org/x/crypto/openpgp/armor"   Zgo.string."golang.org/x/crypto/openpgp/armor" H  Dgolang.org/x/crypto/openpgp/armor  `go.importpath.golang.org/x/crypto/openpgp/armor.       !      Zgo.string."golang.org/x/crypto/openpgp/armor"   dgo.string.hdr."golang.org/x/crypto/openpgp/errors"       "      \go.string."golang.org/x/crypto/openpgp/errors"   \go.string."golang.org/x/crypto/openpgp/errors" H  Fgolang.org/x/crypto/openpgp/errors  bgo.importpath.golang.org/x/crypto/openpgp/errors.       "      \go.string."golang.org/x/crypto/openpgp/errors"   .go.string.hdr."strconv"             &go.string."strconv"   &go.string."strconv"   strconv  ,go.importpath.strconv.             &go.string."strconv"   dgo.string.hdr."golang.org/x/crypto/openpgp/packet"       "      \go.string."golang.org/x/crypto/openpgp/packet"   \go.string."golang.org/x/crypto/openpgp/packet" H  Fgolang.org/x/crypto/openpgp/packet  bgo.importpath.golang.org/x/crypto/openpgp/packet.       "      \go.string."golang.org/x/crypto/openpgp/packet"   ^go.string.hdr."golang.org/x/crypto/openpgp/s2k"             Vgo.string."golang.org/x/crypto/openpgp/s2k"   Vgo.string."golang.org/x/crypto/openpgp/s2k" @  @golang.org/x/crypto/openpgp/s2k  \go.importpath.golang.org/x/crypto/openpgp/s2k.             Vgo.string."golang.org/x/crypto/openpgp/s2k"   :go.string.hdr."crypto/sha256"             2go.string."crypto/sha256"   2go.string."crypto/sha256"    crypto/sha256  8go.importpath.crypto/sha256.             2go.string."crypto/sha256"   Dtype..hash."".canonicalTextHash·f          >type..hash."".canonicalTextHash   @type..eq."".canonicalTextHash·f          :type..eq."".canonicalTextHash   .type..hash.[8]string·f          (type..hash.[8]string   *type..eq.[8]string·f          $type..eq.[8]string   8"".(*EntityList).KeysById·f          2"".(*EntityList).KeysById   B"".(*EntityList).KeysByIdUsage·f          <"".(*EntityList).KeysByIdUsage   D"".(*EntityList).DecryptionKeys·f          >"".(*EntityList).DecryptionKeys   4type..hash.[1]io.Reader·f          .type..hash.[1]io.Reader   0type..eq.[1]io.Reader·f          *type..eq.[1]io.Reader   8"".KeyRing.DecryptionKeys·f          2"".KeyRing.DecryptionKeys   ,"".KeyRing.KeysById·f          &"".KeyRing.KeysById   6"".KeyRing.KeysByIdUsage·f          0"".KeyRing.KeysByIdUsage   Jtype..hash."".signatureCheckReader·f          Dtype..hash."".signatureCheckReader   Ftype..eq."".signatureCheckReader·f          @type..eq."".signatureCheckReader   2"".(*checkReader).Read·f          ,"".(*checkReader).Read   4type..hash."".FileHints·f          .type..hash."".FileHints   0type..eq."".FileHints·f          *type..eq."".FileHints   2"".(*noOpCloser).Write·f          ,"".(*noOpCloser).Write   2"".(*noOpCloser).Close·f          ,"".(*noOpCloser).Close   @type..hash."".signatureWriter·f          :type..hash."".signatureWriter   <type..eq."".signatureWriter·f          6type..eq."".signatureWriter   <"".(*signatureWriter).Write·f          6"".(*signatureWriter).Write   <"".(*signatureWriter).Close·f          6"".(*signatureWriter).Close   go13ld 